先来回答两个相关题目！
哪种初始化方式适用于所有类型？

- 结构化绑定：`auto [first, second] = p;`
- 成员逐一初始化：`student.name = "Jacob"`
- 统一初始化：`Student jacob { "Jacob", "NM", 21 }`
正确答案是C！

`stringstream` 是一种什么流？

- 输入流
- 输出流
- 两者都是！
- 两者都不是！
正确答案依然是C！

# 容器
如果你上过cs106B，请你忘记Stanford库的所有内容！（我其实搞不懂为什么106B不直接点，要搞一个这样的库！当然，按照官方说法是106B主要是为了培养学生编程的抽象思维！）

## C++ 中的多种容器
C++ 标准模板库（STL）包含以下常用容器：

- `std::vector`（向量）
- `std::unordered_map`（无序映射）
- `std::set`（集合）
- `std::unordered_set`（无序集合）
- `std::stack`（栈）
- `std::priority_queue`（优先队列）
- `std::queue`（队列）
- `std::deque`（双端队列）
- `std::map`（映射）
- `std::array`（数组）
这还是很多的！
## 该选择哪种容器？

核心在于**空间与时间的权衡**

“空间即时间”—— 比雅尼・斯特劳斯特鲁普（C++ 之父）

## 今日课程大纲

1. 什么是 STL？什么是模板？
    
    “STL 即标准模板库（Standard Template Library）”
2. 序列容器
    
    元素呈线性排列的容器
3. 关联容器
    
    通过唯一键来组织元素的容器

## 声明

本节课涵盖的内容较多！（尽量不要在细节中迷失方向！）

同时需要说明：我们无法覆盖所有知识点！

## 什么是 STL？

STL：全称为 Standard Template Library，即**标准模板库**

这里我们引入一个小故事：

程序员：我需要一种存储整数列表的方式！
开发者：交给我吧！
程序员：我做好了！
```cpp
class IntVector {
    // 用于存储
    // 整数列表的代码...
};
```

程序员：现在我需要存储双精度浮点数（double）列表！
开发者：马上搞定！
```cpp
class DoubleVector {
    // 用于存储
    // 双精度浮点数列表的代码...
};
```

程序员：那你能再给我做一个存储字符串（string）的列表吗……
开发者：🤯😠😠，你有完没完！

## 要是能保留逻辑不变，只改变数据类型就好了？
不使用模板时，需为每种数据类型单独定义类：
```cpp
class IntVector {
    // 用于存储
    // 整数列表的代码...
};

class DoubleVector {
    // 用于存储
    // 双精度浮点数列表的代码...
};

class StringVector {
    // 用于存储
    // 字符串列表的代码...
};
```

使用模板后，只需定义一次通用类：(这个就是模板类，后面我们会单独有一节说到他！)
```cpp
template <typename T>
class vector {
    // 这样太简洁高效了！
};

// 使用时指定数据类型即可
vector<int> v1;
vector<double> v2;
vector<string> v3;
```

所以：
## 所有 STL 容器都是模板！
准确来说，正是因为这些容器做成模板后，总结到一起，形成了STL！

### 标准模板库（STL）相关背景
1. 由亚历山大・斯特潘诺夫（Alexander Stepanov）创建
2. 他将模板引入 C++，并构建了这个知名的库
3. 该库如今被广泛称为 STL！

STL与std的关系如下图：
![[Pasted image 20251020210842.png]]
不过注意，std是整个c++的标准库的命名空间，而stl中所有容器的命名空间都包含在里面！但是不是所有标准库内容都在stl中，比如cout与cin！所以一个叫做标准库，一个叫做标准模板库！不过stl可不是命名空间，仅仅是一个术语，俗称罢了！
一般的有许多类型的都在stl中，比如vector，有int型，string型等等！但是像cout只有这一种类型的就不会是模板库里面的了！
### 标准模板库（STL）的四大核心组件

1. 容器（Containers）
    
    用于存储多个数据的结构，如向量、映射等。
2. 迭代器（Iterators）
    
    用于遍历容器中元素的工具，类似指针。
3. 算法（Algorithms）
    
    用于对容器中的元素进行通用操作的函数，如排序、查找等。
4. 函数对象（Functors）
    
    可像函数一样被调用的对象，用于自定义算法的行为。

下面我们讲第一大类：
## 序列容器

序列容器用于存储**呈线性排列的元素**

### `std::vector`（标准向量容器）
使用时需包含头文件：`#include <vector>`

`std::vector` 用于存储元素列表，示例代码如下：
```cpp
std::vector<int> vec { 1, 2, 3, 4 };
vec.push_back(5);  // 向向量末尾添加元素5
vec.push_back(6);  // 向向量末尾添加元素6
vec[1] = 20;       // 将索引1处的元素修改为20

// 遍历向量并输出元素
for (size_t i = 0; i < vec.size(); i++) {
    std::cout << vec[i] << " ";
}
```
内部像这样：
![[Pasted image 20251020211310.png]]

### 斯坦福库的向量（Stanford Vector）与标准模板库向量（`std::vector`）对比

|需求|斯坦福 Vector<int>|标准 std::vector<int>|
|---|---|---|
|创建空向量|`Vector<int> v;`|`std::vector<int> v;`|
|创建包含 n 个 0 的向量|`Vector<int> v(n);`|`std::vector<int> v(n);`|
|创建包含 n 个值为 k 的向量|`Vector<int> v(n, k);`|`std::vector<int> v(n, k);`|
|向向量末尾添加 k|`v.add(k);`|`v.push_back(k);`|
|清空向量|`v.clear();`|`v.clear();`|
|判断向量是否为空|`if (v.isEmpty())`|`if (v.empty())`|
|获取索引 i 处的元素|`int val = v.get(i);` 或 `int val = v[i];`|`int val = v.at(i);` 或 `int val = v[i];`|
|修改索引 i 处的元素|`v.get(i) = k;` 或 `v[i] = k;`|`v.at(i) = k;` 或 `v[i] = k;`|
### `std::vector` 的实现原理
1. 初始状态：大小（size）=2，容量（capacity）=4，存储元素 1、2
2. 添加元素 3 后：大小 = 3，容量 = 4
3. 添加元素 4 后：大小 = 4，容量 = 4
4. 添加元素 5 后：大小 = 5，容量自动扩容为 8
![[Pasted image 20251020211758.png]]

### 小贴士：尽可能使用范围 for 循环
传统 for 循环（通过索引遍历）：
```cpp
for (size_t i = 0; i < vec.size(); i++) {
    std::cout << vec[i] << " ";
}
```

范围 for 循环（更简洁，无需关注索引）：
```cpp
for (auto elem : vec) {
    std::cout << elem << " ";
}
```
范围 for 循环适用于所有可迭代容器，并非仅`std::vector`可用。

### 小贴士：尽可能使用`const auto&`
当容器存储的元素类型较大（如自定义的大型类）时：
```cpp
std::vector<MassiveType> vec { ... };
for (auto elem : vec) ...  // 每次循环都会拷贝元素，可能耗时
```

使用`const auto&`可避免拷贝，提高效率：
```cpp
for (const auto& elem : v)  // 仅引用元素，不拷贝
```
这个我们之前好像说过！

### 重要特性：`operator[]` 不进行边界检查
`operator[]` 是**下标运算符**，如`v[1]`！
```cpp
std::vector<int> vec{5, 6};  // 向量内容：{5, 6}
vec[1] = 3;                  // 合法操作，向量内容变为{5, 3}
vec[2] = 4;                  // 非法操作，行为未定义（可能导致程序崩溃）
vec.at(2) = 4;               // 合法操作，但会抛出运行时错误（越界）
```
所以像vec.at(2) = 4;  编译器还会报错。但是`vec[2] = 4;`就不会报错了，他会读取内存中的下一个地址块，出来的会是随机值，这很危险！

零开销原则是 C++ 的设计原则，具体包含两点：

1. 不使用的功能，不会产生额外开销。
2. 所使用的功能，其效率与手动编写的合理代码效率相当。
所以才会有如此设计！

### `std::vector` 并非适用于所有场景……
假设我们需要记录某只股票最近 10000 个价格，以下代码存在什么问题？
```cpp
void receivePrice(vector<double>& prices, double price) 
{
    prices.push_front(price);  // 向向量开头添加价格
    if (prices.size() > 10000)
        prices.pop_back();     // 移除最后一个价格，确保总数不超过10000
}
```
这是一个陷阱题！

`std::vector` 根本没有 `push_front` 成员函数！当然他可以insert，在上面的表格中你会注意到！但是他的时间复杂度就不是O(1)了！

### 假设`std::vector`有`push_front`函数……（就像insert函数）
![[Pasted image 20251020213029.png]]
（插入过程中所有元素需向后移动，效率极低）


### `std::deque`（标准双端队列容器）

使用时需包含头文件：`#include <deque>`
#### `std::deque` 的特性

`deque` 是 “double-ended queue” 的缩写，即双端队列。它支持在两端高效地插入和删除元素。

#### 改进后的股票价格记录代码
```cpp
void receivePrice(deque<double>& prices, double price) 
{
    prices.push_front(price);  // 速度极快，直接在头部插入
    if (prices.size() > 10000)
        prices.pop_back();     // 移除最后一个价格，确保总数不超过10000
}
```

#### 接口特点

`deque` 的接口与 `vector` 基本一致，唯一区别是 `deque` 支持 `push_front`（头部插入）和 `pop_front`（头部删除）操作。

### `std::vector` 的问题根源

`std::vector` 采用**连续的单块内存**存储元素，导致头部插入 / 删除元素时需移动大量数据。
那么vector他只认首个内存块的地址，所以导致如此麻烦！

### `std::deque` 的实现原理

那我们就把内存**分割成多个独立的小块**！
![[Pasted image 20251020213419.png]]

结论：`deque` 通过 “数组的数组”（Array of arrays）方式实现，每个子数组独立分配内存，避免了连续内存的缺陷。


下面是第二大类：
## 关联容器
关联容器通过**唯一键**来组织元素

### `std::map`（标准映射容器）
使用时需包含头文件：`#include <map>`
#### `std::map` 的功能
`std::map` 用于将键（key）映射到值（value），示例如下：
```cpp
std::map<std::string, int>  // 键类型为string，值类型为int
```
![[Pasted image 20251020213717.png]]
`std::map` 相当于 Python 中的字典（dictionary），有时也被称为关联数组（associative array）。

#### `std::map` 使用示例
```cpp
// 创建映射并初始化键值对
std::map<std::string, int> map {
    { "Chris", 2 },
    { "CS106L", 42 },
    { "Keith", 14 },
    { "Nick", 51 },
    { "Sean", 35 },
};

// 获取键"Sean"对应的值
int sean = map["Sean"];  // sean的值为35
// 修改键"Chris"对应的值
map["Chris"] = 31;
```
![[Pasted image 20251020213820.png]]

### 斯坦福映射（Stanford Map）与标准映射（`std::map`）对比

|需求|斯坦福 Map<char, int>|标准 std::map<char, int>|
|---|---|---|
|创建空映射|`Map<char, int> m;`|`std::map<char, int> m;`|
|向映射中添加键 k 和值 v|`m.put(k, v);` 或 `m[k] = v;`|`m.insert({k, v});` 或 `m[k] = v;`|
|从映射中删除键 k|`m.remove(k);`|`m.erase(k);`|
|判断键 k 是否在映射中（* C++20 标准支持）|`if (m.containsKey(k))`|`if (m.count(k))` 或 `if (m.contains(k))`（*）|
|判断映射是否为空|`if (m.isEmpty())`|`if (m.empty())`|
|获取或修改键 k 对应的值（若键不存在则自动插入默认值）|`int i = m[k];` 或 `m[k] = i;`|`int i = m[k];` 或 `m[k] = i;`|
### `std::map<K, V>` 的存储本质

`std::map<K, V>` 存储的是一系列 `std::pair<const K, V>`（键值对）。

#### 遍历映射的键值对

可使用范围 for 循环遍历映射中的所有键值对：
```cpp
std::map<std::string, int> map;  // 假设已初始化

for (auto kv : map) {
    // kv是std::pair<const std::string, int>类型
    std::string key = kv.first;  // 获取键
    int value = kv.second;       // 获取值
}
```
#### 结合结构化绑定遍历映射

结构化绑定可简化映射的遍历代码：
```cpp
std::map<std::string, int> map;  // 假设已初始化

for (const auto& [key, value] : map) {
    // key的类型是const std::string&（键的引用）
    // value的类型是const int&（值的引用）
}
```

### `std::map` 的实现原理
![[Pasted image 20251020214306.png]]`std::map` 底层通过**二叉搜索树**（具体为红黑树，一种自平衡二叉搜索树）实现，确保键值对按键的顺序存储，且插入、删除、查找操作的时间复杂度均为 O (log n)。

#### 查找示例：`map["Keith"]` 如何工作？
1. 判断 “Keith” 是否小于根节点 “CS106L”？是，向左子树查找。
2. 判断 “Keith” 是否小于左子树节点 “Chris”？否，向右子树查找。
3. 判断 “Keith” 是否小于右子树节点 “Nick”？是，向左子树查找。
4. 找到键 “Keith”，返回对应的值 14。

最终结果：`map["Keith"] = 14`
![[Pasted image 20251020214410.png]]

#### 插入示例：`map["Alex"]` 如何工作？
1. 判断 “Alex” 是否小于根节点 “CS106L”？是，向左子树查找。
2. 判断 “Alex” 是否小于左子树节点 “Chris”？是，向左子树查找，但左子树为空。
3. 在该位置插入键 “Alex”，由于未指定值，自动插入 int 类型的默认值 0。

最终结果：`map["Alex"] = 0`（注意：“Alex” 是被自动插入到映射中的）
![[Pasted image 20251020214503.png]]

### `std::map<K, V>` 的关键要求

`std::map<K, V>` 要求键类型 K 必须支持 `<` 运算符（即具有全序关系）。原因就是为了满足上面的工作机制！
```cpp
// 合法：int类型支持<运算符
std::map<int, int> map1; 

// 非法：std::ifstream类型不支持<运算符
std::map<std::ifstream, int> map2; 
```

### `std::set`（标准集合容器）
使用时需包含头文件：`#include <set>`

#### `std::set` 的功能

`std::set` 用于存储**唯一的元素**（无重复），示例如下：
```cpp
std::set<std::string> set { 
    "CS106L!", 
    "Keith", 
    "Sean", 
    "Nick", 
    "Chris" 
};
```
![[Pasted image 20251020214706.png]]

### 斯坦福集合（Stanford Set）与标准集合（`std::set`）对比

| 需求                          | 斯坦福 Set<char>        | 标准 std::set<char>                           |
| --------------------------- | -------------------- | ------------------------------------------- |
| 创建空集合                       | `Set<char> s;`       | `std::set<char> s;`                         |
| 向集合中添加元素 k                  | `s.add(k);`          | `s.insert(k);`                              |
| 从集合中删除元素 k                  | `s.remove(k);`       | `s.erase(k);`                               |
| 判断元素 k 是否在集合中（* C++20 标准支持） | `if (s.contains(k))` | `if (s.count(k))` 或 `if (s.contains(k))`（*） |
| 判断集合是否为空                    | `if (s.isEmpty())`   | `if (s.empty())`                            |
#### `std::set` 与 `std::map` 的关系

可以将 `std::set` 理解为 “没有值的 `std::map`”，它仅存储键（即元素本身），且确保元素唯一。

### `std::set` 的实现原理

![[Pasted image 20251020214828.png]]

`std::set` 底层同样通过**二叉搜索树**（红黑树）实现，确保元素唯一且有序，插入、删除、查找操作的时间复杂度均为 O (log n)。

### 映射和集合的 “另一面”

不过，`map` 和 `set` 还有一个 “分身”——`unordered_map` 和 `unordered_set`！
### `std::unordered_map` 与 `std::unordered_set`

使用时需包含对应的头文件：

- `#include <unordered_map>`（无序映射）
- `#include <unordered_set>`（无序集合）

#### `std::unordered_map` 的特性

可将 `unordered_map` 视为 `map` 的优化版本，两者接口完全相同，但底层实现不同。
```cpp
// unordered_map 使用示例
std::unordered_map<std::string, int> map {
    { "Chris", 2 },    
    { "Nick", 51 },
    { "Sean", 35 },
};

int sean = map["Sean"];  // 获取值35
map["Chris"] = 31;       // 修改值为31
```

### `std::unordered_map` 的实现原理

`std::unordered_map` 底层通过**哈希表**（Hash Table）实现，核心是 “桶数组 + 链表” 的结构。
![[Pasted image 20251020215032.png]]
展示 “Chris”“Nick”“Sean” 分别存储在桶 0、桶 1、桶 2 中

#### 哈希表的存储逻辑

1. 添加键值对时，先将键传入哈希函数（Hash Function）。
2. 哈希函数计算出一个哈希值（size_t 类型），再对桶的数量取模，得到该键值对对应的桶编号。
3. 将键值对存储到对应编号的桶中。

#### 哈希表查找示例

假设要查找 `map["CS106L"]`：

1. 计算 “CS106L” 的哈希值，假设为 80489869。
2. 对桶数量（5）取模：80489869 % 5 = 4，得到桶编号 4。
3. 在桶 4 中查找键 “CS106L”，由于之前未存储，自动插入默认值 0。
4. 最终结果：`int x = map["CS106L"];`（x 的值为 0）

### 什么是哈希函数？

1. 哈希函数能将键 “打乱” 并转换为一个 size_t 类型的值（64 位整数）。
2. 键的微小变化应导致哈希值的巨大变化，以减少哈希冲突。

#### 哈希冲突及解决方式

1. 哈希冲突：两个不同的键经过哈希函数计算后，得到相同的桶编号。
2. 查找时，需遍历对应桶中的所有键值对，通过键的相等性（ == ）判断是否为目标键。
    
    注意：哈希值相同的键，不一定是相等的键！

### `std::unordered_map<K, V>` 的关键要求

`std::unordered_map<K, V>` 要求键类型 K 必须具备：

1. 对应的哈希函数（能计算键的哈希值）
2. 相等性判断（== 运算符，用于解决哈希冲突）

```cpp
// 定义于头文件 <unordered_map>
template<
    class Key,                // 键类型
    class T,                  // 值类型
    class Hash = std::hash<Key>,  // 哈希函数类型，默认使用std::hash<Key>
    class KeyEqual = std::equal_to<Key>,  // 相等性判断类型，默认使用std::equal_to<Key>
    class Allocator = std::allocator<std::pair<const Key, T>>  // 分配器类型
> class unordered_map;
```

```cpp
//  合法：int类型默认支持哈希
std::unordered_map<int, int> map1; 

//  非法：std::ifstream类型默认不支持哈希
std::unordered_map<std::ifstream, int> map2; 
```
大多数基础类型（如 int、double、string）默认都支持哈希。

#### 哈希表的负载因子（Load Factor）

1. 负载因子：哈希表中平均每个桶存储的元素数量（总元素数 / 桶数量）。
2. `unordered_map` 通过维持较低的负载因子来保证快速查找，默认负载因子阈值为 1.0。
3. 当负载因子超过阈值时，哈希表会自动进行 “重哈希”（rehash）—— 增加桶的数量，并重新分配所有元素到新桶中。
### 为什么使用 `std::unordered_map`？

`std::unordered_map` 的优势在于**查找、插入、删除操作的平均时间复杂度为 O (1)**（理想情况下无哈希冲突），远快于 `std::map` 的 O (log n)。

#### C++ 小知识：`max_load_factor`

可以手动控制 `unordered_map` 触发重哈希的最大负载因子：
```cpp
std::unordered_map<std::string, int> map;

// 获取当前负载因子
double lf = map.load_factor(); 
// 设置最大负载因子为2.0
map.max_load_factor(2.0); 

// 现在，只有当负载因子超过2.0时，哈希表才会重哈希
// 通常无需手动修改此值，但了解它是个有趣的知识点
```

#### `std::unordered_set` 与 `std::unordered_map` 的关系

`std::unordered_set` 可理解为 “没有值的 `std::unordered_map`”，它仅存储唯一的元素，底层通过哈希表实现。
```cpp
// unordered_set 使用示例
std::unordered_set<std::string> set {
    "Chris",    
    "Nick",
    "Sean",
    "CS106L"
};
```
![[Pasted image 20251020215807.png]]
### 何时选择 `unordered_map` 与 `map`？

1. 性能：`unordered_map` 通常比 `map` 更快（平均 O (1) vs O (log n)）。
2. 内存：`unordered_map` 占用更多内存（类似 “整洁车库” 与 “杂乱车库” 的权衡，需额外存储哈希表结构）。
3. 键的特性：若键类型不支持 `<` 运算符（无全序关系），则只能选择 `unordered_map`。
4. 通用建议：若无特殊需求，选择 `unordered_map` 是更安全的选择（性能更优）。

## 总结

### 各容器操作效率对比表

|容器|访问第 i 个元素|查找元素|插入元素|删除元素|
|---|---|---|---|---|
|`std::vector`|极快（O (1)）|慢（O (n)）|慢（O (n)，尾部插入除外）|慢（O (n)）|
|`std::deque`|快（O (1)）|慢（O (n)）|快（头部 / 尾部 O (1)，其他位置 O (n)）|快（头部 / 尾部 O (1)，其他位置 O (n)）|
|`std::set`|慢（无直接访问，需遍历 O (n)）|快（O (log n)）|快（O (log n)）|快（O (log n)）|
|`std::map`|慢（无直接访问，需遍历 O (n)）|快（O (log n)）|快（O (log n)）|快（O (log n)）|
|`std::unordered_set`|无此操作（N/A）|极快（平均 O (1)）|极快（平均 O (1)）|极快（平均 O (1)）|
|`std::unordered_map`|无此操作（N/A）|极快（平均 O (1)）|极快（平均 O (1)）|极快（平均 O (1)）|
### 其他值得了解的容器

1. `std::array`（数组容器）
    
    固定大小的数组，比普通数组更安全（支持边界检查等）。
2. `std::list`（链表容器）
    
    双向链表，支持任意位置高效插入 / 删除，但不支持随机访问。
3. `std::multiset`（多重集合）及 `std::unordered_multiset`（无序多重集合）
    
    允许存储重复元素的集合。
4. `std::multimap`（多重映射）及 `std::unordered_multimap`（无序多重映射）
    
    允许一个键对应多个值的映射。
这就是容器！

