## 你可能还记得

类包含以下组成部分：

1. 构造函数
2. 成员变量（小惊喜：这些都属于 “特殊成员函数”）
3. （其他成员）
4. （其他成员）

（特殊成员函数，简称 SMFs）

每当创建一个类的新实例时，构造函数都会被调用；而当对象超出作用域时，析构函数会被调用。

### 6 个特殊成员函数

这些函数仅在被调用时（且在用户显式定义之前）才会由编译器自动生成（就是用到这些函数，但你没有自己定义，编译器会自动生成）：

- 默认构造函数：`T()`
- 析构函数：`~T()`
- 拷贝构造函数：`T(const T&)`
- 拷贝赋值运算符：`T& operator=(const T&)`
- 移动构造函数：`T(T&&)`
- 移动赋值运算符：`T& operator=(T&&)`
### 以 Widget 类为例
```cpp
class Widget { 
public: 
    Widget(); // 默认构造函数
    Widget(const Widget& w); // 拷贝构造函数
    Widget& operator=(const Widget& w); // 拷贝赋值运算符
    ~Widget(); // 析构函数
    Widget(Widget&& rhs); // 移动构造函数
    Widget& operator=(Widget&& rhs); // 移动赋值运算符
};
```
### 确实有 6 个特殊成员函数！
```cpp
Widget(); // 默认构造函数
```
（默认构造函数）无需参数，用于创建一个新对象。

```cpp
Widget(const Widget& w); // 拷贝构造函数
```
（拷贝构造函数）创建一个新对象，其成员变量与另一个对象逐成员拷贝。把源对象（比如 `w1`）的**每一个成员变量**，**直接复制**到新对象（比如 `w2`）的对应成员变量中。**只有成员变量（数据）会被复制，成员函数（行为）不会被复制，也不会重新生成。**

#### 何时会调用拷贝构造函数？
```cpp
Widget widgetOne;
Widget widgetTwo = widgetOne; // 调用拷贝构造函数
```

```cpp
 Widget& operator=(const Widget& w); // 拷贝赋值运算符
```
（拷贝赋值运算符）将一个已存在的对象赋值给另一个已存在的对象。

#### 何时会调用拷贝赋值运算符？
```cpp
Widget widgetOne;
Widget widgetTwo;
widgetOne = widgetTwo; // 调用拷贝赋值运算符
```

所以记住他们两个的区别：

|操作|何时调用|对象状态|
|---|---|---|
|**拷贝构造函数**|创建新对象时|一边是**新对象**，一边是已有对象|
|**拷贝赋值运算符**|已有对象被赋值时|**两个都是已存在的对象**|

```cpp
~Widget(); // 析构函数
```
（析构函数）当对象超出作用域时被调用。

```cpp
Widget(Widget&& rhs); // 移动构造函数
Widget& operator=(Widget&& rhs); // 移动赋值运算符
```
（关于移动构造和移动赋值）我们有一整节课专门讲解这部分内容，今天暂不重点讨论。

我们无需手动编写所有这些函数！它们都有默认版本，会由编译器自动生成。

首先我们来讲讲拷贝构造与拷贝赋值：
先复习一下初始化：
## 初始化
还记得第 8 讲中我们学习的 Vector 类吗？
```cpp
template <typename T>
Vector<T>::Vector() {
    _size = 0;
    _capacity = 4;
    _data = new T[_capacity];
}
```
当我们创建构造函数时，需要对所有成员变量进行初始化。
然而，先将成员变量初始化为默认值，之后再重新赋值的方式效率很低！

上面的代码中实际发生了两个步骤：
在被调用构造函数之前：
#### 步骤 1
所有成员变量会被默认赋值，一般的，内置类型会被赋值为0（比如int，double等），类类型则会被调用他这个类的构造函数进行默认赋值（比如std::string，他会调用string类的构造函数进行初始赋值），还有一些其他的比如指针类型的会被赋值为垃圾值！

#### 步骤 2
把`_size=0`赋值为4，下面的操作一样！
这实际上造成了双倍的工作量

所以为了优化性能：
### 成员初始化列表
```cpp
template <typename T>
Vector<T>::Vector() : _size(0), _capacity(4), _data(new T[_capacity]) { 
    // 构造函数体（可为空）
}
```
我们可以使用初始化列表，一次性声明并初始化成员变量为期望的值！这个就省去了步骤一！
为了防止窄化，可以写成：
```cpp
template <typename T>
Vector<T>::Vector() : _size{0}, _capacity{4}, _data{new T[_capacity]} { 
    // 构造函数体（可为空）
}
```
### 成员初始化列表的优势

- 直接用目标值构造成员变量，速度更快、效率更高；
- 若成员变量是不可赋值类型（如 const 变量、引用变量），只能通过初始化列表初始化；比如：
```cpp
template <typename T>
class MyClass { 
    const int _constant; // const成员变量（不可赋值）
    int& _reference; // 引用成员变量（不可赋值）
public: 
    // 仅能通过初始化列表初始化const和引用成员变量
    MyClass(int value, int& ref) : _constant(value), _reference(ref) { 
        // 构造函数体
    }
};
```
- 任何构造函数（即使是带参数的非默认构造函数）都可以使用成员初始化列表！
而我们的拷贝构造函数就运用到了成员初始化列表！

成员初始化列表是类或结构体构造函数中用于初始化成员变量的特定代码区域（位于构造函数参数列表后、函数体前，以冒号开头），而列表初始化是一种使用大括号`{}`的初始化语法，成员初始化列表可以采用这种语法来完成成员变量的初始化，例如在`struct Person { string name; int age; Person(string n, int a) : name{n}, age{a} {} };`中，`name{n}, age{a}`整体是成员初始化列表，其中的`{}`就是列表初始化语法，可见成员初始化列表是应用场景，列表初始化是该场景中可选用的语法手段。

回到正题，拷贝构造与拷贝赋值！
首先思考一个问题
## 为什么需要重写特殊成员函数？
编译器不是会自动为我们生成这些函数吗？

a. 默认情况下，拷贝构造函数会对每个成员变量进行拷贝（即 “逐成员拷贝”）。

这种 “逐成员拷贝” 是否在所有情况下都足够用？
首先：
### 考虑指针成员变量的情况
如果类中的成员变量是指针，那么逐成员拷贝只会让新指针指向与原指针相同的已分配内存，而不会创建新的内存副本！
```cpp
template <typename T>
Vector<T>::Vector(const Vector<T>& other) :
    _size(other._size), 
    _capacity(other._capacity), 
    _data(other._data) { // 仅拷贝指针地址，未创建新内存
}
```
这些指针会指向同一个底层数组！
![[Pasted image 20251031005801.png]]

这会导致一个问题：对其中一个指针所指向内存的操作，会影响到另一个指针。比如我们想改变other的指针成员变量指向的列表，但是不想改变拷贝的对象的列表，如果这样写，显然这个想法是无法实现的！
所以：
### 拷贝并非总是简单的操作！

很多时候，我们需要创建的 “拷贝” 不仅仅是对成员变量的简单复制。

**深拷贝（Deep Copy）**：创建一个与原对象完全独立的副本，包括原对象中指针所指向的底层数据也会被复制。

在这种情况下，我们需要重写编译器默认生成的特殊成员函数，自行实现深拷贝逻辑！

（实现方式：在头文件中声明这些函数，在.cpp 文件中编写具体实现，与其他函数的实现方式一致。）
### 解决指针成员变量的问题（实现深拷贝）
```cpp
template <typename T>
Vector<T>::Vector(const Vector<T>& other) :
    _size(other._size), 
    _capacity(other._capacity), 
    _data(new T[other._capacity]) { // 为新对象分配独立内存
    // 逐元素复制原数组中的数据到新内存
    for (size_t i = 0; i < _size; ++i) { 
        _data[i] = other._data[i];
    }
}
```
![[Pasted image 20251031010139.png]]

现在，我们的 Vector 类实现了数据的 “深拷贝”，两个对象的内存完全独立。
然后值得一提的是，拷贝函数是可以访问另外一个类的私有变量的，这是因为c++的访问控制是根据类区分而不是对象区分，只要是一个类的对象都可以自由访问私有变量，因为他们的成员函数一样！

那么：
## 如何禁止拷贝操作？

假设我们有一个用于管理所有密码的类：
```cpp
class PasswordManager { 
public: 
    PasswordManager(); // 默认构造函数
    ~PasswordManager(); // 析构函数
    // 其他成员方法...
    PasswordManager(const PasswordManager& rhs); // 拷贝构造函数（声明）
    PasswordManager& operator=(const PasswordManager& rhs); // 拷贝赋值运算符（声明）
private: 
    // 其他重要成员变量...
};
```
### 可以使用 delete 禁用特殊成员函数

将特殊成员函数声明为`delete`，可以移除该函数的功能（即禁止调用）！
```cpp
class PasswordManager { 
public: 
    PasswordManager(); // 默认构造函数
    ~PasswordManager(); // 析构函数
    // 其他成员方法...
    // 禁用拷贝构造函数
    PasswordManager(const PasswordManager& rhs) = delete;
    // 禁用拷贝赋值运算符
    PasswordManager& operator=(const PasswordManager& rhs) = delete;
private: 
    // 其他重要成员变量...
};
```
此时，拷贝操作（拷贝构造和拷贝赋值）将不再是允许的操作！

### 为什么要禁用拷贝操作？
我们可以有选择地允许或禁止特殊成员函数的功能！

- 这种机制有很多用途，例如：若希望某个类的实例只能有一个（即单例模式的一种实现方式），就可以禁用拷贝操作；
- C++ 标准库中的`std::unique_ptr`就是通过这种方式实现的（禁止拷贝，允许移动）！

你可以在 cppreference（C++ 参考文档）中看到相关说明：“`std::unique_ptr`类满足可移动构造（MoveConstructible）和可移动赋值（MoveAssignable）的要求，但不满足可拷贝构造（CopyConstructible）和可拷贝赋值（CopyAssignable）的要求。”

### 可以使用 default 保留默认特殊成员函数

如果我们定义了其他构造函数，仍希望保留编译器默认生成的拷贝构造函数，可以使用`default`声明：
```cpp
class PasswordManager { 
public: 
    PasswordManager(); // 用户定义的默认构造函数
    // 保留编译器默认生成的拷贝构造函数
    PasswordManager(const PasswordManager& pm) = default;
    ~PasswordManager(); // 析构函数
    // 其他成员方法...
    // （示例：此处同时禁用了另一个拷贝构造函数和拷贝赋值运算符，仅作演示）
    PasswordManager(const PasswordManager& rhs) = delete;
    PasswordManager& operator=(const PasswordManager& rhs) = delete;
private: 
    // 其他重要成员变量...
};
```
**注意**：如果声明了任何用户自定义的构造函数，编译器将不再自动生成默认构造函数，除非显式使用`= default`声明。

## 理念探讨

### 零规则（Rule of Zero）

如果编译器默认生成的特殊成员函数能够满足需求，就不要手动定义它们！
只有当编译器默认生成的特殊成员函数无法满足需求时，才需要手动定义新的实现。

- 这种情况通常发生在类中使用动态分配内存时（例如，包含指向堆内存的指针成员变量）。


如果不需要自定义构造函数、析构函数或拷贝赋值运算符等，就不要去定义它们！

如果类依赖的对象 / 类已经实现了这些特殊成员函数，那么就无需重新实现相同的逻辑！

```cpp
class a_string_with_an_id { 
public: 
    //  getter和setter方法（用于访问私有成员变量）
private: 
    int id; // 基本类型成员变量
    std::string str; // 标准库string类型成员变量
};

// 使用示例
a_string_with_an_id object;
```
我们的`a_string_with_an_id`类包含 “自管理型” 成员变量（无需手动管理内存）。
`std::string`类已经实现了拷贝构造函数、拷贝赋值运算符、移动构造函数和移动赋值运算符！

### 三规则（Rule of Three）

如果需要自定义析构函数，那么很可能也需要自定义拷贝构造函数和拷贝赋值运算符。

为什么会这样？

- 如果需要自定义析构函数，通常意味着类中存在手动管理的动态内存（或其他需要手动释放的资源）；
- 在这种情况下，编译器自动生成的拷贝构造函数和拷贝赋值运算符无法正确处理动态内存（只会进行浅拷贝），因此需要手动实现深拷贝逻辑。

到目前为止，我们讨论的 4 个特殊成员函数：

- **默认构造函数**：无参数，创建对象时未初始化成员变量（使用默认值）；
- **拷贝构造函数**：创建一个新对象，其成员变量与已有对象逐成员拷贝；
- **拷贝赋值运算符**：用一个已有对象的内容替换另一个已有对象的内容；
- **析构函数**：当对象超出作用域时被调用，用于释放资源。

## 小测验
```cpp
vector<int> func(vector<int> vec0) { 
    vector<int> vec1; 
    vector<int> vec2(3); 
    vector<int> vec3{3}; 
    vector<int> vec4(); 
    vector<int> vec5(vec2); 
    vector<int> vec6{}; 
    vector<int> vec7{static_cast<int>(vec2.size() + vec6.size())}; 
    vector<int> vec8 = vec2; 
    vec8 = vec2; 
    return vec8;
}
```
上述代码中，每一行分别对应哪种操作或函数调用？

答案：
```cpp
vector<int> func(vector<int> vec0) { 
    vector<int> vec1; // 默认构造函数
    vector<int> vec2(3); // 自定义构造函数（非特殊成员函数）
    vector<int> vec3{3}; // 统一初始化（非特殊成员函数）
    vector<int> vec4(); // 函数声明
    vector<int> vec5(vec2); // 拷贝构造函数
    vector<int> vec6{}; // 列表初始化（空vector）
    vector<int> vec7{static_cast<int>(vec2.size() + vec6.size())}; // 统一初始化（非特殊成员函数）
    vector<int> vec8 = vec2; // 拷贝构造函数
    vec8 = vec2; // 拷贝赋值运算符（Copy Assignment Operator）
    return vec8; // tricky：返回值时调用拷贝构造函数（Copy Constructor）
}
```

## 仅靠拷贝操作足够吗？

我们已经学习了默认构造函数、析构函数、拷贝构造函数和拷贝赋值运算符：

- 我们可以创建对象、销毁对象，以及将一个对象的内容拷贝到另一个对象；
- 但仅靠这些操作，是否在所有场景下都足够？

### 拷贝操作可能存在效率浪费

（回顾：特殊成员函数仅在被调用时由编译器自动生成）
```cpp
class Widget { 
public: 
    Widget(); // 默认构造函数
    Widget(const Widget& w); // 拷贝构造函数
    Widget& operator=(const Widget& w); // 拷贝赋值运算符
    ~Widget(); // 析构函数
    Widget(Widget&& rhs); // 移动构造函数（待讲解）
    Widget& operator=(Widget&& rhs); // 移动赋值运算符（待讲解）
};
```
让我们来理解 “移动语义” 的设计动机。
假设我们需要将当前的`StringTable`对象拷贝到另一个对象中（该对象的引用已给出），且之后不再需要原`StringTable`对象：
```cpp
class StringTable { 
public: 
    // 包含查找（lookup）等方法，但无移动语义和自定义析构函数
private: 
    std::map<int, std::string> values; // 成员变量（map容器）
};
```
此时，拷贝构造函数会逐个拷贝`values`映射中的所有键值对 —— 这个过程会非常慢！

### 理解移动语义的一个好方法

移动语义：“移动” 而非 “复制”

|拷贝（COPY）|移动（MOVE）|
|---|---|
|为新对象创建所有数据的副本（新内存 + 数据复制）|直接 “窃取” 原对象的数据（无需新内存，仅转移所有权）|
|原对象和新对象各自拥有独立的数据|原对象不再拥有数据（通常会变为 “空” 状态）|
然而具体的介绍看下一节！
