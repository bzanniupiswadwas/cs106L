# å›é¡¾
ä¸Šä¸€è®²çŸ¥è¯†ç‚¹å¤šï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å…±åŒæ¥å›å¿†ï¼
### é¦–å…ˆæ˜¯è¦ç¼–å†™ä¸€ä¸ªminå‡½æ•°ï¼š
```cpp
int min(int a, int b){
	return a < b ? a : b;
}

double min(double a, double b){
	return a < b ? a : b;
}

std::string min(std::string a, std::string b){
	return a < b ? a : b;
}
```
### ç¼–å†™æ¨¡æ¿åŒ–çš„ min å‡½æ•°
```cpp
template <typename T>
T min(T a, T b) {
    return a < b ? a : b;
}
```
è¿™å°±æ˜¯ä¸€ä¸ªæ¨¡æ¿ï¼Œ`T`ä¼šè¢«æ›¿æ¢ä¸ºå…·ä½“çš„ç±»å‹ã€‚

### æ˜¾å¼å®ä¾‹åŒ–
æ¨¡æ¿å‡½æ•°ä¼šè®©ç¼–è¯‘å™¨ä¸ºæˆ‘ä»¬ç”Ÿæˆä»£ç 
```cpp
int min(int a, int b) {                  // ç¼–è¯‘å™¨ç”Ÿæˆ
    return a < b ? a : b;                // ç¼–è¯‘å™¨ç”Ÿæˆ
}                                         // ç¼–è¯‘å™¨ç”Ÿæˆ

double min(double a, double b) {         // ç¼–è¯‘å™¨ç”Ÿæˆ
    return a < b ? a : b;                // ç¼–è¯‘å™¨ç”Ÿæˆ
}                                         // ç¼–è¯‘å™¨ç”Ÿæˆ

min<int>(106, 107);          // è¿”å›106
min<double>(1.2, 3.4);       // è¿”å›1.2
```

### éšå¼å®ä¾‹åŒ–ç±»ä¼¼ auto
```cpp
int m = min(106, 107);
```
è¿™å®Œå…¨ç­‰åŒäºæˆ‘ä»¬ç¼–å†™äº†`min<int>(106, 107)`

### ç¼–å†™æ¨¡æ¿åŒ–çš„ find å‡½æ•°
è¿™ä¸ª find å‡½æ•°å¯é€‚ç”¨äºæ‰€æœ‰è¿­ä»£å™¨ç±»å‹ï¼
```cpp
template <typename It, typename T>
It find(It begin, It end, const T& value) {
    for (auto it = begin; it != end; ++it) {
        if (*it == value) return it;
    }
    return end;
}
```
æˆ‘ä»¬çš„ find å‡½æ•°å¯ç”¨äºå…¶ä»–å‘é‡ï¼Œç”šè‡³å…¶ä»–å®¹å™¨
```cpp
std::vector<std::string> v { "seven", "kingdoms" };
auto it = find(v.begin(), v.end(), "kingdoms"); 
// It = vector<std::string>::iteratorï¼ˆå‘é‡<string>ç±»å‹çš„è¿­ä»£å™¨ï¼‰
// T = std::stringï¼ˆå­—ç¬¦ä¸²ç±»å‹ï¼‰

std::set<std::string> s { "house", "targaryen" };
auto it = find(s.begin(), s.end(), "targaryen"); 
// It = std::set<std::string>::iteratorï¼ˆé›†åˆ<string>ç±»å‹çš„è¿­ä»£å™¨ï¼‰
// T = std::stringï¼ˆå­—ç¬¦ä¸²ç±»å‹ï¼‰
```
è¿™äº›éƒ½æ˜¯ç¼–è¯‘å™¨é€šè¿‡åˆ†æå‚æ•°æ¨å¯¼å‡ºæ¨¡æ¿ç±»å‹ï¼Œä¹Ÿå°±æ˜¯éšå¼å®ä¾‹åŒ–ï¼

ä½†æ˜¯å¤§å®¶æœ‰æ²¡æœ‰æƒ³è¿‡ä¸ºä»€ä¹ˆè¦ç»™ find å‡½æ•°ä¼ å…¥è¿­ä»£å™¨å‘¢ï¼Ÿ
æˆ‘ä»¬æœ¬å¯ä»¥ç›´æ¥ç»™ find å‡½æ•°ä¼ å…¥æ•´ä¸ªå®¹å™¨ï¼Œä¸ºä»€ä¹ˆæ²¡è¿™ä¹ˆåšå‘¢ï¼Ÿ
```cpp
template <typename Container, typename T>
auto find(const Container& c, const T& value) {
    for (auto it = c.begin(); it != c.end(); ++it) {
        if (*it == value) return it;
    }
    return c.end();
}

std::vector<std::string> v { "seven", "kingdoms" };//`Container = std::vector<std::string>`ï¼ˆå®¹å™¨ç±»å‹ä¸ºå‘é‡<string>ï¼‰
auto it = find(v, "kingdoms");//`T = std::string`ï¼ˆæŸ¥æ‰¾å€¼ç±»å‹ä¸ºå­—ç¬¦ä¸²ï¼‰
```
ä¼˜åŠ¿ï¼šè¿™æ ·è°ƒç”¨è€…å°±ä¸ç”¨æ“å¿ƒ beginï¼ˆèµ·å§‹è¿­ä»£å™¨ï¼‰å’Œ endï¼ˆç»“æŸè¿­ä»£å™¨ï¼‰äº†ï¼æ‰€ä»¥ä¸ºä»€ä¹ˆä»¥å®¹å™¨ä¸ºå‚æ•°ä¼ å…¥å‡½æ•°
è¿™æ˜¯å› ä¸ºä½¿ç”¨è¿­ä»£å™¨åˆ™èƒ½è®©æˆ‘ä»¬åªæœç´¢å®¹å™¨çš„ä¸€éƒ¨åˆ†ï¼Œè€Œå®¹å™¨ä¸ºå‚æ•°ä¸è¡Œï¼
```cpp
std::vector<int> v { 106, 107, 106, 143, 149, 106 };

// æœç´¢106ï¼Œè·³è¿‡ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªå…ƒç´ 
auto it = find(v.begin() + 1, v.end() - 1, 106);

// ä½¿ç”¨std::distanceè·å–è¿­ä»£å™¨å¯¹åº”çš„ç´¢å¼•
std::cout << std::distance(v.begin(), it); 
// è¾“å‡º2ï¼Œè€Œä¸æ˜¯0
```
æœ‰äººä¼šè¯´ï¼Œæˆ‘ç›´æ¥auto it = c.begin()+1;ä¸ä¹Ÿæ˜¯å¯ä»¥çš„å—ï¼ä½ æƒ³æƒ³çœ‹ï¼Œå‰é¢è¿­ä»£å™¨ï¼Œæˆ‘ä»¬æƒ³ä¼ å…¥ç¬¬å‡ ä¸ªè¿­ä»£å™¨éƒ½å¯ä»¥ï¼Œfindå‡½æ•°çš„å†…æ¶µå°±æ˜¯ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å¼€å¤´çš„è¿­ä»£å™¨ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ç»“å°¾çš„è¿­ä»£å™¨ï¼Œä½†æ˜¯ä½ æ³¨æ„äº†å¦‚æœæ˜¯ç¬¬äºŒä¸ªå‡½æ•°ä»–çš„å†…æ¶µæ˜¯å¯¹å®¹å™¨è¿›è¡Œä»å¤´åˆ°å°¾çš„éå†ï¼Œè¿™æ ·åŠ ä¸€ä¸ª1ï¼Œç ´åäº†é€šç”¨æ€§ï¼Œè¡Œä¸ºä¸Šä¹Ÿä¸ç›´è§‚ï¼
æ‰€ä»¥æˆ‘ä»¬é€‰æ‹©ç”¨é€šç”¨çš„æ–¹å¼å®šä¹‰äº† find å‡½æ•°ï¼

ä½†æ˜¯è¿™æ ·çš„é€šç”¨æ€§è¿˜æ˜¯ä¸å¤Ÿå¼ºï¼
## å¦‚ä½•è®© find å‡½æ•°çš„é€šç”¨æ€§æ›´å¼ºå‘¢ï¼ï¼Ÿ

â— æˆ‘ä»¬ç°åœ¨çš„ find å‡½æ•°æ˜¯åœ¨å®¹å™¨ä¸­æŸ¥æ‰¾å€¼çš„ç¬¬ä¸€æ¬¡å‡ºç°
â— ä½†å¦‚æœæˆ‘ä»¬æƒ³æŸ¥æ‰¾ä»¥ä¸‹å†…å®¹çš„ç¬¬ä¸€æ¬¡å‡ºç°ï¼Œè¯¥æ€ä¹ˆåšå‘¢ï¼š
å­—ç¬¦ä¸²ä¸­çš„å…ƒéŸ³å­—æ¯ï¼Ÿ
å‘é‡`<int>`ä¸­çš„è´¨æ•°ï¼Ÿ
é›†åˆ`<int>`ä¸­èƒ½è¢« 5 æ•´é™¤çš„æ•°ï¼Ÿ

é‚£ä¹ˆè¿›å…¥ä»Šå¤©çš„ä¸»é¢˜ï¼š
# å‡½æ•°ä¸ Lambda è¡¨è¾¾å¼
å®šä¹‰ï¼šè°“è¯ï¼ˆPredicateï¼‰æ˜¯è¿”å›å¸ƒå°”å€¼çš„å‡½æ•°æˆ–è€…å‡½æ•°å¯¹è±¡ï¼
### è°“è¯ç¤ºä¾‹
ä¸€å…ƒè°“è¯ï¼šï¼ˆæ¥æ”¶ä¸€ä¸ªå‚æ•°ï¼‰
```cpp
bool isVowel(char c) {
	c = toupper(c);//toupperå‡½æ•°ä½œç”¨æ˜¯æŠŠå°å†™å­—æ¯æ›¿æ¢ä¸ºå¤§å†™å­—æ¯
	return	c == 'A' || c == 'Eâ€™ ||
			c == 'I' || c == 'Oâ€™ ||
			c == 'U';
}
bool isPrime(size_t n) {
	if (n < 2) return false;
	for (auto i = 3; i<=sqrt(n); i++)
		if (n % i == 0) return false;
	return true;
}
```
äºŒå…ƒè°“è¯ï¼šï¼ˆæ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼‰
```cpp
bool isLessThan(int x, int y) {
	return x < y;
}
bool isDivisible(int n, int d) 
{
	return n % d == 0;
}
```

### ä½¿ç”¨è°“è¯
â— å¦‚ä½•ç”¨isVowelï¼ˆåˆ¤æ–­å…ƒéŸ³å‡½æ•°ï¼‰åœ¨å­—ç¬¦ä¸²ä¸­æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå…ƒéŸ³å­—æ¯ï¼Ÿ
â— å¦‚ä½•ç”¨isPrimeï¼ˆåˆ¤æ–­è´¨æ•°å‡½æ•°ï¼‰åœ¨å‘é‡`<int>`ä¸­æŸ¥æ‰¾è´¨æ•°ï¼Ÿ
â— å¦‚ä½•ç”¨isDivisibleï¼ˆåˆ¤æ–­æ•´é™¤å‡½æ•°ï¼‰æŸ¥æ‰¾èƒ½è¢«5æ•´é™¤çš„æ•°ï¼Ÿ

æ ¸å¿ƒæ€è·¯ï¼šéœ€è¦å°†è°“è¯ä½œä¸ºå‚æ•°ä¼ å…¥å‡½æ•°
æ”¹é€ æˆ‘ä»¬çš„findå‡½æ•°
```cpp
template <typename It, typename T>
It find(It first, It last, const T& value) {
    for (auto it = first; it != last; ++it) {
        if (*it == value) return it;
    }
    return last;
}
```
ä¸Šé¢çš„ä»£ç ä¸­è¿™ä¸ªåˆ¤æ–­æ¡ä»¶åªèƒ½ç”¨äºæŸ¥æ‰¾ç‰¹å®šå€¼ï¼Œå±€é™æ€§å¤ªå¤§ã€‚å¦‚ä½•æ”¹é€ å®ƒä»¥æ”¯æŒé€šç”¨æ¡ä»¶åˆ¤æ–­å‘¢ï¼Ÿ
```cpp
template <typename It>
It find(It first, It last, ???? pred) {
    for (auto it = first; it != last; ++it) {
        if (*it == value) return it;
    }
    return last;
}
```
ä¸Šé¢çš„ä»£ç ä¸ºä¾‹å­ï¼Œè¦æ˜¯èƒ½å°†è°“è¯ä½œä¸ºå‚æ•°ä¼ å…¥è¿™ä¸ªå‡½æ•°ï¼Œä¼šæ€ä¹ˆæ ·å‘¢ï¼Ÿ
è¿™æ ·æˆ‘ä»¬å°±èƒ½æŠŠä»£ç ä¸­çš„å…³é”®åˆ¤æ–­éƒ¨åˆ†æ›¿æ¢æˆè°ƒç”¨è°“è¯äº†ã€‚
```cpp
template <typename It>
It find(It first, It last, ???? pred) {
    for (auto it = first; it != last; ++it) {
        if (pred(*it)) return it;
    }
    return last;
}
```
è¿™æ ·æˆ‘ä»¬å°±èƒ½æŠŠä»£ç ä¸­çš„å…³é”®åˆ¤æ–­éƒ¨åˆ†æ›¿æ¢æˆè°ƒç”¨è°“è¯äº†â€¦â€¦ å°±åƒè¿™æ ·ï¼
é‚£ä¹ˆä»£ç ä¸­çš„ï¼Ÿï¼Ÿï¼Ÿå¡«ä»€ä¹ˆï¼Ÿ
## ç­”æ¡ˆï¼šæ¨¡æ¿ç»“åˆè°“è¯

`Pred`ï¼šè¡¨ç¤ºæˆ‘ä»¬è°“è¯çš„ç±»å‹ã€‚ç¼–è¯‘å™¨ä¼šé€šè¿‡éšå¼å®ä¾‹åŒ–å¸®æˆ‘ä»¬æ¨å¯¼å‡ºè¿™ä¸ªç±»å‹ï¼
```cpp
template <typename It, typename Pred>
It find(It first, It last, Pred pred) {
    for (auto it = first; it != last; ++it) {
        if (pred(*it)) return it;
    }
    return last;
}
```
æˆ‘ä»¬å¯¹æ¯ä¸ªå…ƒç´ è°ƒç”¨è°“è¯ï¼Œä¸€æ—¦æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å…ƒç´ ï¼Œå°±è¿”å›å…¶è¿­ä»£å™¨ï¼
è¿™ä¸ªæ—¶å€™ä¸ºè¿™ä¸ªå‡½æ•°æ”¹ä¸ªåå­—é˜²æ­¢ä¸å‰é¢çš„æ··æ·†ï¼
```cpp
template <typename It, typename Pred>
It find_if(It first, It last, Pred pred) {
    for (auto it = first; it != last; ++it) {
        if (pred(*it)) return it;
    }
    return last;
}                                  
```
### ä½¿ç”¨æˆ‘ä»¬çš„ find_if å‡½æ•°
ä¾‹å­ä¸€ï¼š
```cpp
bool isVowel(char c) {
    c = ::toupper(c);//åŠ å†’å·æ˜¯ä¸ºäº†é˜²æ­¢ä¸ç±»ä¸­çš„å‡½æ•°å†²çªï¼Œå¦‚æœå†™æˆstd::toupperæ˜¯ä¸æ˜¯å°±æ˜ç™½äº†
    return c == 'A' || c == 'E' || c == 'I' ||
           c == 'O' || c == 'U';
}

std::string corlys = "Lord of the Tides";
auto it = find_if(corlys.begin(), corlys.end(), isVowel);
*it = '0'; // ç»“æœä¸ºâ€œL0rd of the Tidesâ€
```
ä¾‹å­äºŒï¼š
```cpp
bool isPrime(size_t n) {
    if (n < 2) return false;
    for (size_t i = 3; i <= std::sqrt(n); i++)
        if (n % i == 0) return false;
    return true;
}

std::vector<int> ints = {1, 0, 6};
auto it = find_if(ints.begin(), ints.end(), isPrime);
assert(it == ints.end());
```
ä¼ å…¥å‡½æ•°èƒ½è®©ç®—æ³•æ”¯æŒç”¨æˆ·è‡ªå®šä¹‰è¡Œä¸ºï¼Œä»è€Œå®ç°é€šç”¨åŒ–ã€‚ä¹Ÿå°±æ˜¯è¯´åœ¨å‡½æ•°åœ¨å¯ä»¥è‡ªå®šä¹‰å‡½æ•°çš„åˆ¤æ–­æ¡ä»¶ï¼Œå…¶å®ä¸ä»…ä»…æ˜¯åˆ¤æ–­æ¡ä»¶ï¼Œæƒ³ä¸€ä¸‹åœ¨pythonæˆ‘ä»¬å¯ä»¥æŠŠå‡½æ•°ä½œä¸ºå‚æ•°ä¼ å…¥å‡½æ•°ï¼Œå¸¦æ¥äº†è®¸å¤šä½œç”¨ï¼Œä¸€æ ·çš„ï¼Œè¿™ä¸ªå°±æ˜¯ç›¸å½“äºè¿™ä¸ªçš„ä½œç”¨ï¼

### è¯´çœŸçš„ï¼ŒPred çš„ç±»å‹åˆ°åº•æ˜¯ä»€ä¹ˆï¼Ÿ
`Pred`æ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆ
```cpp
find_if(corlys.begin(), corlys.end(), isVowel);
// Pred = bool(*)(char)ï¼ˆæŒ‡å‘æ¥æ”¶charã€è¿”å›boolçš„å‡½æ•°çš„æŒ‡é’ˆï¼‰

find_if(ints.begin(), ints.end(), isPrime);
// Pred = bool(*)(int)ï¼ˆæŒ‡å‘æ¥æ”¶intã€è¿”å›boolçš„å‡½æ•°çš„æŒ‡é’ˆï¼‰
```
boolä»£è¡¨â€œæˆ‘çš„å‡½æ•°è¿”å› bool ç±»å‹â€ï¼Œ`(*)`ä»£è¡¨â€œæˆ‘å°±æ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆâ€ï¼Œ(int)ä»£è¡¨â€˜â€™æˆ‘æ¥æ”¶ä¸€ä¸ª int ç±»å‹çš„å‚æ•°â€
ç¨åæˆ‘ä»¬ä¼šçœ‹åˆ°ï¼Œå‡½æ•°æŒ‡é’ˆåªæ˜¯èƒ½ä¼ ç»™ find_if çš„ä¸€ç§ç±»å‹è€Œå·²

ä½†æ˜¯
### å‡½æ•°æŒ‡é’ˆçš„é€šç”¨æ€§è¾ƒå·®
å‡è®¾æˆ‘ä»¬æƒ³åœ¨å‘é‡ä¸­æŸ¥æ‰¾å°äº N çš„æ•°
```cpp
bool lessThan5(int x) { return x < 5; }
bool lessThan6(int x) { return x < 6; }
bool lessThan7(int x) { return x < 7; }

find_if(begin, end, lessThan5);
find_if(begin, end, lessThan6);
find_if(begin, end, lessThan7);
```
å¦‚æœæˆ‘ä»¬æƒ³æŸ¥æ‰¾å°äº N çš„æ•°ï¼Œä½† N çš„å€¼è¦åˆ°è¿è¡Œæ—¶æ‰çŸ¥é“ï¼Œè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿï¼ˆå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬æƒ³è®©find_ifå‡½æ•°å¯ä»¥æ‰¾åˆ°å°äºä»»æ„Nçš„æ•°ï¼Œä½†æ˜¯Næ˜¯æœªçŸ¥çš„ï¼Œæ‹¿åˆ°æˆ‘ä»¬è¦å†™æ— æ•°ä¸ªlessThanNä½œä¸ºå‚æ•°ä¼ å…¥è¿›å»å—ï¼Œè€Œä¸”ä¹Ÿæ— æ³•æå‰çŸ¥é“å…·ä½“çš„Nï¼Œæ‰€ä»¥åˆ°æ—¶å€™å…·ä½“ä¼ å…¥å“ªä¸€ä¸ªéƒ½ä¸çŸ¥é“ï¼ï¼‰

ä½ ï¼š"ç¥ç»ç—…å§ï¼Œç›´æ¥åœ¨lessThanåŠ ä¸€ä¸ªå‚æ•°ä¸å°±å¯ä»¥äº†å—ï¼Œæƒ³ä¸‹é¢è¿™æ ·"
```cpp
bool isLessThan(int elem, int n) {
    return elem < n;
}
```
ä½†æ˜¯ï¼š
### æˆ‘ä»¬ä¸èƒ½ç›´æ¥ç»™è°“è¯åŠ å‚æ•°
è§‚å¯Ÿä¹‹å‰çš„find_ifçš„ä»£ç ï¼š
```cpp
template <typename It, typename Pred>
It find_if(It first, It last, Pred pred) {
    for (auto it = first; it != last; ++it) {
        if (pred(*it)) return it;
    }
    return last;
}
```
æˆ‘ä»¬åªç»™ pred ä¼ äº†ä¸€ä¸ªå‚æ•°å•Šï¼æ‰€ä»¥æ˜¯ä¸å…è®¸ç»™å‡½æ•°çš„å‚æ•°ä¼ å‚çš„ï¼ï¼ˆå½“ç„¶æ˜¯ä»…é™äºå‡½æ•°æ˜¯è°“è¯çš„æ—¶å€™ï¼ï¼‰

### æˆ‘ä»¬æƒ³ç»™å‡½æ•°æ·»åŠ é¢å¤–çš„çŠ¶æ€â€¦â€¦

â€¦â€¦ ä½†åˆä¸æƒ³å¼•å…¥æ–°çš„å‚æ•°
lambdaç™»ä¸Šäº†å†å²çš„èˆå°ï¼
## éš†é‡ä»‹ç»ï¼šLambda è¡¨è¾¾å¼
Lambda è¡¨è¾¾å¼æ˜¯èƒ½ä»å¤–å±‚ä½œç”¨åŸŸæ•è·çŠ¶æ€çš„å‡½æ•°
```cpp
int n;
std::cin >> n;

auto lessThanN = [n](int x) { return x < n; };

find_if(begin, end, lessThanN); // ğŸ˜ ğŸ˜
```
### Lambda è¡¨è¾¾å¼è¯­æ³•
```cpp
auto lessThanN = [n](int x) { 
    return x < n; 
};
```
`[n]`ï¼šæ•è·å­å¥ï¼Œè®©æˆ‘ä»¬èƒ½ä½¿ç”¨å¤–éƒ¨å˜é‡

`(int x)`ï¼šå‚æ•°åˆ—è¡¨ï¼Œå’Œæ™®é€šå‡½æ•°çš„å‚æ•°åˆ—è¡¨å®Œå…¨ä¸€æ ·

`{ return x < n; }`ï¼šå‡½æ•°ä½“ï¼Œå’Œæ™®é€šå‡½æ•°çš„å‡½æ•°ä½“å®Œå…¨ä¸€æ ·ï¼Œåªæ˜¯ä½œç”¨åŸŸå†…åªæœ‰å‚æ•°å’Œæ•è·çš„å˜é‡

å…¶å®ä»–å°±æ˜¯ä½ ä¸Šé¢æ‰€è¯´çš„å¾€å‡½æ•°çš„å‚æ•°ä¼ å‚ï¼Œåªæ˜¯å®ç°æ˜¯å½¢å¼ä¸ä½ æå‡ºçš„ä¸ä¸€æ ·ï¼
### å…³äºæ•è·çš„è¯´æ˜
```cpp
auto lambda = [capture-values](arguments) {
    return expression;
}
```
- `[x](arguments)`ï¼šæŒ‰å€¼æ•è· xï¼ˆåˆ›å»ºå‰¯æœ¬ï¼‰
- `[x&](arguments)`ï¼šæŒ‰å¼•ç”¨æ•è· x
- `[x, y](arguments)`ï¼šæŒ‰å€¼æ•è· x å’Œ y
- `[&](arguments)`ï¼šæŒ‰å¼•ç”¨æ•è·æ‰€æœ‰å¤–éƒ¨å˜é‡
- `[&, x](arguments)`ï¼šé™¤ x å¤–ï¼Œå…¶ä»–å¤–éƒ¨å˜é‡éƒ½æŒ‰å¼•ç”¨æ•è·
- `[=](arguments)`ï¼šæŒ‰å€¼æ•è·æ‰€æœ‰å¤–éƒ¨å˜é‡
### æˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸ä½¿ç”¨æ•è·ï¼

Lambda è¡¨è¾¾å¼å¾ˆé€‚åˆå¿«é€Ÿåˆ›å»ºä¸´æ—¶å‡½æ•°
```cpp
std::string corlys = "Lord of the tides";
auto it = find_if(corlys.begin(), corlys.end(), 
    [](auto c) {
        c = toupper(c);
        return c == 'A' || c == 'E' || 
               c == 'I' || c == 'O' || c == 'U';
    });
```
å¯¹äº†ï¼Œå€¼å¾—ç»™å¤§å®¶å¼ºè°ƒçš„æ˜¯ï¼š
### auto å‚æ•°æ˜¯æ¨¡æ¿çš„ç®€å†™å½¢å¼
```cpp
auto lessThanN = [n](auto x) { 
    return x < n; 
};
```
ç­‰åŒäº
```cpp
template <typename T>
auto lessThanN = [n](T x) { 
    return x < n; 
};
```
ä»–ä»¬çš„ä½œç”¨éƒ½æ˜¯ä¸€æ ·çš„ï¼
â€œæ— è®ºåœ¨ä»€ä¹ˆåœ°æ–¹çœ‹åˆ° auto å‚æ•°ï¼Œéƒ½é€‚ç”¨è¿™ä¸ªè§„åˆ™ï¼Œä¸åªæ˜¯ Lambda è¡¨è¾¾å¼ï¼â€

â€œè¿™ç”¨åˆ°äº†éšå¼å®ä¾‹åŒ–ï¼ç¼–è¯‘å™¨ä¼šåœ¨å‡½æ•°è°ƒç”¨æ—¶æ¨å¯¼å‡ºç±»å‹ã€‚â€
æ‰€ä»¥ä¸€äº›å¾ˆç»éªŒè€é“çš„c++ç¨‹åºå‘˜ï¼Œæ˜¯æ‡‚å¾—å¦‚ä½•åœ¨è¿™ä¸¤è€…ä¹‹é—´åˆ‡æ¢çš„ï¼Œå¤§å®¶éœ€è¦ç§¯ç´¯ç»éªŒå»ç†Ÿç»ƒä½¿ç”¨ï¼

é‚£ä¹ˆæŒ‰ç…§å°¿æ€§ï¼Œæˆ‘ä»¬åº”è¯¥æ¥äº†è§£ä¸€ä¸‹åŸç†ï¼ˆå…¶å®è¿™é—¨è¯¾ç¨‹éƒ½æ˜¯å°½é‡çš„ç»™å¤§å®¶è®²åŸç†çš„ï¼Œé™¤éä¸€äº›ç‰¹åˆ«æ¶‰åŠåº•å±‚ï¼Œä½†æ˜¯ä»æ±‡ç¼–ä»åº•å±‚ç¡¬ä»¶å¼€å§‹çš„æˆ‘ä»¬ä¸€èˆ¬ä¸ä¼šè¯´ï¼ï¼‰ï¼š
### Lambda è¡¨è¾¾å¼æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ
## å›é¡¾ï¼šæ ‡å‡†æ¨¡æ¿åº“ï¼ˆSTLï¼‰
è¿™æ˜¯STLçš„ç¬¬ä¸‰ä¸ªå†…å®¹
![[Pasted image 20251029002219.png]]
## å®šä¹‰ï¼šå‡½æ•°å¯¹è±¡ï¼ˆFunctorï¼‰æ˜¯å®šä¹‰äº† operator ()ï¼ˆè°ƒç”¨è¿ç®—ç¬¦ï¼‰çš„ä»»æ„å¯¹è±¡

é€šä¿—åœ°è¯´ï¼šè¡Œä¸ºç±»ä¼¼å‡½æ•°çš„å¯¹è±¡

### å‡½æ•°å¯¹è±¡ç¤ºä¾‹ï¼š`std::greater<T>`
```cpp
template <typename T>
struct std::greater {
    bool operator()(const T& a, const T& b) const {//operator()ä»–å¯ä»¥è®©å¯¹è±¡åƒå‡½æ•°ä¸€æ ·è¢«è°ƒç”¨
        return a > b;
    }
};

std::greater<int> g;
g(1, 2); // è¿”å›false
```
å—¯â€¦â€¦ çœ‹èµ·æ¥å’Œå‡½æ•°çœŸåƒğŸ¦†ğŸ¦†ï¼ˆé¸­å­ç±»å‹æ¯”å–»ï¼šçœ‹èµ·æ¥åƒé¸­å­ã€å«èµ·æ¥åƒé¸­å­ï¼Œé‚£å®ƒå°±æ˜¯é¸­å­ï¼‰
è™½ç„¶greateræ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä½†æ˜¯ä»–å´æƒ³å‡½æ•°ä¸€æ ·ï¼æ‰€ä»¥åœ¨ç¨‹åºå‘˜æ¥è¯´ï¼šè¿™å« **â€œå…³æ³¨è¡Œä¸ºï¼Œè€Œä¸æ˜¯ç±»å‹â€**ã€‚æœ‰ç‚¹åƒæŒ‡é¹¿ä¸ºé©¬ï¼

### å¦ä¸€ä¸ª STL å‡½æ•°å¯¹è±¡ï¼š`std::hash<T>`

é¢˜å¤–è¯ï¼šè¿™ç§è¯­æ³•ç§°ä¸ºé’ˆå¯¹ MyType ç±»å‹çš„æ¨¡æ¿ç‰¹åŒ–
```cpp
template <>
struct std::hash<MyType> {
    size_t operator()(const MyType& v) const {
        // è¿™é‡Œæ˜¯ç»è¿‡7ä½åšå£«å’Œå”çº³å¾·Â·å…‹åŠªç‰¹è®¤å¯çš„ã€ç†è®ºä¸¥è°¨çš„å“ˆå¸Œå‡½æ•°
        return ...;
    }
};

MyType m;
std::hash<MyType> hash_fn;
hash_fn(m); // ä¾‹å¦‚è¿”å›125123201
```
æç¤ºæç¤ºï¼šè¿™ä¹Ÿæ˜¯ä¸ºè‡ªå®šä¹‰ç±»å‹åˆ›å»ºå“ˆå¸Œå‡½æ•°çš„æ–¹æ³•ä¹‹ä¸€ï¼

## å› ä¸ºå‡½æ•°å¯¹è±¡æ˜¯å¯¹è±¡ï¼Œæ‰€ä»¥å®ƒå¯ä»¥æ‹¥æœ‰çŠ¶æ€

### å‡½æ•°å¯¹è±¡å¯ä»¥æ‹¥æœ‰çŠ¶æ€ï¼
```cpp
struct my_functor {
    bool operator()(int a) const {
        return a * value;
    }

    int value; //å“¦ï½è¿™ä¹ˆå¤šçŠ¶æ€å‘¢ğŸ¥¹ğŸ¥¹
};

my_functor f;
f.value = 5;
f(10); // è¿”å›50
```
## å½“ä½ ä½¿ç”¨ Lambda è¡¨è¾¾å¼æ—¶ï¼Œç¼–è¯‘å™¨ä¼šç”Ÿæˆä¸€ä¸ªå‡½æ•°å¯¹è±¡ç±»å‹

ä¸‹é¢è¿™æ®µä»£ç â€¦â€¦
```cpp
int n = 10;
auto lessThanN = [n](int x) { return x < n; };
find_if(begin, end, lessThanN);
```
â€¦â€¦ ç­‰åŒäºè¿™æ®µä»£ç ï¼
```cpp
class __lambda_6_18 //â€œè¿™ä¸ªç±»åæ˜¯ç¼–è¯‘å™¨å†…éƒ¨ä½¿ç”¨çš„éšæœºåç§°ï¼â€
{
public: 
    bool operator()(int x) const { return x < n; }//å›é¡¾ï¼šå‡½æ•°å¯¹è±¡çš„è°ƒç”¨è¿ç®—ç¬¦
    __lambda_6_18(int& _n) : n{_n} {}//â€œè¿™æ˜¯ç±»çš„æ„é€ å‡½æ•°â€
private: 
    int n; //â€œæˆ‘ä»¬æ•è·çš„å˜é‡å˜æˆäº†ç±»çš„æˆå‘˜å˜é‡ï¼â€
};

int n = 10;
auto lessThanN = __lambda_6_18{ n };//â€œé€šè¿‡å°†å¤–å±‚ä½œç”¨åŸŸçš„å˜é‡ n ä¼ å…¥æ„é€ å‡½æ•°ï¼Œå®ç°äº†å¯¹ n çš„æ•è·â€
find_if(begin, end, lessThanN);
```
å¦‚æœå¯¹è¿™ç±»å†…å®¹æ„Ÿå…´è¶£ï¼Œå¯ä»¥è®¿é—®[https://cppinsights.io/](https://cppinsights.io/)æŸ¥çœ‹æ›´å¤šç»†èŠ‚ï¼

## ä½ ä»¥å‰ä¹Ÿè§è¿‡ç±»ä¼¼çš„æƒ…å†µâ€¦â€¦
```cpp
std::vector<int> v {1,2,3};
for (const int& e : v) 
{
    // ... 
}
```
ç­‰åŒäº
```cpp
auto begin = v.begin();
auto end = v.end();
for (auto it = begin; it != end; ++it)
{
    // ...
}
```
## è¿™éƒ½æ˜¯è¯­æ³•ç³–ï¼ˆSyntactic Sugarï¼‰è€Œå·²
```cpp
int n = 10;
auto lessThanN = [n](int x) 
{ return x < n; };
find_if(begin, end, lessThanN);
```
ç­‰åŒäº
```cpp
class __lambda_6_18
{
public: 
    bool operator()(int x) const 
    { return x < n; }
    __lambda_6_18(int& _n) : n{_n} {}
private: 
    int n; 
};

int n = 10;
auto lessThanN = __lambda_6_18{n};
find_if(begin, end, lessThanN);
```
## å‡½æ•°ä¸ Lambda è¡¨è¾¾å¼å›é¡¾

ä½¿ç”¨å‡½æ•° / Lambda è¡¨è¾¾å¼å¯ä»¥å°†è¡Œä¸ºä½œä¸ºå˜é‡ä¼ é€’é¢˜å¤–è¯ï¼š`std::function`æ˜¯æ¶µç›–å‡½æ•° / Lambda è¡¨è¾¾å¼çš„é€šç”¨ç±»å‹
â— ä»»ä½•å‡½æ•°å¯¹è±¡ / Lambda è¡¨è¾¾å¼ / å‡½æ•°æŒ‡é’ˆéƒ½èƒ½è½¬æ¢ä¸º`std::function`ç±»å‹
â— ä½†`std::function`çš„æ•ˆç‡ä¼šç¨ä½ä¸€äº›
â— æˆ‘é€šå¸¸ç”¨ auto / æ¨¡æ¿ï¼Œä¸ç”¨ç‰¹æ„å…³æ³¨ç±»å‹ï¼
```cpp
std::function<bool(int, int)> less = std::less<int>{};
std::function<bool(char)> vowel = isVowel;
std::function<int(int)> twice = [](int x) { return x * 2; };
```
è¿™å°±æ˜¯lambdaçš„åŸç†ï¼

## æˆ‘ä»¬åœ¨å“ªäº›åœ°æ–¹ç”¨åˆ°å‡½æ•°ä¸ Lambda è¡¨è¾¾å¼ï¼Ÿ
ç­”æ¡ˆæ˜¯ç®—æ³•
![[Pasted image 20251029002313.png]]
è¿™æ˜¯STLçš„æœ€åä¸€ä¸ªå†…å®¹äº†ï¼
## å—¯â€¦â€¦ è¿™çœ‹èµ·æ¥å¾ˆç†Ÿæ‚‰
![[Pasted image 20251029002845.png]]
ï¼ˆå›¾ç‰‡è¯´æ˜ï¼šSTL ç®—æ³•å‡½æ•°å£°æ˜ï¼ŒåŒ…å« std::findã€std::find_ifã€std::find_if_notï¼Œæ ‡æ³¨äº† C++ æ ‡å‡†ç‰ˆæœ¬å’Œæ¨¡æ¿å‚æ•°ï¼‰
### `<algorithm>`æ˜¯æ¨¡æ¿å‡½æ•°çš„é›†åˆ

- `std::count_if(InputIt first, InputIt last, UnaryPred p);`ç»Ÿè®¡ `[first, last)` åŒºé—´å†…æ»¡è¶³è°“è¯ p çš„å…ƒç´ ä¸ªæ•°ã€‚
    
- `std::sort(RandomIt first, RandomIt last, Compare comp);`æ ¹æ®æ¯”è¾ƒå‡½æ•° comp å¯¹ `[first, last)` åŒºé—´å†…çš„å…ƒç´ è¿›è¡Œæ’åºã€‚
    
- `std::max_element(ForwardIt first, ForwardIt last, Compare comp);`æ ¹æ®æ¯”è¾ƒå‡½æ•° comp æ‰¾å‡º `[first, last)` åŒºé—´å†…çš„æœ€å¤§å…ƒç´ ã€‚

### `<algorithm>`ä¸­çš„å‡½æ•°åŸºäºè¿­ä»£å™¨æ“ä½œ

- `std::copy_if(InputIt r1, InputIt r2, OutputIt o, UnaryPred p);`ä»…å°† `[r1, r2)` åŒºé—´å†…æ»¡è¶³è°“è¯ p çš„å…ƒç´ å¤åˆ¶åˆ° o æŒ‡å‘çš„ä½ç½®ã€‚
    
- `std::transform(ForwardIt1 r1, ForwardIt1 r2, ForwardIt2 o, UnaryOp op);`å¯¹ `[r1, r2)` åŒºé—´å†…çš„æ¯ä¸ªå…ƒç´ æ‰§è¡Œæ“ä½œ opï¼Œå¹¶å°†ç»“æœå†™å…¥ o æŒ‡å‘çš„åºåˆ—ã€‚
    
- `std::unique_copy(InputIt i1, InputIt i2, OutputIt o, BinaryPred p);`ç§»é™¤ `[r1, r2)` åŒºé—´å†…è¿ç»­çš„é‡å¤å…ƒç´ ï¼Œå¹¶å°†ç»“æœå†™å…¥ o æŒ‡å‘çš„åºåˆ—ï¼ˆåˆ¤æ–­é‡å¤çš„è§„åˆ™ç”±äºŒå…ƒè°“è¯ p å®šä¹‰ï¼‰ã€‚

![[Pasted image 20251029003206.png]]ï¼ˆå›¾ç‰‡è¯´æ˜ï¼šSTL ç®—æ³•åˆ—è¡¨ï¼ŒåŒ…å« all_ofã€any_ofã€none_ofã€for_eachã€find ç­‰ï¼‰
â€œç®—æ³•çš„æ•°é‡å¯çœŸä¸å°‘â€¦â€¦â€
## ä½¿ç”¨ STL èƒ½å®ç°çš„åŠŸèƒ½

äºŒåˆ†æŸ¥æ‰¾ã€å †æ„å»ºã€æœ€å° / æœ€å¤§å€¼æ¯”è¾ƒã€å­—å…¸åºæ¯”è¾ƒã€åˆå¹¶ã€é›†åˆæ±‚å¹¶é›†ã€é›†åˆæ±‚å·®é›†ã€é›†åˆæ±‚äº¤é›†ã€åˆ†åŒºã€æ’åºã€æŸ¥æ‰¾ç¬¬ n å¤§å…ƒç´ ã€éšæœºæ‰“ä¹±ã€é€‰æ‹©æ€§åˆ é™¤ã€é€‰æ‹©æ€§å¤åˆ¶ã€éå†ã€éšæœºæŠ½æ ·

æ‰€æœ‰åŠŸèƒ½éƒ½ä»¥æœ€é€šç”¨çš„å½¢å¼å®ç°ï¼

### `<algorithm>`è®©æˆ‘ä»¬èƒ½æ£€æŸ¥å’Œè½¬æ¢æ•°æ®
`<algorithm>`Â æ˜¯ C++ æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªå¤´æ–‡ä»¶ã€‚ä½†æ˜¯ä»–çš„åŒ…å«äº†è®¸å¤šé€šç”¨ç®—æ³•ï¼Œè€Œä¸”ç”¨å¤„å¾ˆå¤§ï¼ä½¿ç”¨ `<algorithm>`ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹å®¹å™¨ä¸­çš„æ•°æ®è¿›è¡Œåˆ†æå’Œå¤„ç†ã€‚
![[Pasted image 20251029004039.png]]
STL ä¸åªæ˜¯â€œæ™®é€šç¼–ç¨‹â€ç”¨ï¼Œå®ƒåœ¨**ä¸“ä¸šé¢†åŸŸä¹Ÿéå¸¸é‡è¦**ã€‚å³ä½¿æ˜¯å¤æ‚çš„ç®—æ³•ï¼ˆå¦‚å‹ç¼©ï¼‰ï¼Œä¹Ÿå¯ä»¥å€ŸåŠ© STL å®ç°ã€‚**STL ä¸ä»…é€‚åˆå†™å°ç¨‹åºï¼Œè¿˜é€‚åˆå†™è¶…å¤§å‹å·¥ä¸šçº§ç³»ç»Ÿã€‚**
**C++ çš„ `<algorithm>` å¤´æ–‡ä»¶éå¸¸å¼ºå¤§ï¼Œä¸ä»…èƒ½å¤„ç†ç®€å•æ•°æ®ï¼Œè¿˜èƒ½ç”¨äºï¼š**

- ç”Ÿç‰©ä¿¡æ¯å­¦ï¼ˆSEQANï¼‰
- ç½‘ç»œé€šä¿¡ï¼ˆTCP åŒ…å¤„ç†ï¼‰
- æ•°æ®å‹ç¼©ï¼ˆHuffman ç¼–ç ï¼‰
- ç¼–è¯‘å™¨å¼€å‘ï¼ˆLLVMï¼‰

å®ƒæ˜¯ç°ä»£ C++ ç¼–ç¨‹çš„åŸºçŸ³ä¹‹ä¸€ã€‚
**`<algorithm>` æ˜¯ C++ çš„â€œç‘å£«å†›åˆ€â€â€”â€”æ— è®ºä½ æ˜¯åœ¨åˆ†æåŸºå› åºåˆ—ã€å‹ç¼©æ–‡ä»¶ï¼Œè¿˜æ˜¯æ„å»ºç¼–è¯‘å™¨ï¼Œå®ƒéƒ½èƒ½å¸®ä½ é«˜æ•ˆåœ°æ£€æŸ¥å’Œè½¬æ¢æ•°æ®ã€‚**
**ä¸è¦å°çœ‹ `<algorithm>`ï¼Œå®ƒæ˜¯ä»ç§‘ç ”åˆ°å·¥ä¸šçº§è½¯ä»¶éƒ½ä¾èµ–çš„å¼ºå¤§å·¥å…·ã€‚**

## è®©æˆ‘ä»¬ç”¨ STL ç¼–å†™ä¸€ä¸ªç®—æ³•ï¼
## Soundex ç®—æ³•ï¼
### ç›®æ ‡ï¼šä¸ºå§“åç”Ÿæˆè¯­éŸ³ç¼–ç 

â€œRobertsâ€ â†’ â€œR163â€

â€œRupertâ€ â†’ â€œR163â€

### Soundex ç®—æ³•æ­¥éª¤

1. ç»™å®šå­—ç¬¦ä¸² sï¼Œæå–å…¶ä¸­çš„å­—æ¯
2. å°†æ¯ä¸ªå­—æ¯æ›¿æ¢ä¸ºå¯¹åº”çš„ Soundex ç¼–ç 
3. åˆå¹¶ç›¸é‚»çš„é‡å¤ç¼–ç ï¼ˆå¦‚ 222025 å˜ä¸º 2025ï¼‰
4. ç”¨å­—ç¬¦ä¸² s çš„ç¬¬ä¸€ä¸ªå­—æ¯ï¼ˆå¤§å†™ï¼‰æ›¿æ¢ç¼–ç çš„ç¬¬ä¸€ä¸ªæ•°å­—
5. ä»ç¼–ç ä¸­ç§»é™¤æ‰€æœ‰ 0
6. å°†ç¼–ç è°ƒæ•´ä¸ºæ°å¥½ 4 ä½é•¿åº¦ï¼ˆè¿‡é•¿åˆ™æˆªæ–­ï¼Œè¿‡çŸ­åˆ™è¡¥ 0ï¼‰
### Soundex ç¼–ç è§„åˆ™
![[Pasted image 20251029010116.png]]
Soundex ç¼–ç å¯¹åº”è¡¨ï¼Œæ•°å­— 0 å¯¹åº” AEIOUHWYï¼Œ1 å¯¹åº” BFPVï¼Œ2 å¯¹åº” CGJKQSXZï¼Œ3 å¯¹åº” DTï¼Œ4 å¯¹åº” Lï¼Œ5 å¯¹åº” MNï¼Œ6 å¯¹åº” R

ä»¥ â€œRobertsâ€ ä¸ºä¾‹ï¼š

1. æå–å­—æ¯ï¼šRobertsï¼ˆå…¨ä¸ºå­—æ¯ï¼Œæ— éœ€ç­›é€‰ï¼‰
2. æ›¿æ¢ç¼–ç ï¼šRâ†’6ï¼Œoâ†’0ï¼Œbâ†’1ï¼Œeâ†’0ï¼Œrâ†’6ï¼Œtâ†’3ï¼Œsâ†’2 â†’ 6010632
3. åˆå¹¶é‡å¤ï¼š6010632ï¼ˆæ— ç›¸é‚»é‡å¤ï¼Œä¿æŒä¸å˜ï¼‰
4. æ›¿æ¢é¦–å­—ç¬¦ï¼šç”¨ R æ›¿æ¢ç¬¬ä¸€ä¸ªæ•°å­— 6 â†’ R010632
5. ç§»é™¤ 0ï¼šR1632
6. è°ƒæ•´é•¿åº¦ï¼šæˆªå–å‰ 4 ä½ â†’ R163
![[Pasted image 20251029010316.png]]

## è®©æˆ‘ä»¬ç”¨ STL å®ç° Soundex ç®—æ³•ï¼
ä½†æ˜¯å®ç°ä¹‹å‰æˆ‘ä»¬éœ€è¦è€ƒè™‘ä¸€äº›é—®é¢˜
é¦–å…ˆï¼š
## èƒ½è®©æˆ‘ä»¬çš„ Soundex ä»£ç æ›´æ˜“è¯»å—ï¼Ÿ
æœ‰ï¼Œé‚£å°±æ˜¯ï¼š
# èŒƒå›´ï¼ˆRangesï¼‰ä¸è§†å›¾ï¼ˆViewsï¼‰

èŒƒå›´æ˜¯ STL çš„æ–°ç‰ˆæœ¬
å®šä¹‰ï¼šèŒƒå›´ï¼ˆRangeï¼‰æ˜¯ä»»ä½•æ‹¥æœ‰ beginï¼ˆèµ·å§‹ï¼‰å’Œ endï¼ˆç»“æŸï¼‰çš„å¯¹è±¡

### å“ªäº›æ˜¯èŒƒå›´ï¼Ÿ

- `std::vector<T>`ï¼ˆå‘é‡ï¼‰
- `std::map<K, V>`ï¼ˆæ˜ å°„ï¼‰
- `std::set<K>`ï¼ˆé›†åˆï¼‰
- `std::unordered_set<K,V>`ï¼ˆæ— åºé›†åˆï¼‰
- ä½ è‡ªå·±å®šä¹‰çš„ã€æ‹¥æœ‰ begin å’Œ end çš„è‡ªå®šä¹‰ç±»å‹ï¼

## å›é¡¾ï¼šä¸ºä»€ä¹ˆæˆ‘ä»¬è¦ç»™ find å‡½æ•°ä¼ è¿­ä»£å™¨ï¼Ÿ
```cpp
int main() {
    std::vector<char> v = {'a', 'b', 'c', 'd', 'e'};
    auto it = std::find(v.begin(), v.end(), 'c');
}
```
ä¼ è¿­ä»£å™¨èƒ½è®©æˆ‘ä»¬æœç´¢å­èŒƒå›´ï¼ä½†å¤§å¤šæ•°æ—¶å€™ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦è¿™ä¸ªåŠŸèƒ½ã€‚

â€œæˆ‘ä»¬çœŸçš„åœ¨æ„è¿­ä»£å™¨å—ï¼Ÿæˆ‘åªæ˜¯æƒ³æœç´¢æ•´ä¸ªå®¹å™¨è€Œå·²ï¼â€

### èŒƒå›´ç®—æ³•ç›´æ¥æ“ä½œèŒƒå›´
```cpp
int main() {
    std::vector<char> v = {'a', 'b', 'c', 'd', 'e'};
    auto it = std::ranges::find(v, 'c');
}
```
â€œSTD èŒƒå›´åº“æä¾›äº†`<algorithm>`åº“ä¸­ç®—æ³•çš„æ–°ç‰ˆæœ¬ï¼Œä¸“é—¨ç”¨äºèŒƒå›´â€

â€œçœ‹ï¼æˆ‘å¯ä»¥ç›´æ¥ä¼  vï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªèŒƒå›´ï¼â€
### èŒƒå›´ç®—æ³•ä¹Ÿæ”¯æŒè¿­ä»£å™¨ï¼ˆæŒ‰éœ€ä½¿ç”¨ï¼‰
```cpp
int main() {
    std::vector<char> v = {'a', 'b', 'c', 'd', 'e'};

    // ä»'b'æœç´¢åˆ°'d'
    auto first = v.begin() + 1;
    auto last = v.end() - 1;
    auto it = std::ranges::find(first, last, 'c');
}
```
â— STL `<algorithm>`åº“ä¸­çš„å¤§å¤šæ•°ç®—æ³•éƒ½æœ‰å¯¹åº”çš„èŒƒå›´ç‰ˆæœ¬
ä¸‹é¢è¿™äº›éƒ½æ˜¯éå¸¸æ–°çš„ç‰¹æ€§ï¼éœ€è¦ C++20/23/26 åŠæ›´é«˜ç‰ˆæœ¬æ”¯æŒ
![[Pasted image 20251029011303.png]]
![[Pasted image 20251029011312.png]]
![[Pasted image 20251029011321.png]]
### èŒƒå›´ç®—æ³•æœ‰çº¦æŸæ¡ä»¶
è¿™æ„å‘³ç€å®ƒä»¬ä½¿ç”¨äº† STL çš„æ–°æ¦‚å¿µï¼ˆConceptsï¼‰ï¼è¿˜è®°å¾—å—ï¼Ÿå°±æ˜¯åœ¨ä¸Šä¸€èŠ‚è¯´åˆ°çš„ï¼

```cpp
template<class T>
concept range = requires(T& t) { ranges::begin(t); ranges::end (t); };//â€œèŒƒå›´å°±æ˜¯æ‹¥æœ‰ begin å’Œ end çš„å¯¹è±¡ï¼:)â€

template<class T>
concept input_range = //â€œè¾“å…¥èŒƒå›´ï¼ˆinput_rangeï¼‰æ˜¯ä½¿ç”¨è¾“å…¥è¿­ä»£å™¨çš„èŒƒå›´â€
    ranges::range<T> && std::input_iterator<ranges::iterator_t<T>>;

template<ranges::input_range R, class T, class Proj = std::identity>
borrowed_iterator_t<R> find( R&& r, const T& value, Proj proj = {} );
//â€œæˆ‘è¿™é‡Œçœç•¥äº†éƒ¨åˆ†ä»£ç ï¼Œä½†æ³¨æ„åˆ°èŒƒå›´ç‰ˆæœ¬çš„ find ä½¿ç”¨äº†æ¦‚å¿µï¼ˆConceptsï¼‰ï¼ï¼â€
```
## èŒƒå›´å›é¡¾

â— èŒƒå›´ä½¿ç”¨æ¦‚å¿µï¼ˆConceptsï¼‰ï¼é”™è¯¯ä¿¡æ¯æ›´å‹å¥½ï¼Œè¿™å¤šå¥½å•Šï¼
â— æˆ‘ä»¬å¯ä»¥ç›´æ¥ä¼ å…¥æ•´ä¸ªå®¹å™¨

### è§†å›¾ï¼ˆViewsï¼‰ï¼šç»„åˆç®—æ³•çš„æ–¹å¼ï¼ˆä»–æ¯”èŒƒå›´è¿˜æ–°ï¼Œc++23æ‰å¼•å…¥ï¼‰
å®šä¹‰ï¼šè§†å›¾ï¼ˆViewï¼‰æ˜¯ä¸€ç§å»¶è¿Ÿé€‚é…å¦ä¸€ä¸ªèŒƒå›´çš„èŒƒå›´

#### æ—§ STL ä¸­çš„è¿‡æ»¤ï¼ˆFilterï¼‰ä¸è½¬æ¢ï¼ˆTransformï¼‰
åœ¨å½“å‰çš„ STL ä¸­ï¼Œè¿™ç±»ä»£ç å†™èµ·æ¥æœ‰ç‚¹ç¹ç
```cpp
std::vector<char> v = {'a', 'b', 'c', 'd', 'e'};

// è¿‡æ»¤â€”â€”è¿‡æ»¤å‡ºå…ƒéŸ³å­—æ¯ â†’ å­˜åˆ°æ–° vector
std::vector<char> f;
std::copy_if(v.begin(), v.end(), std::back_inserter(f), isVowel);

// è½¬æ¢â€”â€”æŠŠ f ä¸­çš„å­—æ¯è½¬å¤§å†™ â†’ å­˜åˆ°å¦ä¸€ä¸ª vector
std::vector<char> t;
std::transform(f.begin(), f.end(), std::back_inserter(t), toupper);

// ç»“æœï¼š{ 'A', 'E' }
```
#### ç”¨è§†å›¾å®ç°è¿‡æ»¤ä¸è½¬æ¢

è§†å›¾æ˜¯ä¸€ç§èŒƒå›´ï¼Œå®ƒä¼šå»¶è¿Ÿè½¬æ¢åº•å±‚èŒƒå›´ï¼Œæ¯æ¬¡åªå¤„ç†ä¸€ä¸ªå…ƒç´ 
```cpp
std::vector<char> letters = {'a', 'b', 'c', 'd', 'e'};

auto f = std::ranges::views::filter(letters, isVowel);
auto t = std::ranges::views::transform(f, toupper);

auto vowelUpper = std::ranges::to<std::vector<char>>(t);
```
#### è§†å›¾æ”¯æŒç»„åˆ
```cpp
auto f = std::ranges::views::filter(letters, isVowel);
// fæ˜¯ä¸€ä¸ªè§†å›¾ï¼å®ƒæ¥æ”¶åº•å±‚èŒƒå›´letters
// ç”Ÿæˆä¸€ä¸ªåªåŒ…å«å…ƒéŸ³å­—æ¯çš„æ–°èŒƒå›´ï¼ä½†æ­¤æ—¶ä»€ä¹ˆéƒ½æ²¡åšï¼åªæ˜¯è®°ä½äº†è¿™ä¸ªè§„åˆ™

auto t = std::ranges::views::transform(f, toupper);
// tæ˜¯ä¸€ä¸ªè§†å›¾ï¼å®ƒæ¥æ”¶åº•å±‚èŒƒå›´f
// ç”Ÿæˆä¸€ä¸ªåŒ…å«å¤§å†™å­—æ¯çš„æ–°èŒƒå›´ï¼ä»ç„¶æ²¡æœ‰æ‰§è¡Œï¼åªæ˜¯ç»„åˆäº†ä¸¤ä¸ªæ“ä½œ

auto vowelUpper = std::ranges::to<std::vector<char>>(t);
// è¿™é‡Œæˆ‘ä»¬å°†è§†å›¾â€œå…·ä½“åŒ–â€ä¸ºå‘é‡ï¼
// åœ¨è¿™è¡Œä»£ç æ‰§è¡Œä¹‹å‰ï¼Œå®é™…ä¸Šä»€ä¹ˆéƒ½æ²¡åšï¼
//`std::ranges::to<T>` å°±æ˜¯è¿™ä¸ªâ€œå¯åŠ¨æ‰§è¡Œ + æ„é€ å®¹å™¨â€çš„å¼€å…³ï¼
```
ä¸ä»…ä»…æ˜¯ä»£ç ç®€æ´äº†ï¼Œç›¸æ¯”è€ç‰ˆæœ¬ï¼Œä»–å°‘äº†è®¸å¤šçš„ä¸­é—´å˜é‡ï¼Œæ¯”å¦‚ä¸Šé¢çš„ä¾‹å­ï¼Œæ²¡æœ‰äº†fè¿™ä¸ªä¸­é—´çš„æ•°ç»„ï¼
#### æˆ‘ä»¬å¯ä»¥ç”¨è¿ç®—ç¬¦ |ï¼ˆç®¡é“ç¬¦ï¼‰é“¾å¼ç»„åˆè§†å›¾
```cpp
std::vector<char> letters = {'a','b','c','d','e'};
std::vector<char> upperVowel = letters
    | std::ranges::views::filter(isVowel)
    | std::ranges::views::transform(toupper)
    | std::ranges::to<std::vector<char>>();

// upperVowel = { 'A', 'E' }
```

#### è®°ä½ï¼šèŒƒå›´ç®—æ³•æ˜¯ç«‹å³æ‰§è¡Œçš„
```cpp
// è¿™è¡Œä»£ç ä¼šç«‹å³å¯¹vecè¿›è¡Œæ’åºï¼Œé©¬ä¸Šæ‰§è¡Œï¼ï¼ï¼
std::ranges::sort(v);
```

#### è®°ä½ï¼šè§†å›¾æ˜¯å»¶è¿Ÿæ‰§è¡Œçš„
```cpp
std::ranges::viewsæ˜¯ç»„åˆç®—æ³•çš„å»¶è¿Ÿæ‰§è¡Œæ–¹å¼
auto view = letters
    | std::ranges::views::filter(isVowel)
    | std::ranges::views::transform(toupper);

std::vector<char> upperVowel =
    std::ranges::to<std::vector<char>>(view);
```

#### å°è´´å£«ï¼šè§†å›¾ç±»ä¼¼ Python ä¸­çš„ç”Ÿæˆå™¨ï¼ˆGeneratorsï¼‰
```cpp
auto view = letters
    | std::ranges::views::filter(isVowel)
    | std::ranges::views::transform(toupper);
auto upperVowel = std::ranges::to<std::vector<char>>(view);
```
è¿™æ®µ C++ ä»£ç çš„å·¥ä½œæ–¹å¼å’Œä¸‹é¢çš„ Python ä»£ç å®Œå…¨ä¸€æ ·
```python
view = (l for l in letters if isVowel(l))  # å»¶è¿Ÿæ‰§è¡Œ
view = (l.upper() for l in view)           # å»¶è¿Ÿæ‰§è¡Œ
upperVowel = list(view)
```
å›åˆ°æœ€å¼€å§‹çš„é—®é¢˜ï¼
## ç”¨è§†å›¾å®ç°çš„ Soundex ä¼šæ˜¯ä»€ä¹ˆæ ·å­ï¼Ÿ

## èŒƒå›´ä¸è§†å›¾å›é¡¾
â— ä¸ºä»€ä¹ˆä½ å¯èƒ½ä¼šå–œæ¬¢èŒƒå›´ / è§†å›¾ï¼Ÿ
	ä¸ç”¨å†è¿‡å¤šæ“å¿ƒè¿­ä»£å™¨
	å¸¦çº¦æŸçš„ç®—æ³•èƒ½æä¾›æ›´å‹å¥½çš„é”™è¯¯ä¿¡æ¯
	è¯­æ³•ç®€æ´æ˜“è¯»ï¼Œæ”¯æŒå‡½æ•°å¼ç¼–ç¨‹é£æ ¼
â— ä¸ºä»€ä¹ˆä½ å¯èƒ½ä¼šä¸å–œæ¬¢èŒƒå›´ / è§†å›¾ï¼Ÿ
	å®ƒä»¬éå¸¸æ–°ï¼ŒåŠŸèƒ½å°šæœªå®Œå…¨å®Œå–„
	ç¼–è¯‘å™¨æ”¯æŒç¨‹åº¦ä¸è¶³
	æ€§èƒ½ç›¸æ¯”æ‰‹å†™ä»£ç æœ‰æ‰€æŸå¤±
â— æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è€ƒã€ŠThe Terrible Problem of Incrementing a Smart Iteratorã€‹ï¼ˆã€Šæ™ºèƒ½è¿­ä»£å™¨è‡ªå¢çš„æ£˜æ‰‹é—®é¢˜ã€‹ï¼‰

## Soundexï¼šC++26 ç‰ˆæœ¬ï¼ˆ26è¿˜æ²¡æœ‰æ›´æ–°ï¼ï¼‰

ä¸€æ—¦è§†å›¾åŠŸèƒ½å®Œå…¨å®ç°ï¼Œæˆ‘ä»¬çš„ Soundex ä»£ç å¯èƒ½ä¼šæ˜¯è¿™æ ·çš„ï¼š
```cpp
namespace rng = std::ranges;
namespace rv = std::ranges::views;

auto ch = *rng::find_if(s, isalpha);              // è·å–ç¬¬ä¸€ä¸ªå­—æ¯ 
auto sx = s  | rv::filter(isalpha)                // è¿‡æ»¤éå­—æ¯å­—ç¬¦ 
             | rv::transform(soundexEncode)       // å¯¹å­—æ¯è¿›è¡ŒSoundexç¼–ç 
             | rv::unique                         // ç§»é™¤é‡å¤ç¼–ç 
             | rv::filter(notZero)                // è¿‡æ»¤æ‰0
             | rv::concat("0000")                 // ç¡®ä¿é•¿åº¦è‡³å°‘ä¸º4
             | rv::drop(1)                        // è·³è¿‡ç¬¬ä¸€ä¸ªç¼–ç ï¼ˆåç»­ç”¨é¦–å­—æ¯æ›¿æ¢ï¼‰
             | rv::take(3)                        // å–æ¥ä¸‹æ¥çš„3ä¸ªç¼–ç 
             | rng::to<std::string>();            // è½¬æ¢ä¸ºå­—ç¬¦ä¸²
return toupper(ch) + v;
```