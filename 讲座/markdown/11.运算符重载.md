# 复习
### 1. 模板类（Template Classes）

模板类就像一个 “工厂”，可生成适配不同数据类型的类。
- 未使用模板时，需为每种数据类型单独定义类：
```cpp
class IntVector {
    // 存储int类型列表的代码
};
class DoubleVector {
    // 存储double类型列表的代码
};
class StringVector {
    // 存储string类型列表的代码
};
```
- 使用模板类时，只需定义一次，即可适配多种数据类型：
```cpp
template <typename T>
class Vector {
    // 通用的列表存储代码，简洁又高效
};

// 实例化不同类型的Vector对象
Vector<int> v1;
Vector<double> v2;
Vector<string> v3;
```

### 2. const 正确性（Const Correctness）

const 正确性是类设计者与 C++ 程序之间的一种 “契约”，确保成员函数不会意外修改对象状态。
```cpp
template <class T> class Vector {
public:
    // const成员函数：承诺不修改对象
    size_t size() const; 
    bool empty() const;
    // 非const版本：允许修改返回的元素
    T& operator[] (size_t index); 
    // const版本：返回不可修改的元素（用于const对象）
    const T& at(size_t index) const; 
    // 接收const参数：不修改传入的元素
    void push_back(const T elem); 
};
```
const 成员函数的本质可理解为：向编译器承诺 “我不会在这个函数里修改当前对象”，编译器会帮你检查并确保这一点。

然后在上一节的课程中我们结束了对STL的全部学习！
### 3. C++ 标准与库参考

- 涵盖 C++11、C++14、C++17、C++20、C++23、C++26 等多个标准及编译器支持情况。
- 核心标准库包括：
    - 诊断库（Diagnostics library）
    - 字符串库（Strings library）
    - 内存管理库（Memory management library）
    - 文本处理库（Text processing library）
    - 容器库（Containers library）
    - 日期时间库（Date and time library，C++20 新增）
    - 语言支持库（Language support library，含 C++20 特性测试宏）
    - 输入输出库（Input/output library）
    - 迭代器库（Iterators library）
    - 算法库（Algorithms library）
    - 概念库（Concepts library，C++20 新增）
    - 执行支持库（Execution support library，C++26 新增）
- 技术规范扩展（Technical specifications）：
    - 并行库扩展 v2（Parallelism TS v2）
    - 标准库扩展 v3（Library Fundamentals TS v3，含 scope_exit、scope_fail 等）
    - 并发库扩展（Concurrency TS）
    - 事务内存（Transactional Memory TS）
    - 反射（Reflection TS）
![[Pasted image 20251030151643.png]]

## 二、运算符重载（Operator Overloading）
### 1. 运算符重载的动机
#### （1）从 std::map 的需求说起

`std::map<K, V>`要求键类型`K`必须支持`<`运算符，这是为什么？
因为`std::map`底层基于平衡二叉搜索树实现，需要通过`<`运算符比较键的大小，从而实现元素的插入、查找（如`map["Alex"]`）和排序。

示例：
![[Pasted image 20251030152005.png]]
通过`<`比较字符串键以实现查找`"Alex" < "Chris"`？→ 是，向左查找；`"Alex" < "CS106L"`？→ 是，向左查找，最终找到对应值（如`"Alex": 0`、`"Chris": 31`等）。

#### （2）运算符的核心价值

引用 CppCon 的经典观点：**“运算符能传递函数无法表达的类型语义”**。
以`min`函数为例：
```cpp
template <typename T>
T min(const T& a, const T& b) {
    return a < b ? a : b; // 依赖T的<运算符
}
```
要让`min<T>`编译通过，`T`必须满足两个条件：

1. 存在合理的排序关系（如`int`的大小、`string`的字典序）；
2. 是 “可比较的有序类型”，即逻辑上能确定 “最小值”。
例如，比较两个`StanfordID`对象（代表斯坦福 ID）：
```cpp
StanfordID jacob;
StanfordID fabio;
auto minStanfordID = min<StanfordID>(jacob, fabio);
```
此时编译器会报错 —— 因为`StanfordID`类未定义`<`运算符，编译器不知道如何比较两个`StanfordID`对象。
### 2. 运算符重载的基本原理

#### （1）本质：自定义运算符的行为

- 与在类中声明成员函数类似，可声明运算符的自定义功能；
- 当对自定义类的对象使用该运算符时，会执行自定义的逻辑；
- 与函数重载类似，若运算符名相同，会覆盖其默认行为（仅针对自定义类型）。
#### （2）可重载与不可重载的运算符
可重载运算符
![[Pasted image 20251030153552.png]]

不可重载运算符
`::`（作用域解析）、`? :`（三元运算符）、`.`（成员访问）、`.*`（指向成员的指针访问）、`sizeof()`（对象大小）、`typeid()`（类型信息）、`cast()`（强制类型转换，如`static_cast`）
这些运算符的语义是 C++ 语言层面固定的，无法修改！

### 3. 运算符重载的两种方式

#### （1）成员函数重载（Member Overloading）

- 定义在类的内部，隐含第一个参数为`this`指针（指向左侧操作数）；
- 仅需传入右侧操作数（`rhs`，即`right-hand side`）。

示例：为`StanfordID`类重载`<`运算符（按`idNumber`比较）：
- 头文件（.h）：
```cpp
class StanfordID {
private:
    std::string name;    // 姓名
    std::string sunet;   // 斯坦福网络ID
    int idNumber;        // 唯一ID号
public:
    // 构造函数
    StanfordID(std::string name, std::string sunet, int idNumber);
    // 成员函数重载<运算符（const成员函数，不修改对象）
    bool operator<(const StanfordID& rhs) const;
    // 获取私有成员idNumber（供外部访问）
    int getIdNumber() const { return idNumber; }
};
```
- 源文件（.cpp）：
```cpp
#include "StanfordID.h"

// 实现<运算符：比较两个对象的idNumber
bool StanfordID::operator<(const StanfordID& rhs) const {
    return this->idNumber < rhs.getIdNumber(); // this指向左侧操作数
}
```
#### （2）非成员函数重载（Non-member Overloading）

- 定义在类的外部，需显式传入左侧操作数（`lhs`，即`left-hand side`）和右侧操作数（`rhs`）；
- 是 STL 推荐的方式，更符合 C++ 的惯用写法（idiomatic C++）。

**优势**：

1. 支持左侧操作数为非类类型（如`3 + MyClass`，而成员重载仅支持`MyClass + 3`）；
```cpp
MyClass operator+(int lhs, const MyClass& rhs); // 支持 3 + obj
MyClass operator+(const MyClass& lhs, int rhs); // 支持 obj + 3
```
2. 可用于重载无法修改的类（如第三方库的类），只需在外部定义运算符。
	- 如果你使用的是别人写的类（比如来自某个库），你无法修改它的源码去添加成员函数。
	- 但你可以**在自己的代码中定义一个非成员的运算符重载函数**，只要至少有一个参数是你能控制的类型（或该类本身）。
	- 这极大提高了灵活性。

**问题**：非成员函数无法访问类的私有成员（如`StanfordID`的`idNumber`），需通过`friend`关键字解决。
要提醒大家的是，在定义非成员重载函数的时候，要注意参数一定是要加上类型的（废话，c++中所有函数都这样），而且这个类型不能是内置类型如 `int`, `double`, `char*` 等，这是违法的，只有当你重载的运算符**涉及自定义类、结构体、枚举等用户定义类型**时，才是合法的。
比如：
```
int operator+(int a, int b);        // ❌ 错误！不能重载 int + int
double operator*(double a, double b); // ❌ 错误！

MyClass operator+(const MyClass& a, int b);      // ✅ 合法（MyClass 是自定义类型）
MyClass operator+(int a, const MyClass& b);      // ✅ 合法
MyEnum operator|(MyEnum a, MyEnum b);            // ✅ 枚举也算用户定义类型
```
其实不用friend关键字也可以（前提是getIdNumber()是公有函数）
```cpp
return lhs.getIdNumber() < rhs.getIdNumber();
```
这样就挺好！但是如果一个类没有这样的方法，那这样就无法实现了！
所以接下来我们介绍friend关键字！

#### （3）友元关键字（friend）：突破访问限制

`friend`关键字允许非成员函数或其他类访问当前类的私有成员与私有函数，是实现非成员运算符重载的关键。
示例：用非成员函数重载`StanfordID`的`<`运算符：
- 头文件（.h）：
```cpp
class StanfordID {
private:
    std::string name;
    std::string sunet;
    int idNumber;
public:
    StanfordID(std::string name, std::string sunet, int idNumber);
    // 声明<运算符为友元，允许其访问私有成员
    friend bool operator<(const StanfordID& lhs, const StanfordID& rhs);（也可以把他放到类外定义和声明！）
};
```
bool operator<可不是类成员函数，这是因为加上了friend！
- 源文件（.cpp）：
```cpp
#include "StanfordID.h"

// 非成员函数实现<运算符：直接访问私有成员idNumber
bool operator<(const StanfordID& lhs, const StanfordID& rhs) {
    return lhs.idNumber < rhs.idNumber;
}
```
**注意**：避免歧义 —— 同一运算符不能同时用成员函数和非成员函数重载，否则编译器无法确定调用哪个版本。
### 4. 运算符重载的规则与设计哲学

#### （1）最小惊讶原则（Principle of Least Astonishment, PoLA）

运算符的功能必须 “符合直觉”，不能违背用户对该运算符的固有认知：

- 例如，`operator+`应实现 “加法” 语义（如向量相加、字符串拼接），而不是 “集合减法”；
- 若功能不直观，应改用命名函数（如`set_difference`），而非重载运算符。
#### （2）对立规则（Rule of Contrariety）

定义成对的运算符时，利用对立关系减少冗余代码：

- 例如，定义`operator==`后，`operator!=`可直接通过`!(*this == other)`实现；
```cpp
// 重载==：比较所有成员是否相等
bool StanfordID::operator==(const StanfordID& other) const {
    return (name == other.name) && (sunet == other.sunet) && (idNumber == other.idNumber);
}

// 重载!=：直接复用==的逻辑
bool StanfordID::operator!=(const StanfordID& other) const {
    return !(*this == other);
}
```
#### （3）灵活实现：以流插入运算符（<<）为例

`operator<<`常用于自定义对象的输出（如`cout << jacob`），其实现需适配`std::ostream`类型：
```cpp
// 非成员函数重载<<：输出StanfordID的信息
std::ostream& operator<<(std::ostream& out, const StanfordID& sid) {
    out << "姓名：" << sid.name << "，SUNet：" << sid.sunet << "，ID号：" << sid.idNumber;
    return out; // 返回out以支持链式调用（如cout << a << b）
}
```
使用方式：
```cpp
StanfordID jacob("Jacob", "jrb123", 12345);
std::cout << jacob << std::endl; 
// 输出：姓名：Jacob，SUNet：jrb123，ID号：12345
```
而且这个必须写成非成员函数，因为如果是成员函数，调用关系会出错，这是c++输出逻辑觉定的，比如一个类有函数A，实例化对象后是x这个名字，调用A函数就是A.x
写成成员函数就是：
```cpp
class StanfordID {
public:
    std::ostream& operator<<(std::ostream& out) {
        out << "姓名：" << name;
        return out;
    }
};
```
那么调用就写
```
jacob << std::cout;
```
“让 `jacob` 调用它的 `<<` 函数，把 `std::cout` 当作参数传进去。”
但是我们得要`std::cout`调用jacob！
### 5. 总结

1. **功能价值**：运算符重载为自定义对象解锁了新的功能层和语义表达能力，让对象操作更直观（如`a < b`、`cout << a`）。
2. **设计核心**：运算符的语义必须清晰合理 —— 核心目的是传递函数无法表达的类型含义，而非单纯 “简化代码”。
3. **使用原则**：按需重载 —— 仅在需要时定义（如无需输出对象则不重载`<<`），避免无意义的重载增加代码复杂度。