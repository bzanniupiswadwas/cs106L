# æ¨¡æ¿å‡½æ•°
ä¾æ—§æ˜¯ä¸€ä¸ªå°æ•…äº‹ï¼š
å½“ä½ éœ€è¦åœ¨c++å†™ä¸€ä¸ªæ¯”è¾ƒä¸¤ä¸ªæ•°ä¹‹é—´å¤§å°çš„å‡½æ•°ï¼Œæ€ä¹ˆåŠï¼š
```cpp
// è¿”å›aå’Œbä¸­çš„è¾ƒå°å€¼
int min(int a, int b) {
    return a < b ? a : b;
}
```
ï¼ˆå¦‚æœ a å°äº bï¼Œåˆ™è¿”å› aï¼Œå¦åˆ™è¿”å› bï¼‰è¿™æ˜¯ä¸ªä¸‰å…ƒè¿ç®—ç¬¦ï¼
è¿™å¾ˆå¸®ï¼
```cpp
min(106, 107);                  // æ•´å‹ï¼Œè¿”å›106
min(1.2, 3.4);                  // åŒç²¾åº¦æµ®ç‚¹å‹ï¼Œè¿”å›1.2
min("Jacob", "Fabio");      // å­—ç¬¦ä¸²ï¼Œè¿”å›"Fabio"
```
ä½†æ˜¯ï¼Œå¦‚æœè¿™ä¸¤ä¸ªæ•°æ˜¯doubleç±»å‹å‘¢ï¼Œå¦‚æœæ˜¯stringå‘¢ï¼Œæ‰€ä»¥...
min å‡½æ•°ä¸ä»…é€‚ç”¨äºæ•´æ•°ç±»å‹ã€‚é‚£æˆ‘ä»¬è¯¥å¦‚ä½•å®ç°è¿™ç§é€šç”¨æ€§å‘¢ï¼Ÿ

## è§£å†³æ–¹æ¡ˆä¹‹ä¸€ï¼šå‡½æ•°é‡è½½
```cpp
int min(int a, int b) {
    return a < b ? a : b;
}

double min(double a, double b) {
    return a < b ? a : b;
}

std::string min(std::string a, std::string b) {
    return a < b ? a : b;
}
```
ğŸ¤” å—¯â€¦â€¦ è¿™çœ‹èµ·æ¥ä¼¼æ›¾ç›¸è¯†ï¼æ‰€ä»¥è¿™ä¸ªæ–¹æ³•æŒ‰ç…§æƒ¯ä¾‹å¯ä»¥æ»šè›‹äº†ï¼

## æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¨¡æ¿ï¼

æ¥çœ‹è¿™æ®µä»£ç â€¦â€¦
```cpp
int min(int a, int b) {
    return a < b ? a : b;
}

double min(double a, double b) {
    return a < b ? a : b;
}

std::string min(std::string a, std::string b) {
    return a < b ? a : b;
}
```
## æˆ‘ä»¬å¯ä»¥å°†å…¶æ”¹å†™æˆè¿™æ ·ï¼
```cpp
template <typename T>
T min(T a, T b) {
    return a < b ? a : b;
}
```
è¿™å°±æ˜¯ä¸€ä¸ªæ¨¡æ¿ã€‚

å…¶ä¸­çš„ T ä¼šè¢«æ›¿æ¢ä¸ºå…·ä½“çš„ç±»å‹ã€‚æ¨¡æ¿å‡½æ•°ä»–å°±æ˜¯ä¸€ä¸ªç”Ÿäº§å‡½æ•°çš„å·¥å‚ã€‚

## è®°ä½ï¼šæ¨¡æ¿ä¸å‡½æ•°çš„åŒºåˆ«
```cpp
template <typename T>
T min(T a, T b) 
```

```cpp
min<std::string>
```
è¿™æ˜¯ä¸€ä¸ªæ¨¡æ¿ï¼Œå®ƒä¸æ˜¯å‡½æ•°ã€‚

è¿™æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œä¹Ÿç§°ä¸ºæ¨¡æ¿å®ä¾‹åŒ–ã€‚

## æ¨¡æ¿å‡½æ•°
```cpp
template <typename T>
T min(T a, T b) {
    return a < b ? a : b;
}

template <typename T>
T min(const T& a, const T& b) {
    return a < b ? a : b;
}
```
æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨å¼•ç”¨æ¥é¿å…æ‹·è´æ“ä½œï¼


## å¦‚ä½•è°ƒç”¨æ¨¡æ¿å‡½æ•°ï¼Ÿ
### æ–¹å¼ä¸€ï¼šæ˜¾å¼å®ä¾‹åŒ–
æ˜¾å¼å®ä¾‹åŒ–ç›´æ¥æŒ‡å®šç±»å‹ï¼Œä¸æ¨¡æ¿ç±»çš„ä½¿ç”¨æ–¹å¼ç±»ä¼¼ã€‚
```cpp
min<int>(106, 107);          // è¿”å›106
min<double>(1.2, 3.4);      // è¿”å›1.2
```

æ¨¡æ¿å‡½æ•°ä¼šè®©ç¼–è¯‘å™¨ä¸ºæˆ‘ä»¬ç”Ÿæˆä»£ç ã€‚
```cpp
int min(int a, int b) {                 // ç¼–è¯‘å™¨ç”Ÿæˆ
    return a < b ? a : b;               // ç¼–è¯‘å™¨ç”Ÿæˆ
}                                       // ç¼–è¯‘å™¨ç”Ÿæˆ

double min(double a, double b) {        // ç¼–è¯‘å™¨ç”Ÿæˆ
    return a < b ? a : b;               // ç¼–è¯‘å™¨ç”Ÿæˆ
}                                       // ç¼–è¯‘å™¨ç”Ÿæˆ

min<int>(106, 107);          // è¿”å›106
min<double>(1.2, 3.4);      // è¿”å›1.2
```

**æ ¸å¿ƒæ€æƒ³ï¼šæ¨¡æ¿å¯è‡ªåŠ¨ç”Ÿæˆä»£ç **

## æ–¹å¼äºŒï¼šéšå¼å®ä¾‹åŒ–
```cpp
min(106, 107);      // æ•´å‹ï¼Œè¿”å›106
min(1.2, 3.4);      // åŒç²¾åº¦æµ®ç‚¹å‹ï¼Œè¿”å›1.2
```
éšå¼å®ä¾‹åŒ–å…è®¸ç¼–è¯‘å™¨è‡ªè¡Œæ¨å¯¼å‡ºç±»å‹ã€‚

â€œæˆ‘æ²¡æœ‰æŒ‡å®šä»»ä½•æ¨¡æ¿ç±»å‹ï¼â€

## éšå¼å®ä¾‹åŒ–ç±»ä¼¼ auto å…³é”®å­—çš„ç”¨æ³•
```cpp
auto number = 106;
```
è¿™é‡Œçš„å˜é‡æœ¬è´¨ä¸Šè¿˜æ˜¯æ•´å‹ï¼Œåªæ˜¯è®©ç¼–è¯‘å™¨è‡ªè¡Œåˆ¤æ–­è€Œå·²ã€‚

```cpp
int m = min(106, 107);
```
è¿™å®Œå…¨ç­‰åŒäºç¼–å†™ï¼š`min<int>(106, 107)`

## éšå¼å®ä¾‹åŒ–å¯èƒ½å­˜åœ¨ä¸ç¡®å®šæ€§
```cpp
template <typename T>
T min(T a, T b) {
    return a < b ? a : b;
}

min("Jacob", "Fabio");
```
è¿™é‡Œçš„ T æ˜¯ä»€ä¹ˆç±»å‹ï¼Ÿå‚æ•°çš„ç±»å‹åˆæ˜¯ä»€ä¹ˆï¼Ÿ

```cpp
const char* min(const char* a, const char* b) {
    return a < b ? a : b;
}

min<const char*>("Jacob", "Fabio");
```
ï¼ˆè­¦å‘Šï¼‰æŒ‡é’ˆæ¯”è¾ƒï¼è¿™å¹¶ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ç»“æœã€‚ä¸ºä»€ä¹ˆä¼šè¿™æ ·å‘¢ï¼Œè¿™æ˜¯å› ä¸ºå­—ç¬¦ä¸²ä¼šè¢«è®¤å®šä¸ºæ˜¯ä¸€ä¸ªå­˜å‚¨å­—ç¬¦çš„æ•°ç»„ï¼Œè€Œæ•°ç»„æ˜¯æ— æ³•ä½œä¸ºå‡½æ•°å‚æ•°ç›´æ¥è¢«ä¼ é€’çš„ï¼Œä¸€èˆ¬éƒ½æ˜¯ä¼ é€’æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆï¼Œæ‰€ä»¥ä¼šè¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªæŒ‡é’ˆç±»å‹ï¼Œç„¶åå°±å®Œè›‹äº†ï¼

åœ¨è¿™ç§å­˜åœ¨æ­§ä¹‰çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å§‹ç»ˆå¯ä»¥ä½¿ç”¨æ˜¾å¼å®ä¾‹åŒ–ã€‚
```cpp
template <typename T>
T min(const T& a, const T& b) {
    return a < b ? a : b;
}

min<std::string>("Jacob", "Fabio");
```
æ­¤å¤„ const char * ä¼šè¢«è½¬æ¢ä¸º std::string ç±»å‹ã€‚

å¦ä¸€ä¸ªä¾‹å­ï¼šå‚æ•°ç±»å‹ä¸å®Œå…¨åŒ¹é…çš„æƒ…å†µã€‚
```cpp
template <typename T>
T min(const T& a, const T& b) {
    return a < b ? a : b;
}

min(106, 3.14); 
```
é”™è¯¯ï¼‰æ— æ³•é€šè¿‡ç¼–è¯‘ï¼è¿™ä¸¤ä¸ªç±»å‹éƒ½ä¸ä¸€æ ·æ€ä¹ˆåŠã€‚

æ­¤æ—¶éœ€ä½¿ç”¨æ˜¾å¼å®ä¾‹åŒ–ï¼š`min<double>(106, 3.14)`ï¼Œè¿™ä¸ªæ—¶å€™106ä¼šè¢«è½¬åŒ–ä¸º106.0
å¦ä¸€ç§è§£å†³æ–¹æ¡ˆï¼šè®©æ¨¡æ¿çš„çµæ´»æ€§æ›´é«˜ä¸€äº›ã€‚
```cpp
template <typename T, typename U>
????? min(const T& a, const U& b) {
    return a < b ? a : b;
}

min(106, 3.14);
```
è¿™é‡Œå‡½æ•°çš„è¿”å›ç±»å‹åº”è¯¥æ˜¯ä»€ä¹ˆï¼Ÿè¿™ä¸ªï¼Ÿï¼Ÿï¼Ÿï¼Ÿåˆ°åº•åº”è¯¥å¡«ä»€ä¹ˆï¼š

å…¶ä¸­ï¼ŒU = åŒç²¾åº¦æµ®ç‚¹å‹ï¼ˆdoubleï¼‰ï¼ŒT = æ•´å‹ï¼ˆintï¼‰ã€‚
ç­”æ¡ˆæ˜¯auto
```cpp
template <typename T, typename U>
auto min(const T& a, const U& b) {
    return a < b ? a : b;
}

min(106, 3.14);
```
è¿™é‡Œå‡½æ•°çš„è¿”å›ç±»å‹åº”è¯¥æ˜¯ä»€ä¹ˆï¼Ÿ

æƒ…å†µæ¯”è¾ƒå¤æ‚ï¼Œè®©ç¼–è¯‘å™¨é€šè¿‡ auto å…³é”®å­—è‡ªè¡Œåˆ¤æ–­å§ã€‚å…¶å®æ˜¯ä¼šè¿”å›doubleç±»å‹çš„ï¼Œä¸ºä»€ä¹ˆï¼Œå› ä¸ºintåˆ°doubleå¯ä»¥éšå¼è½¬åŒ–ï¼

## å®ç”¨æŠ€å·§ï¼šåˆ©ç”¨ IDE æŸ¥çœ‹å®ä¾‹åŒ–ç±»å‹

é›†æˆå¼€å‘ç¯å¢ƒï¼ˆå¦‚ VSCodeã€QtCreatorï¼‰å¯ä»¥æ˜¾ç¤ºå®é™…ä½¿ç”¨çš„ç±»å‹ã€‚ä»–ä¼šæ—è¾¹æœ‰ä¸€å°è¡Œçš„æç¤ºï¼Œå‘Šè¯‰ä½ ç¼–è¯‘å™¨æ¨æ–­çš„æ˜¯ä»€ä¹ˆç±»å‹ï¼ç„¶åä½ å°±å¯ä»¥åˆ¤æ–­ä½ å†™çš„ä»£ç æ˜¯ä¸æ˜¯ä½ æƒ³è¦çš„æ•ˆæœï¼


## é—®é¢˜ï¼šåœ¨å®é™…å¼€å‘ä¸­ï¼Œæˆ‘ä»¬åœ¨å“ªäº›åœºæ™¯ä¸‹ä¼šä½¿ç”¨æ¨¡æ¿å‡½æ•°ï¼Ÿ

## ç­”æ¡ˆï¼šåº”ç”¨åœºæ™¯éå¸¸å¤šï¼

ä¸€ä¸ªå…¸å‹çš„ä¾‹å­å°±æ˜¯è¿­ä»£å™¨ã€‚


## ç¼–å†™ find å‡½æ•°
```cpp
std::vector<int> v { 106, 111, 42, 112 };
auto it = find(v.begin(), v.end(), 42);
*it = 107;
// æ­¤æ—¶v = { 106, 111, 107, 112 }
```
find (b, e, 42) ä» begin å¼€å§‹ï¼Œä¾æ¬¡ç»è¿‡å€¼ä¸º 106ï¼ˆç´¢å¼• 0ï¼‰ã€111ï¼ˆç´¢å¼• 1ï¼‰çš„å…ƒç´ ï¼Œæ‰¾åˆ°å€¼ä¸º 42ï¼ˆç´¢å¼• 2ï¼‰çš„å…ƒç´ ï¼Œit æŒ‡å‘è¯¥ä½ç½®ï¼Œå°†å…¶ä¿®æ”¹ä¸º 107ï¼Œæœ€ååˆ° endï¼ˆç´¢å¼• 3ï¼Œå€¼ä¸º 112ï¼‰ç»“æŸï¼‰

è¿™æ˜¯ç¼–è¯‘å™¨å±•å¼€åçš„findå‡½æ•°ï¼š
```cpp
std::vector<int>::iterator find(
    std::vector<int>::iterator begin, 
    std::vector<int>::iterator end, 
    int value
) {
    // åœ¨è¯¥å®¹å™¨ä¸­æŸ¥æ‰¾å¯¹åº”è¿­ä»£å™¨çš„é€»è¾‘
    // å¦‚æœæœªæ‰¾åˆ°è¯¥å…ƒç´ ï¼Œåˆ™è¿”å›end
}
```

## è¿­ä»£å™¨ç±»å‹æœ‰å¾ˆå¤šç§ï¼
åŒ…æ‹¬ï¼š

`1.deque<T>::iteratorï¼ˆåŒç«¯é˜Ÿåˆ—è¿­ä»£å™¨ï¼Œå…ƒç´ ä¸º 1ã€9ã€7ã€3ã€2ã€1ã€2ã€9ï¼‰`
`2. vector<T>::iteratorï¼ˆå‘é‡è¿­ä»£å™¨ï¼Œå…ƒç´ ä¸º 1ã€0ã€2ã€1ã€2ã€4ã€3ã€4ï¼‰`
`3. map<K, V>::iteratorï¼ˆæ˜ å°„è¿­ä»£å™¨ï¼Œé”®å€¼å¯¹ä¸º â€œChrisâ€-31ã€â€œNickâ€-51ã€â€œSeanâ€-35ã€â€œCS106Lâ€-42ï¼‰`
`4. unordered_map<K, V>::iteratorï¼ˆæ— åºæ˜ å°„è¿­ä»£å™¨ï¼Œé”®å€¼å¯¹ä¸º â€œChrisâ€-31ã€â€œNickâ€-51ã€â€œKeithâ€-14ã€â€œSeanâ€-35ï¼‰ï¼‰`

ä½†å®ƒä»¬éƒ½æ‹¥æœ‰ç›¸åŒçš„æ¥å£ï¼

```cpp
// æ‹·è´æ„é€ 
auto it = c.begin();

// å‘å‰é€’å¢è¿­ä»£å™¨
++it;

// è§£å¼•ç”¨è¿­ä»£å™¨â€”â€”è‹¥it == end()ï¼Œåˆ™è¡Œä¸ºæœªå®šä¹‰
auto elem = *it;

// ç›¸ç­‰æ€§åˆ¤æ–­ï¼šæ˜¯å¦æŒ‡å‘åŒä¸€ä½ç½®ï¼Ÿ
if (it == c.end()) ...
```
## ä¹‹å‰çš„ find å‡½æ•°å®šä¹‰è¿‡äºå±€é™
```cpp
std::vector<int>::iterator find(
    std::vector<int>::iterator begin, 
    std::vector<int>::iterator end, 
    int value
) {
    // åœ¨è¯¥å®¹å™¨ä¸­æŸ¥æ‰¾å¯¹åº”è¿­ä»£å™¨çš„é€»è¾‘
    // å¦‚æœæœªæ‰¾åˆ°è¯¥å…ƒç´ ï¼Œåˆ™è¿”å›end
}
```

æ¢ä¸€ä¸ªç±»å‹å°±æ— æ³•é€šè¿‡äº†ï¼Œæˆ‘ä»¬ç¼–å†™çš„ find å‡½æ•°æ— æ³•ç”¨äºå…¶ä»–å‘é‡å®¹å™¨æˆ–å…¶ä»–ç±»å‹çš„å®¹å™¨ã€‚æ¯”å¦‚ï¼š
```cpp
std::vector<std::string> v { "seven", "kingdoms" };
auto it = find(v.begin(), v.end(), "kingdoms"); 
// æ— æ³•é€šè¿‡ç¼–è¯‘

std::set<std::string> s { "house", "targaryen" };
auto it = find(s.begin(), s.end(), "targaryen"); 
// æƒ…å†µä¼šå¾ˆç³Ÿç³•
```
å› ä¸ºä»ä¸Šé¢æˆ‘ä»¬å±•å¼€çš„findä»£ç æ¥çœ‹ï¼Œä¸€ä¸ªstringç±»å‹çš„vectorï¼Œä»–çš„è¿­ä»£å™¨ä¹Ÿæ˜¯è¿™æ ·çš„ï¼Œè€Œå­—ç¬¦ä¸²æ£€æµ‹çš„æ˜¯æŒ‡é’ˆç±»å‹ï¼Œæ‰€ä»¥ç¼–è¯‘å¤±è´¥ï¼æ‰€ä»¥ï¼š

## è®©æˆ‘ä»¬æ¥ç¼–å†™ä¸€ä¸ªæ¨¡æ¿å‡½æ•°å§ï¼

## ç¼–å†™ find å‡½æ•°â€¦â€¦ ä½†ç”¨æ¨¡æ¿å®ç°

```cpp
template <typename Iterator, typename TElem>
???? find(???? begin, ???? end, ???? value) {
    // åœ¨è¯¥å®¹å™¨ä¸­æŸ¥æ‰¾å¹¶è¿”å›æŒ‡å‘å€¼ä¸ºvalueçš„å…ƒç´ çš„è¿­ä»£å™¨
    // å¦‚æœæœªæ‰¾åˆ°è¯¥å…ƒç´ ï¼Œåˆ™è¿”å›end
}

find<std::vector<int>::iterator, int>(b, e, 42);
```
è¿™ä¸ªåœ¨106l.vercel.app/findçš„æ–‡ä»¶ä¸­å†™äº†ç­”æ¡ˆï¼

## STL ä¸­çš„ find å‡½æ•°
â— å±äº`<algorithm>`å¤´æ–‡ä»¶ï¼ˆåé¢çš„è¯¾ç¨‹æˆ‘ä»¬ä¼šè¯¦ç»†è®²è§£è¿™ä¸ªå¤´æ–‡ä»¶ï¼ï¼‰

```cpp
// std::findã€std::find_ifã€std::find_if_not
// å®šä¹‰äºå¤´æ–‡ä»¶<algorithm>
template< class InputIt, class T >
InputIt find( InputIt first, InputIt last, const T& value );
```
è¿™ä¸ªå°±æ˜¯c++å®˜æ–¹ç»™å‡ºçš„æ¨¡æ¿å‡½æ•°ï¼Œä¸ä¸Šé¢æˆ‘ä»¬è¦æ±‚å¤§å®¶å†™çš„å‡½æ•°ä½œç”¨æ˜¯ä¸€æ ·çš„ï¼
æ‰€ä»¥è¿™å°±æ˜¯æ¨¡æ¿å‡½æ•°çš„å¼ºå¤§ï¼ä½†æ˜¯ï¼Œå¦‚æœæ¨¡æ¿å‡½æ•°åˆ°æ­¤ä¸ºæ­¢ï¼Œè¿˜ä¸å¤Ÿå®Œç¾ï¼Œæ¯”å¦‚ï¼Œä¼šå‡ºç°ä¸‹é¢åƒå¥‡ç™¾æ€ªçš„é”™è¯¯ï¼š

# æ¦‚å¿µï¼ˆConceptsï¼‰
## å›åˆ°æˆ‘ä»¬çš„ min å‡½æ•°
```cpp
template <typename T>
T min(const T& a, const T& b) {
    return a < b ? a : b;
}

// å¯¹äºå“ªäº›ç±»å‹Tï¼Œä»¥ä¸‹ä»£ç èƒ½æˆåŠŸç¼–è¯‘ï¼Ÿ
T a = /* Tç±»å‹çš„å®ä¾‹ */;
T b = /* Tç±»å‹çš„å®ä¾‹ */;
min<T>(a, b);
```

## è¦ä½¿ç”¨ min å‡½æ•°ï¼Œç±»å‹ T å¿…é¡»æ»¡è¶³ä»€ä¹ˆæ¡ä»¶ï¼Ÿ
ç±»å‹ T å¿…é¡»æ‹¥æœ‰ operator<ï¼ˆå°äºè¿ç®—ç¬¦ï¼‰ï¼Œè¿™æ ·å‡½æ•°æ‰æœ‰æ„ä¹‰ã€‚
```cpp
struct StanfordID; // æˆ‘ä»¬è¯¥å¦‚ä½•æ¯”è¾ƒä¸¤ä¸ªIDå‘¢ï¼Ÿ

StanfordID jacob { "Jacob", "jtrb" };
StanfordID fabio { "Fabio", "fabioi" };
min<StanfordID>(jacob, fabio); // âŒ ç¼–è¯‘é”™è¯¯
```
å½“æˆ‘ä»¬è¿›è¡Œç¼–è¯‘çš„æ—¶å€™ï¼š
```bash
$ g++ main.cpp --std=c++20
main.cpp:9:12: error: invalid operands to binary expression
('const StanfordID' and 'const StanfordID')
return a < b ? a : b;
       ~ ^ ~
main.cpp:20:3: note: in instantiation of function template specialization 'min<StanfordID>' requested here
min<StanfordID>(jacob, fabio);
^
1 error generated.
```
ä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªæŠ¥é”™ä¸ä¸Šé¢ä¸åŒï¼Œå°½ç®¡è¿™æ¬¡ç±»å‹èµ‹äºˆæ˜¯æ­£ç¡®çš„ï¼Œä½†æ˜¯è¿™ä¸ªç±»å‹ä¸æ”¯æŒæ¯”è¾ƒè¿ç®—ç¬¦ï¼Œæ‰€ä»¥è¿˜æ˜¯æŠ¥é”™ï¼
## ç¼–è¯‘å™¨åªæœ‰åœ¨å®ä¾‹åŒ–åæ‰èƒ½å‘ç°é”™è¯¯
ç¼–è¯‘å™¨å…ˆå¯¹æ¨¡æ¿è¿›è¡Œäº†å®ä¾‹åŒ–ï¼Œä¹‹åæ‰å‘ç°é”™è¯¯ã€‚

ç¼–è¯‘å™¨ï¼šâ€œè¿™å°±ä¸ºæ‚¨ç”Ÿæˆ StanfordID ç±»å‹çš„ min å‡½æ•°ï¼â€
```cpp
StanfordID jacob { "Jacob", "jtrb" };
StanfordID fabio { "Fabio", "fabioi" };
min<StanfordID>(jacob, fabio);

StanfordID min(const StanfordID& a, const StanfordID& b)
{
    return a < b ? a : b;
}
```
ä½†æ˜¯è¿™ä¸ªç±»å‹å¯ä¸æ”¯æŒæ¯”è¾ƒè¿ç®—ç¬¦ï¼

ä¸ä»…ä»…æ˜¯minå‡½æ•°ï¼Œæ¯”å¦‚æˆ‘ä»¬ä¹‹å‰å­¦åˆ°è¿‡çš„std::setï¼Œä»–æ˜¯å­˜å‚¨åœ¨äºŒå‰æ ‘ä¸­çš„ï¼ŒæŸ¥æ‰¾ä¹Ÿæ˜¯é€šè¿‡æ¯”è¾ƒè¿ç®—ç¬¦å®ç°çš„ï¼Œå¦‚æœæˆ‘ä»¬å­˜å‚¨çš„æ˜¯`std::set<StanfordID> s { jacob, fabio };`ï¼Œç”±äºä¸æ”¯æŒæ¯”è¾ƒè¿ç®—ç¬¦ï¼ŒåŒæ ·æŠ¥é”™ï¼

è¿˜æœ‰çš„é”™è¯¯æ˜¯è¿™æ ·çš„ï¼š
```cpp
int main() {
    int idx = find(1, 5, 3); // å‘ƒâ€¦â€¦å¤§æ¦‚æ˜¯3ï¼Ÿæ•‘å‘½å•Š ğŸ¥²
}
```
ä¸€çœ‹ï¼Œå¥½åƒæ²¡æœ‰é—®é¢˜ï¼Œåœ¨1åˆ°5ä¸­å¯»æ‰¾3ã€‚ä½†æ˜¯findå‡½æ•°æ¥å—çš„å‰é¢ä¸¤ä¸ªå‚æ•°æ˜¯æŒ‡é’ˆï¼Œè€Œä¸æ˜¯æ•°ï¼Œç›´æ¥æŠ¥é”™ï¼

æ‰€ä»¥æˆ‘ä»¬æ˜¯æ—¶å€™è€ƒè™‘å¦‚ä½•è§„èŒƒåŒ–æ¨¡æ¿å‡½æ•°äº†ï¼

## æƒ³æ³•ï¼šå¦‚ä½•å¯¹æ¨¡æ¿æ–½åŠ çº¦æŸï¼Ÿ

â— æ¨¡æ¿è™½ç„¶å¾ˆå¼ºå¤§ï¼Œä½†åœ¨ä½¿ç”¨ä¸å½“çš„æ—¶å€™ï¼Œäº§ç”Ÿçš„é”™è¯¯ä¿¡æ¯å¾€å¾€éš¾ä»¥ç†è§£ã€‚
â— æˆ‘ä»¬æ€æ ·æ‰èƒ½æå‰æ˜ç¡®æ¨¡æ¿ç±»å‹éœ€è¦æ»¡è¶³çš„æ¡ä»¶å‘¢ï¼Ÿ

### C# ä¸­çš„å®ç°æ–¹å¼
```csharp
class EmployeeList<T> 
where T : notnull, Employee, IComparable<T>, new()
```
### Java ä¸­çš„å®ç°æ–¹å¼
```java
class ListObject<T extends Comparable<T>> 
```

åªæœ‰æ»¡è¶³æ‰€æœ‰çº¦æŸæ¡ä»¶ï¼Œç¼–è¯‘å™¨æ‰ä¼šå¯¹æ¨¡æ¿è¿›è¡Œå®ä¾‹åŒ–ã€‚
```cpp
template <typename T>
T min(const T& a, const T& b)

template <typename T>
struct set;

template <typename It, typename T>
It find(It begin, It end, const T& value)
```
æ¯”å¦‚ä¸Šé¢çš„ä»£ç ä¸­ï¼ŒT å¿…é¡»æ‹¥æœ‰ operator<ï¼ˆå°äºè¿ç®—ç¬¦ï¼‰ã€‚It å¿…é¡»æ˜¯è¿­ä»£å™¨ç±»å‹ã€‚

åœ¨c++ä¸­ï¼Œç§°è¿™ç§è§„èŒƒä¸ºConcepts

## æ¥è®¤è¯†ä¸€ä¸‹ C++ æ¦‚å¿µï¼ˆConceptsï¼‰å§ï¼
## åˆ›å»º Comparableï¼ˆå¯æ¯”è¾ƒçš„ï¼‰æ¦‚å¿µ
```cpp
template <typename T>
concept Comparable = requires(T a, T b) {
    { a < b } -> std::convertible_to<bool>;
};
```
conceptï¼ˆæ¦‚å¿µï¼‰ï¼šä¸€ç»„å¸¦æœ‰åç§°çš„çº¦æŸæ¡ä»¶ã€‚
requiresï¼ˆè¦æ±‚ï¼‰ï¼šç»™å®šä¸¤ä¸ª T ç±»å‹çš„å¯¹è±¡ï¼Œéœ€è¦æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ã€‚
çº¦æŸæ¡ä»¶ï¼šèŠ±æ‹¬å·`{ }`å†…çš„è¡¨è¾¾å¼å¿…é¡»èƒ½æ— é”™è¯¯åœ°ç¼–è¯‘ã€‚
çº¦æŸæ¡ä»¶ 2ï¼šâ€¦â€¦ å¹¶ä¸”è¡¨è¾¾å¼çš„ç»“æœå¿…é¡»èƒ½è½¬æ¢ä¸º bool ç±»å‹ï¼ˆå³ bool-likeï¼‰ã€‚
å…¶ä¸­ï¼Œconvertible_to æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªæ¦‚å¿µï¼

## ä½¿ç”¨æˆ‘ä»¬å®šä¹‰çš„ Comparable æ¦‚å¿µ
å¯ä»¥è¿™æ ·ï¼š
```cpp
template <typename T> requires Comparable<T>
T min(const T& a, const T& b);
```
ä¹Ÿå¯ä»¥ï¼š
```cpp
// ä»¥ä¸Šä»£ç çš„ç®€æ´å†™æ³•
template <Comparable T>
T min(const T& a, const T& b);
```

## æ¦‚å¿µèƒ½å¤§å¹…ä¼˜åŒ–ç¼–è¯‘é”™è¯¯ä¿¡æ¯
```cpp
template <typename T>
struct std::set;
```

ä»¥ä¸‹æ˜¯ä¹‹å‰æœªä½¿ç”¨æ¦‚å¿µæ—¶ï¼Œå®ä¾‹åŒ– set äº§ç”Ÿçš„é”™è¯¯ä¿¡æ¯ã€‚
![[Pasted image 20251026135505.png]]å¾ˆæ˜¯æ¶å¿ƒï¼Œè¦æˆ‘ä»ä¸­çœ‹å‡ºé”™è¯¯ï¼Œæ€äº†æˆ‘å§ï¼

```cpp
template <Comparable T>
struct std::set;
```
ä»¥ä¸‹æ˜¯ä½¿ç”¨æ¦‚å¿µåï¼Œå®ä¾‹åŒ– set äº§ç”Ÿçš„é”™è¯¯ä¿¡æ¯ã€‚
```bash
main.cpp:32:3: error: constraints not satisfied for class template 'set' [with T = StanfordID]
set<StanfordID> ids { jacob, fabio };
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main.cpp:13:11: note: because 'StanfordID' does not satisfy 'Comparable'
template <Comparable T>
          ^
main.cpp:10:7: note: because 'a < b' would be invalid: invalid operands to binary expression ('const StanfordID' and 'const StanfordID')
    { a < b } -> std::convertible_to<bool>;
      ~ ^ ~
4 errors generated.
```
è¿™å°±å¯ä»¥çœ‹å‡ºæ˜¯æ— æ³•æ¯”è¾ƒäº†ï¼

## C++ è‡ªå¸¦è®¸å¤šå†…ç½®æ¦‚å¿µ
```plaintext
æ ¸å¿ƒè¯­è¨€æ¦‚å¿µï¼ˆå®šä¹‰äºå¤´æ–‡ä»¶<concepts>ï¼‰
- same_as (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªç±»å‹ä¸å¦ä¸€ä¸ªç±»å‹ç›¸åŒ
- derived_from (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªç±»å‹æ´¾ç”Ÿè‡ªå¦ä¸€ä¸ªç±»å‹
- convertible_to (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªç±»å‹å¯éšå¼è½¬æ¢ä¸ºå¦ä¸€ä¸ªç±»å‹
- common_reference_with (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šä¸¤ä¸ªç±»å‹å…±äº«ä¸€ä¸ªå…¬å…±å¼•ç”¨ç±»å‹
- common_with (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šä¸¤ä¸ªç±»å‹å…±äº«ä¸€ä¸ªå…¬å…±ç±»å‹
- integral (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªç±»å‹ä¸ºæ•´æ•°ç±»å‹
- signed_integral (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªç±»å‹ä¸ºæœ‰ç¬¦å·æ•´æ•°ç±»å‹
- unsigned_integral (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªç±»å‹ä¸ºæ— ç¬¦å·æ•´æ•°ç±»å‹
- floating_point (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªç±»å‹ä¸ºæµ®ç‚¹ç±»å‹
- assignable_from (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªç±»å‹å¯ä»å¦ä¸€ä¸ªç±»å‹èµ‹å€¼
- swappable (C++20)ï¼ˆæ¦‚å¿µï¼‰ã€swappable_with (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªç±»å‹å¯äº¤æ¢ï¼Œæˆ–ä¸¤ä¸ªç±»å‹å¯ç›¸äº’äº¤æ¢
- input_iterator (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªç±»å‹ä¸ºè¾“å…¥è¿­ä»£å™¨ï¼Œå³å…¶å¼•ç”¨çš„å€¼å¯è¯»å–ï¼Œä¸”æ”¯æŒå‰ç½®å’Œåç½®é€’å¢
- output_iterator (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªç±»å‹ä¸ºç‰¹å®šå€¼ç±»å‹çš„è¾“å‡ºè¿­ä»£å™¨ï¼Œå³è¯¥ç±»å‹çš„å€¼å¯å†™å…¥ï¼Œä¸”æ”¯æŒå‰ç½®å’Œåç½®é€’å¢
- forward_iterator (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªè¾“å…¥è¿­ä»£å™¨ä¸ºå‰å‘è¿­ä»£å™¨ï¼Œæ”¯æŒç›¸ç­‰æ€§æ¯”è¾ƒå’Œå¤šè¶Ÿéå†
- bidirectional_iterator (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªå‰å‘è¿­ä»£å™¨ä¸ºåŒå‘è¿­ä»£å™¨ï¼Œæ”¯æŒå‘åç§»åŠ¨
- random_access_iterator (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªåŒå‘è¿­ä»£å™¨ä¸ºéšæœºè®¿é—®è¿­ä»£å™¨ï¼Œæ”¯æŒåœ¨å¸¸æ•°æ—¶é—´å†…æ¨è¿›å’Œä¸‹æ ‡è®¿é—®
- contiguous_iterator (C++20)ï¼ˆæ¦‚å¿µï¼‰ï¼šæŒ‡å®šæŸä¸ªéšæœºè®¿é—®è¿­ä»£å™¨ä¸ºè¿ç»­è¿­ä»£å™¨ï¼ŒæŒ‡å‘åœ¨å†…å­˜ä¸­è¿ç»­å­˜å‚¨çš„å…ƒç´ 
```
## å®Œå–„æˆ‘ä»¬çš„ find å‡½æ•°
```cpp
template <std::input_iterator It, typename T>
It find(It begin, It end, const T& value);

int idx = find(1, 5, 3); // ä¸ºä»€ä¹ˆè¿™ä¸ªä¸èƒ½æ­£å¸¸å·¥ä½œï¼Ÿ
```
çœ‹æŠ¥é”™ï¼š
```bash
main.cpp:10:11: note: because 'int' does not satisfy 'input_iterator'
template <std::input_iterator It, typename T>
```
åŸæ¥æ˜¯è¿™é‡ŒæŠ¥é”™å•Š.......ï¼

## æ¦‚å¿µå°ç»“

â— ä½¿ç”¨æ¦‚å¿µçš„ä¸¤ä¸ªåŸå› ï¼š

1. è·å¾—æ›´æ¸…æ™°çš„ç¼–è¯‘é”™è¯¯ä¿¡æ¯ã€‚
2. è·å¾—æ›´å¥½çš„ IDE æ”¯æŒï¼ˆå¦‚æ™ºèƒ½æç¤º / è‡ªåŠ¨è¡¥å…¨ç­‰ï¼‰ã€‚
    
    â— æ¦‚å¿µä»æ˜¯ä¸€ä¸ªè¾ƒæ–°çš„ç‰¹æ€§ï¼š
    
    STL å°šæœªå®Œå…¨æ”¯æŒæ¦‚å¿µã€‚
    
    ä¹‹åçš„è¯¾ç¨‹æˆ‘ä»¬ä¼šè¿›ä¸€æ­¥æ¢è®¨è¿™ä¸ªè¯é¢˜ï¼

# å¯å˜å‚æ•°æ¨¡æ¿ï¼ˆVariadic Templatesï¼‰
## å¦‚ä½•åˆ›å»ºå¯æ¥æ”¶å¯å˜æ•°é‡å‚æ•°çš„å‡½æ•°ï¼Ÿ
## å›åˆ°æˆ‘ä»¬çš„ min å‡½æ•°
```cpp
template <Comparable T>
T min(const T& a, const T& b) {
    return a < b ? a : b;
}

min(2.4, 7.5);                  // è¿™ä¸ªèƒ½æ­£å¸¸å·¥ä½œ
min(2.4, 7.5, 5.3);          // é‚£è¿™ä¸ªå‘¢ï¼Ÿ
min(2.4, 7.5, 5.3, 1.2); // è¿˜æœ‰è¿™ä¸ªå‘¢ï¼Ÿ
```
## è§£å†³æ–¹æ¡ˆä¹‹ä¸€ï¼šå‡½æ•°é‡è½½
```cpp
template <Comparable T>
T min(const T& a, const T& b) { return a < b ? a : b; }

template <Comparable T>
T min(const T& a, const T& b, const T& c) {
    auto m = min(b, c);
    return a < m ? a : m;
}

template <Comparable T>
T min(const T& a, const T& b, const T& c, const T& d) {
    auto m = min(b, c, d);
    return a < m ? a : m;
}
```
å¤„ç† 3 ä¸ªå…ƒç´ çš„é‡è½½å‡½æ•°ä¼šè°ƒç”¨å¤„ç† 2 ä¸ªå…ƒç´ çš„é‡è½½å‡½æ•°ã€‚

å¤„ç† 4 ä¸ªå…ƒç´ çš„é‡è½½å‡½æ•°ä¼šè°ƒç”¨å¤„ç† 3 ä¸ªå…ƒç´ çš„é‡è½½å‡½æ•°ã€‚

è¿™çœ‹èµ·æ¥å‡ ä¹æ˜¯é€’å½’çš„ï¼å¥½å§ï¼Œå°±æ˜¯é€’å½’ï¼

å¦‚æœæˆ‘ï¼š
```cpp
min(2.4, 7.5, 5.3, 1.2, 3.4, 6.7, 8.9, 9.1); ğŸ™„
```
æ˜¾ç„¶ï¼Œè¿™ä¸ªæ–¹æ³•ä¸å¯å–ï¼

## ç­‰ç­‰â€¦â€¦ æ¨¡æ¿çš„æ ¸å¿ƒå°±æ˜¯ä»£ç ç”Ÿæˆå‘€

ç¼–è¯‘å™¨èƒ½ä¸èƒ½å¸®æˆ‘ä»¬ç”Ÿæˆè¿™äº›é‡è½½å‡½æ•°å‘¢ï¼Ÿ
æ‰€ä»¥æˆ‘ä»¬çš„å¯å˜å‚æ•°çš„å‡½æ•°ï¼Œè¿˜æ˜¯å¾—ç”¨åˆ°æ¨¡æ¿å‡½æ•°ï¼

ä¸è¿‡ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹å¦ä¸€ç§ï¼ˆç•¥æœ‰ä¸åŒçš„ï¼‰è§£å†³æ–¹æ¡ˆã€‚
## æˆ‘ä»¬èƒ½ä¸èƒ½ç”¨ std::vector æ¥é€’å½’è§£å†³è¿™ä¸ªé—®é¢˜å‘¢ï¼Ÿ
```cpp
template <Comparable T>
T min(const std::vector<T>& values);

// è¿™é‡Œä¼ å…¥çš„æ˜¯vector<double>ç±»å‹ï¼
// æ³¨æ„è¿™é‡Œä½¿ç”¨äº†{ }åˆå§‹åŒ–åˆ—è¡¨ï¼ˆç»Ÿä¸€åˆå§‹åŒ–å‘é‡ï¼‰
min({ 2.4, 7.5 }); 
min({ 2.4, 7.5, 5.3 }); 
min({ 2.4, 7.5, 5.3, 1.2 }); 
```


```cpp
template <Comparable T>
T min(const std::vector<T>& values) {
    if (values.size() == 1) return values[0];
    const auto& first = values[0];
    std::vector<T> rest(++values.begin(), values.end());
    auto m = min(rest);
    return first < m ? first : m;
}
```
é€’å½’æƒ…å†µï¼ˆRecursive Caseï¼‰ï¼šå°†ç¬¬ä¸€ä¸ªå…ƒç´ ä¸å‰©ä½™å…ƒç´ çš„æœ€å°å€¼è¿›è¡Œæ¯”è¾ƒï¼Œè¿”å›è¾ƒå°çš„é‚£ä¸ªï¼

è¿™ä¸ªè§£å†³æ–¹æ¡ˆæ˜¯æ­£ç¡®çš„ã€‚ä½†æœ‰äººèƒ½çœ‹å‡ºå…¶ä¸­å­˜åœ¨çš„æ•ˆç‡é—®é¢˜å—ï¼Ÿ
## è¿™ç§æ–¹æ³•å­˜åœ¨çš„ä¸€äº›é—®é¢˜

1. å®ƒä¼šé€’å½’åœ°æ‹·è´å‘é‡ï¼ˆå¯ä»¥é€šè¿‡åŒ…è£…å‡½æ•°æ¥é¿å…ï¼ï¼‰ã€‚
2. æ¯æ¬¡è°ƒç”¨éƒ½å¿…é¡»åˆ†é…ä¸€ä¸ªå‘é‡ï¼ˆè¿™æ˜¯æ— æ³•é¿å…çš„å¼€é”€ï¼‰ã€‚

## æˆ‘ä»¬çœŸæ­£æƒ³è¦çš„æ•ˆæœ
```cpp
min(2.4, 7.5);                  // è¿™ä¸ªèƒ½æ­£å¸¸å·¥ä½œ
min(2.4, 7.5, 5.3);          // ç°åœ¨è¿™ä¸ªä¹Ÿèƒ½æ­£å¸¸å·¥ä½œäº†
min(2.4, 7.5, 5.3, 1.2); // è¿™ä¸ªä¹Ÿèƒ½æ­£å¸¸å·¥ä½œäº†

// è¿™ä¸ªä¹Ÿèƒ½ç›´æ¥æ­£å¸¸å·¥ä½œï¼
min(2.4, 7.5, 5.3, 1.2, 3.4, 6.7, 8.9, 9.1);
```

## æ¥è®¤è¯†ä¸€ä¸‹â€¦â€¦ å¯å˜å‚æ•°æ¨¡æ¿å§
## å¯å˜å‚æ•°æ¨¡æ¿
```cpp
template <Comparable T> //åŸºå‡†æƒ…å†µå‡½æ•°ï¼šç”¨äºç»ˆæ­¢é€’å½’
T min(const T& v) { return v; }

template <Comparable T, Comparable... Args> //å¯å˜å‚æ•°æ¨¡æ¿ï¼šåŒ¹é… 0 ä¸ªæˆ–å¤šä¸ªç±»å‹ã€‚
T min(const T& v, const Args&... args) { //å‚æ•°åŒ…ï¼ˆParameter packï¼‰ï¼š0 ä¸ªæˆ–å¤šä¸ªå‚æ•°ã€‚
    auto m = min(args...); //åŒ…å±•å¼€ï¼ˆPack expansionï¼‰ï¼šå°†`...args`æ›¿æ¢ä¸ºå®é™…çš„å‚æ•°ã€‚
    return v < m ? v : m;
}
```

æ˜¯ä¸æ˜¯å¤§å®¶è§‰å¾—æœ‰ç‚¹æ‡µï¼Œé‚£é‡Œæ¥çš„è¿™ä¸€ç³»åˆ—å¥‡æ€ªçš„è¯­æ³•ï¼Œä»–ä»¬æ˜¯æ€ä¹ˆå·¥ä½œçš„ï¼
## å‘¼â€¦â€¦ è¿™éœ€è¦å¥½å¥½æ¢³ç†ä¸€ä¸‹

ï¼ˆæ²¡æœ‰åŒå…³çš„æ„æ€ï¼‰
## åˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ
é€’å½’æƒ…å†µï¼ˆRecursive Caseï¼‰ï¼š
```cpp
template <Comparable T, Comparable... Args>
T min(const T& v, const Args&... args)
```
åŸºå‡†æƒ…å†µï¼ˆBase Caseï¼‰ï¼š
```cpp
template <Comparable T>
T min(const T& v) { return v; }
```
å½“ç¼–è¯‘å™¨é‡åˆ°è¿™æ ·çš„å‡½æ•°è°ƒç”¨æ—¶ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿ

ç­”æ¡ˆæ˜¯éšå¼å®ä¾‹åŒ–ï¼

```cpp
template <Comparable T, Comparable... Args>
T min(const T& v, const Args&... args)

template <Comparable T>
T min(const T& v) { return v; }
```
å…¶ä¸­ï¼ŒT = æ•´å‹ï¼ˆintï¼‰ï¼Œ`Args = [int, int, int]`
```cpp
min<int, int, int, int>(2, 7, 5, 1)

template <Comparable T, Comparable... Args>
T min(const T& v, const Args&... args) {
    auto m = min(args...);
    return v < m ? v : m;
}
```
ç„¶åComparable Tè¿›è¡Œäº†å®ä¾‹åŒ–ï¼š
```cpp
min<int, int, int, int>(2, 7, 5, 1)

template <Comparable... Args>
int min(const int& v, const Args&... args) {
    auto m = min(args...);
    return v < m ? v : m;
}
```
ç„¶ååŒ…å±•å¼€ï¼šArgs è¢«å±•å¼€ã€‚
```cpp
min<int, int, int, int>(2, 7, 5, 1)

template <Comparable... Args>
int min(const int& v, const int& a0, const int& a1, const int& a2) {
    auto m = min(args...);
    return v < m ? v : m;
}
```
åŒ…å±•å¼€ï¼šargs è¢«å±•å¼€ã€‚
```cpp
min<int, int, int, int>(2, 7, 5, 1)

int min(const int& v, const int& a0, const int& a1, const int& a2) {
    auto m = min(a0, a1, a2);
    return v < m ? v : m;
}
```
ç¼–è¯‘å™¨å·²ç»ä¸ºæˆ‘ä»¬ç”Ÿæˆäº†ä¸€ä¸ªé‡è½½å‡½æ•°ï¼å¦‚ä¸Šï¼

é‚£å…¶ä¸­çš„min(a0, a1, a2)æ˜¯ä»€ä¹ˆï¼Œè¿™æ˜¯å¦ä¸€ä¸ªæ¨¡æ¿å®ä¾‹åŒ–ï¼å¦‚ä¸‹ï¼š
```cpp
min<int, int, int>(a0, a1, a2);

template <Comparable T, Comparable... Args>
T min(const T& v, const Args&... args) {
    auto m = min(args...);
    return v < m ? v : m;
}
```
æŒ‰ç…§ä¸Šé¢çš„æ­¥éª¤å¾—åˆ°ï¼š
```cpp
int min(const int& v, const int& a0, const int& a1) {
    auto m = min(a0, a1);
    return v < m ? v : m;
}
```
ç»§ç»­ï¼š
```cpp
min<int, int>(a0, a1);

template <Comparable T, Comparable... Args>
T min(const T& v, const Args&... args) {
    auto m = min(args...);
    return v < m ? v : m;
}
```
å¾—åˆ°ï¼š
```cpp
int min(const int& v, const int& a0) {
    auto m = min(a0);
    return v < m ? v : m;
}
```
æœ€åï¼š
```cpp
min<int>(a0);

template <Comparable T>
T min(const T& v) { 
    return v; 
}

int min(const int& v) {
    return v;
}
```
## ç¼–è¯‘å™¨æ€»æ˜¯ä¼šä¼˜å…ˆé€‰æ‹©æœ€å…·ä½“çš„æ¨¡æ¿
ä¹Ÿå°±æ˜¯è¯´ï¼Œå•æ¬¡è°ƒç”¨`min(2, 7, 5, 1)`ç”Ÿæˆäº†ä»¥ä¸‹è¿™äº›å‡½æ•°ï¼š
```cpp
min(2, 7, 5, 1);

min<int, int, int, int>    // T = intï¼ŒArgs = [int, int, int]
min<int, int, int>          // T = intï¼ŒArgs = [int, int]
min<int, int>               // T = intï¼ŒArgs = [int]
min<int>                    // T = int
```
æ‰€ä»¥ï¼Œæœ¬è´¨ä¸Šè¿™ä¹Ÿæ˜¯ä¸€ä¸ªé€’å½’ï¼

## å¯å˜å‚æ•°çš„ç±»å‹ä¸å¿…ç›¸åŒ

â— åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæ‰€æœ‰çš„ T ç±»å‹éƒ½æ˜¯ç›¸åŒçš„ã€‚
â— ä½†åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå®ƒä»¬çš„ç±»å‹ä¹Ÿå¯ä»¥ä¸åŒã€‚
â— ä¾‹å¦‚ï¼Œæƒ³è±¡ä¸€ä¸ªç±»ä¼¼ printf çš„å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š`format("Queen {}, Protector of the {} Kingdoms", "Rhaenyra", 7);`å…¶ä¸­çš„`{}`å¯ä»¥ç”¨ä»»æ„æ•°é‡ã€ä»»æ„ç±»å‹çš„å‚æ•°æ¥å¡«å……ã€‚

## å¯å˜å‚æ•°çš„ç±»å‹ä¸å¿…æ˜¯ç›¸åŒçš„ï¼ˆå³å¯ä»¥æ˜¯å¼‚è´¨çš„ï¼‰
å‡è®¾æˆ‘ä»¬æƒ³è¦å®ç°ä¸€ä¸ªç±»ä¼¼ Python ä¸­ f-string çš„æ‰“å°å‡½æ•°ã€‚

å…¶ä¸­æ¶‰åŠçš„ç±»å‹åŒ…æ‹¬ï¼šstd::stringï¼ˆå­—ç¬¦ä¸²ï¼‰ã€intï¼ˆæ•´å‹ï¼‰ã€boolï¼ˆå¸ƒå°”å‹ï¼‰ã€std::stringï¼ˆå­—ç¬¦ä¸²ï¼‰ã€‚

```cpp
format("Queen {}, Protector of the {} Kingdoms", "Rhaenyra", 7);
// è¾“å‡ºï¼šQueen Rhaenyra, Protector of the 7 Kingdoms

std::cout << std::boolalpha;
format("The {} enemy won't {} out the {}", true, "wait", "storm");
// è¾“å‡ºï¼šThe true enemy won't wait out the storm

format("Winter is coming");
// è¾“å‡ºï¼šWinter is coming
```

å¦‚æœå‚æ•°ç±»å‹ä¸åŒï¼Œvector çš„åº•å±‚ç±»å‹è¯¥å¦‚ä½•ç¡®å®šå‘¢ï¼ŸæŒ‰ç…§ä¸Šé¢è®²çš„ä¾‹å­ï¼Œä¼šï¼š
```cpp
template <typename T>
void format(const std::string& fmt, std::vector<T> args) {
    // ...
}

format("{} {}", { true, "facts" });
// âŒ æ— æ³•ç¡®å®švectorçš„ç±»å‹
```
å½“ç„¶ï¼Œå¦‚æœæ‰€æœ‰å‚æ•°çš„ç±»å‹éƒ½ç›¸åŒï¼Œè¿™ç§æ–¹æ³•æ˜¯å¯è¡Œçš„ï¼Œä½†å¦‚æœå‚æ•°ç±»å‹ä¸åŒï¼Œå°±ä¸è¡Œäº†ã€‚
## å®ç° format å‡½æ•°
```cpp
void format(const std::string& fmt) {
    std::cout << fmt << std::endl;
}

template <typename T, typename... Args>
void format(const std::string& fmt, T value, Args... args) {
    auto pos = fmt.find("{}");
    if (pos == std::string::npos) throw std::runtime_error("Extra arg");
    std::cout << fmt.substr(0, pos);
    std::cout << value;
    format(fmt.substr(pos + 2), args...);
}
```
## å½“æˆ‘ä»¬å®ä¾‹åŒ– format å‡½æ•°æ—¶ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
```cpp
format("Lecture {}: {} (Week {})", 9, "Templates", 5);
```
1. `format<int, std::string, int>()`ï¼šT = intï¼ŒArgs = [std::string, int]
2. `format<std::string, int>()`ï¼šT = std::stringï¼ŒArgs = [int]
3. `format<int>()`ï¼šT = intï¼ŒArgs = []
4. `format()`ï¼šåŸºå‡†æƒ…å†µï¼ä¸æ˜¯æ¨¡æ¿ï¼Œæ²¡æœ‰ç±»å‹å‚æ•°

â— ç¼–è¯‘å™¨é€šè¿‡é€’å½’ç”Ÿæˆä»»æ„æ•°é‡çš„é‡è½½å‡½æ•°ã€‚è¿™ä½¿å¾—æˆ‘ä»¬èƒ½å¤Ÿæ”¯æŒä»»æ„æ•°é‡çš„å‡½æ•°å‚æ•°ã€‚
â— æ›´å¤šå…³äºé«˜çº§å¯å˜å‚æ•°æ¨¡æ¿çš„å†…å®¹ï¼Œå¯ä»¥æŸ¥çœ‹éšè—å¹»ç¯ç‰‡ï¼å¦‚æœä½ æ„Ÿå…´è¶£çš„è¯ï¼Œstd::tuple<T1,T2,â€¦>ï¼ˆå…ƒç»„ï¼‰å°±æ˜¯é€šè¿‡è¿™ç§æŠ€æœ¯å®ç°çš„ï¼
â— å®ä¾‹åŒ–å‘ç”Ÿåœ¨ç¼–è¯‘æ—¶ã€‚

# æ¨¡æ¿å…ƒç¼–ç¨‹ï¼ˆTemplate Metaprogrammingï¼‰

## å¦‚ä½•åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œä»£ç ï¼Ÿ
## æ¨¡æ¿å…ƒç¼–ç¨‹åŸºç¡€ï¼šé˜¶ä¹˜ï¼ˆFactorialï¼‰
```cpp
template <>
struct Factorial<0> { //åŸºå‡†æƒ…å†µï¼ˆBase Caseï¼‰ï¼šè¿™æ˜¯é’ˆå¯¹ N=0 çš„æ¨¡æ¿ç‰¹åŒ–ã€‚
    enum { value = 1 }; //enumï¼ˆæšä¸¾ï¼‰ï¼šä¸€ç§å­˜å‚¨ç¼–è¯‘æ—¶å¸¸é‡çš„æ–¹å¼ã€‚
};

template <size_t N>
struct Factorial {
    enum { value = N * Factorial<N - 1>::value }; //å“¦ï¼Œè¿™æ˜¯ç¼–è¯‘æ—¶é€’å½’ï¼
};

std::cout << Factorial<7>::value << std::endl;
```
è¯¥ä»£ç ä¼šè¾“å‡º 5040ï¼Œä½†è®¡ç®—è¿‡ç¨‹åœ¨ç¼–è¯‘æ—¶å®Œæˆï¼

## Factorial<7> çš„æ¨¡æ¿å®ä¾‹åŒ–è¿‡ç¨‹
![[Pasted image 20251026150829.png]]

## Factorial<7> çš„è¾“å‡ºæ±‡ç¼–ä»£ç 
```cpp
int main() {
    std::cout << Factorial<7>::value;
    return 0;
}
```
å¯¹åº”çš„æ±‡ç¼–ä»£ç ï¼š
```asm
main:
    push rax
    mov edi, offset cout
    mov esi, 5040
    call ostream::operator<<(int)
    xor eax, eax
    pop rcx
    ret
```
è®¡ç®—ç»“æœå·²ç›´æ¥åµŒå…¥åˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼

## å¦ä¸€ä¸ªä¾‹å­ï¼šæ–æ³¢é‚£å¥‘æ•°åˆ—ï¼ˆFibonacciï¼‰
```cpp
template <>
struct Fibonacci<0> {
    enum { value = 0 };
};

template <>
struct Fibonacci<1> {
    enum { value = 1 };
};

template <size_t N>
struct Fibonacci {
    enum { value = Fibonacci<N - 1>::value + Fibonacci<N - 2>::value };
};
```

## ä»€ä¹ˆæ˜¯æ¨¡æ¿å…ƒç¼–ç¨‹ï¼ˆTMPï¼‰ï¼Ÿ

## æ¨¡æ¿å…ƒç¼–ç¨‹åœ¨å®é™…å¼€å‘ä¸­æœ‰å“ªäº›åº”ç”¨åœºæ™¯ï¼Ÿ

1. åœ¨ç¼–è¯‘æ—¶å°†è®¡ç®—ç»“æœåµŒå…¥åˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼ˆä¾‹å¦‚é˜¶ä¹˜è®¡ç®—ï¼‰ã€‚
2. å¯¹çŸ©é˜µã€æ ‘æˆ–å…¶ä»–æ•°å­¦ç»“æ„è¿›è¡Œä¼˜åŒ–ã€‚
3. åŸºäºç­–ç•¥çš„è®¾è®¡ï¼ˆPolicy-based designï¼‰ï¼šé€šè¿‡æ¨¡æ¿ä¼ é€’è¡Œä¸ºã€‚
4. Boost MPL åº“ï¼ˆBoost å…ƒç¼–ç¨‹åº“ï¼‰ã€‚

## æ¨¡æ¿å…ƒç¼–ç¨‹å…è®¸å¯¹ç±»å‹è¿›è¡Œç¼–ç¨‹

Boost::mpl åº“æ˜¯ä¸€ä¸ªæµè¡Œçš„å…ƒç¼–ç¨‹åº“ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç±»å‹çš„å‘é‡ï¼
```cpp
using namespace boost;

using Move = mpl::vector<MoveUp, MoveRight>;
using MoveRotate = mpl::push_back<Move, Rotate45>::type;

template <typename Transformations>
void apply(Object&);

apply<Move>(object); // å°†å¯¹è±¡å‘ä¸Šå’Œå‘å³ç§»åŠ¨
apply<MoveRotate>(object); // å°†å¯¹è±¡å‘ä¸Š/å‘å³ç§»åŠ¨ï¼Œå¹¶æ—‹è½¬45åº¦
```
ç¼–è¯‘å™¨ä¼šæ ¹æ®å˜æ¢ï¼ˆTransformationsï¼‰ç”Ÿæˆç‰¹å®šçš„ä»£ç ã€‚

## æ¨¡æ¿å…ƒç¼–ç¨‹æ˜¯å›¾çµå®Œå¤‡çš„

æˆ‘ä»¬å¯ä»¥åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œä»»æ„ä»£ç ã€‚

ä½†å®ƒçš„è¯­æ³•å¹¶ä¸æ€»æ˜¯é‚£ä¹ˆç®€æ´â€¦â€¦
```cpp
template<>
struct push_back_impl< aux::vector_tag<BOOST_PP_DEC(i_)> >
{
    template< typename Vector, typename T > struct apply
    {
        typedef BOOST_PP_CAT(vector,i_)<
            BOOST_PP_ENUM_PARAMS(BOOST_PP_DEC(i_), typename Vector::item)
            BOOST_PP_COMMA_IF(BOOST_PP_DEC(i_))
            T
            > type;
    };
};
```
## å¦‚ä½•åŒæ—¶å®ç°ä»¥ä¸‹ä¸¤ç‚¹ï¼Ÿ

1. åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œä»£ç ã€‚
2. ä»£ç å…·æœ‰è‰¯å¥½çš„å¯è¯»æ€§ã€‚
## ä¸ç”¨å†å†™è¿™æ ·æ™¦æ¶©çš„ä»£ç äº†â€¦â€¦
```cpp
template <>
struct Factorial<0> {
    enum { value = 1 };
};

template <size_t N>
struct Factorial {
    enum { value = N * Factorial<N - 1>::value };
};

std::cout << Factorial<7>::value << std::endl;
```
## å¯ä»¥ä½¿ç”¨ constexpr/consteval å…³é”®å­—

å®ƒä»¬æ˜¯æ¨¡æ¿å…ƒç¼–ç¨‹çš„ â€œè§„èŒƒåŒ–â€ å®ç°ï¼ˆC++20 ä¸­æ–°å¢çš„ç‰¹æ€§ï¼‰ã€‚
```cpp
constexpr size_t factorial(size_t n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}

consteval size_t factorial(size_t n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}
```
constexprï¼ˆå¸¸é‡è¡¨è¾¾å¼ï¼‰ï¼šâ€œäº²çˆ±çš„ç¼–è¯‘å™¨ï¼Œè¯·å°½é‡åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œæˆ‘ ğŸ˜˜â€

constevalï¼ˆç«‹å³å‡½æ•°ï¼‰ï¼šâ€œäº²çˆ±çš„ç¼–è¯‘å™¨ï¼Œä½ å¿…é¡»åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œæˆ‘ ğŸ¤¬ğŸ¤¬â€

è¿™éƒ¨åˆ†å†…å®¹ç»“æŸï¼Œæœ¬èŠ‚ä¿¡æ¯é‡å¤§ï¼Œå¤§å®¶æ…¢æ…¢æ¶ˆåŒ–ï¼å…ƒç¼–ç¨‹è¿™éƒ¨åˆ†å¤§å®¶å¯ä»¥å…ˆæ”¾ä¸‹ï¼Œæ¯•ç«Ÿå¯¹äºc++ç‰¹æ€§è€Œè¨€ï¼Œä»–å¾®ä¸è¶³é“ï¼Œå¤§å®¶å¯ä»¥åœ¨ç†Ÿç»ƒçš„æŒæ¡c++ç‰¹æ€§ï¼Œå¹¶ä¸”æœ‰ç€å¤§é‡çš„ä»£ç ç»éªŒåå†æ¥å¤ä¹ ï¼

