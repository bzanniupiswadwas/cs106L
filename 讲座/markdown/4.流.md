## 流的定义

- 流是 C++ 中的通用输入 / 输出工具。
- 流是 C++ 中的通用输入 / 输出（IO）抽象概念。
### 抽象的作用

抽象能提供统一的接口，对于流而言，这个接口的作用是读取和写入数据。
### 常见的流示例

```cpp
std::cout << "Hello, World" << std::endl;
```

这就是一个流操作。其中，`std::cout`是`std::ostream`类的实例，代表标准输出流。
那么上面这行代码是怎么运作的呢？下面用三张图片来展示流的工作机制：
![[Pasted image 20251016170319.png]]
![[Pasted image 20251016170446.png]]
![[Pasted image 20251016170503.png]]
这就是上面一行代码，流做的事情！

## 如何从外部源读取数据到程序？（输入流）

如何从控制台读取一个双精度浮点数（double）？`std::cin`就是控制台输入流！它是`std::istream`类的实例，代表标准输入流。
```cpp
int main() {
    double pi;
    // 验证圆周率的值！
    std::cin >> pi; 
    std::cout << pi / 2 << '\n';
    return 0;
}
```
控制台输入 “3.14”，程序会输出 “1.57”。
上面两个是我们最常见的流的操作。
但是真正的建立在c++内部的流机制，可远不止这么简单，下面我们来系统的讲讲！

## 流的本质（类继承关系）
![[Pasted image 20251019152602.png]]
1. ios_base
2. basic_ios<CharT, Traits>
3. 分支 1：basic_ostream<CharT, Traits>（输出流基类）
    - 衍生类：basic_ostringstream<CharT, Traits>（字符串输出流）、basic_ofstream<CharT, Traits>（文件输出流）
4. 分支 2：basic_istream<CharT, Traits>（输入流基类）
    - 衍生类：basic_istringstream<CharT, Traits>（字符串输入流）、basic_ifstream<CharT, Traits>（文件输入流）
5. 交叉类：basic_iostream<CharT, Traits>（输入输出流，同时继承输出流和输入流的特性）

### 流与类型的关联
从上面的图可以看出来，流的类型有许多，真的很多！
但是这些类型各自都关联着一些功能——稍后会详细介绍。
他们的具体关系大概是想下面的图这样：
![[Pasted image 20251019153118.png]]
![[Pasted image 20251019153138.png]]
- `std::cout`属于`std::basic_ostream`类型，具备输出流的特性。
![[Pasted image 20251019153200.png]]
- `std::cin`属于`std::istream`类型，具备输入流的特性。
## 流的通用工作流程

外部源（如控制台、文件）→ 流 → 字符串形式（如 “3.14”）→ 类型转换 → 程序中的数据（如 double 类型的 3.14）
所有的流的类型都遵守这个工作流程，无一例外！不过不敢肯定，说不定之后c++100会颠覆他！

### 流的核心价值

流提供了一种统一处理外部数据的方式，无需针对不同外部源（控制台、文件、字符串等）重复编写读写逻辑。

## 流的分类
然而上面的那么多流的类型大概分为下面三类：

### 1. 输入流（Input streams，简称 “I”）

- 作用：从数据源读取数据。
- 继承自`std::istream`。
- 示例：从控制台读取数据（`std::cin`）。
- 主要运算符：`>>`（称为 “提取运算符”，用于从流中提取数据）。

### 2. 输出流（Output streams，简称 “O”）

- 作用：向数据目的地写入数据。
- 继承自`std::ostream`。
- 示例：向控制台输出数据（`std::cout`）。
- 主要运算符：`<<`（称为 “插入运算符”，用于向流中插入数据）。

### 3. 输入输出流（iostream）

- 是输入流和输出流的交集，同时具备两者的特性，可同时进行读写操作。
前面的两类已经在上面的韦恩图中显示出来了，那第三种输入输出流在哪里，他在：
![[Pasted image 20251019153626.png]]
在类的继承图中他位于：
![[Pasted image 20251019153653.png]]
现在大家大概分清楚了哪些类型了，那么我们就开始介绍具体的一些类型，说说他们的具体内容！

## 字符串流（std::stringstream）
### 什么是字符串流？

- 一种可将字符串当作流来处理的工具，同时具备输出流（ostream）和输入流（istream）的特性。

### 字符串流的用途

适用于需要混合处理不同数据类型的场景（如将字符串拆分为多个不同类型的数据，或拼接不同类型数据为字符串）。

字符串流属于第三种类型，输入输出流！他是basic_stringstream的实例！
![[Pasted image 20251019153946.png]]

### 字符串流示例代码
#### 示例 1：初始化与数据提取
```cpp
int main() {
    // 比雅尼的部分名言
    std::string initial_quote = "Bjarne Stroustrup C makes it easy to shoot yourself in the foot"; 
    // 创建字符串流（通过字符串构造函数初始化）
    std::stringstream ss(initial_quote);
    
    // 存储提取后数据的变量
    std::string first; 
    std::string last;
    std::string language, extracted_quote;
    
    // 从字符串流中提取数据
    ss >> first >> last >> language >> extracted_quote;
    // 输出结果
    std::cout << first << " " << last << " said this: " << language << " " << extracted_quote << std::endl;
    return 0;
}
```
#### 示例 2：通过插入运算符初始化字符串流
```cpp
int main() {
    // 比雅尼的部分名言
    std::string initial_quote = "Bjarne Stroustrup C makes it easy to shoot yourself in the foot"; 
    // 创建空字符串流
    std::stringstream ss;
    // 通过插入运算符将字符串写入流（流的常规操作方式）
    ss << initial_quote;
    
    // 存储提取后数据的变量
    std::string first; 
    std::string last;
    std::string language, extracted_quote;
    
    // 从字符串流中提取数据
    ss >> first >> last >> language >> extracted_quote;
    // 输出结果
    std::cout << first << " " << last << " said this: " << language << " " << extracted_quote << std::endl;
    return 0;
}
```
上面两段代码的大体一样，只是在初始化方式不一样！

### 关键注意点

- 流的核心作用：将数据从一个地方传输到另一个地方。
- `>>`运算符的限制：仅读取到下一个空白字符（空格、换行符`\n`、制表符`\t`）为止。

那么现在给大家看看他的具体运作吧：
当程序执行到ss << initial_quote;，流这个时候内部是这样的：
![[Pasted image 20251019154650.png]]
然后执行
    std::string first; 
    std::string last;
    std::string language, extracted_quote;
后得到：
![[Pasted image 20251019154756.png]]
然后ss >> first >> last >> language >> extracted_quote;
这行代码执行就是：
![[Pasted image 20251019154842.png]]
![[Pasted image 20251019154856.png]]
![[Pasted image 20251019154908.png]]
![[Pasted image 20251019154925.png]]
然后还要一个extracted_quote;，我们本身的想法是想把后续全部的后文都放在extracted_quote中，但是我们上面说到了`>>`运算符的限制：仅读取到下一个空白字符（空格、换行符`\n`、制表符`\t`）为止。
所以现实是：
![[Pasted image 20251019155121.png]]
extracted_quote = makes;
怎么办呢，需要引入getline函数！

## getline () 函数的使用
### 函数原型
```cpp
istream& getline(istream& is, string& str, char delim)
```
- 作用：从输入流`is`中读取数据，直到遇到分隔符`delim`，并将读取到的内容存储到字符串`str`中。
- 默认分隔符：`\n`（换行符）。也就是`delim`默认是\n
- 重要特性：`getline()`会**消耗掉分隔符**（即分隔符不会留在流缓冲区中），使用时需特别注意这一点。
结合后：
```cpp
int main() {
    // 比雅尼的部分名言
    std::string initial_quote = "Bjarne Stroustrup C makes it easy to shoot yourself in the foot"; 
    // 创建字符串流
    std::stringstream ss(initial_quote);
    
    // 存储提取后数据的变量
    std::string first; 
    std::string last;
    std::string language, extracted_quote;
    
    // 提取前三个单词（到空白字符为止）
    ss >> first >> last >> language;
    // 读取剩余的整行数据（包括空格）
    std::getline(ss, extracted_quote);
    // 输出结果（注意添加单引号使名言部分更清晰）
    std::cout << first << " " << last << " said this: '" << language << " " << extracted_quote << "'" << std::endl;
    return 0;
}
```

![[Pasted image 20251019155351.png]]
这样的话我们就达到目的了！

## 输出流（Output Streams）
接下来我们说说输出流。就是第二类。
### 输出流的定义与作用

- 作用：向数据目的地（如控制台、文件）写入数据。
- 示例：向控制台输出数据（`std::cout`）。
- 主要运算符：`<<`（插入运算符，用于向流中写入数据）。

### 输出流的缓冲机制

输出流中的字符会先存储在 “中间缓冲区”（intermediary buffer）中，直到触发 “刷新”（flush）操作，才会将缓冲区中的内容写入最终目的地。

比如：
```cpp
// 定义变量tao（约等于6.28，即2π）
double tao = 6.28; 
// 将tao的值写入std::cout流（此时数据仅在缓冲区，未输出到控制台）
std::cout << tao; 
```
这个时候终端不会输出任何的内容，内容在缓冲区。
`std::cout`是 “行缓冲”（line-buffered）的，即缓冲区中的内容默认不会立即显示，需显式触发刷新。

#### 触发刷新的方式
1：使用`std::flush`显式刷新：
```cpp
double tao = 6.28; 
std::cout << tao; 
// 显式刷新缓冲区，将数据输出到控制台
std::cout << std::flush; 
```
此时控制台会输出 “6.28”。
![[Pasted image 20251019160019.png]]

2：使用`std::endl`（换行 + 刷新）：
```cpp
double tao = 6.28; 
std::cout << tao; 
// 换行并刷新缓冲区（等同于“\n” + std::flush）
std::cout << std::endl; 
```
此时控制台会输出 “6.28” 并换行。
![[Pasted image 20251019160114.png]]

### std::endl 与 '\n' 的区别
没有任何显示刷新的情况下：
```cpp
int main() {
    // 循环输出1到5
    for (int i = 1; i <= 5; ++i) {
        std::cout << i; 
    }
    return 0;
}
```
![[Pasted image 20251019160358.png]]
这里会输出的原因大家是不是有点疑惑，就是没有显示刷新缓冲区，怎么就输出了，其实是因为在程序结束后，缓冲区会自动的刷新！
#### 示例 1：使用 std::endl
```cpp
int main() {
    // 循环输出1到5
    for (int i = 1; i <= 5; ++i) {
        // 输出i的值并换行+刷新
        std::cout << i << std::endl; 
    }
    return 0;
}
```
- 输出结果：每个数字单独占一行（“1”“2”“3”“4”“5” 分别换行）。
- 原因：`std::endl`会同时完成 “换行” 和 “刷新缓冲区” 两个操作，每次循环都会立即输出数据。
![[Pasted image 20251019160212.png]]
他会执行两个操作。如：
![[Pasted image 20251019160649.png]]
然后缓冲区为：
![[Pasted image 20251019160720.png]]
然后在下一个for循环的时候：
![[Pasted image 20251019160747.png]]
如此往复！

#### 示例 2：仅使用 '\n'（换行符）
```cpp
int main() {
    // 循环输出1到5
    for (int i = 1; i <= 5; ++i) {
        // 仅输出i的值和换行符（不主动刷新）
        std::cout << i << '\n'; 
    }
    return 0;
}
```
那他是怎么样的呢，在执行for循环的途中是：
![[Pasted image 20251019161056.png]]
![[Pasted image 20251019161105.png]]
![[Pasted image 20251019161118.png]]
![[Pasted image 20251019161130.png]]
![[Pasted image 20251019161230.png]]
这个时候缓冲区满了，然后c++自动的刷新了，然后输出：
![[Pasted image 20251019161302.png]]
但是程序还没有结束，怎么办，继续：
![[Pasted image 20251019161338.png]]
然后输出5，这与用endl的最后结果没有任何不同。
![[Pasted image 20251019161415.png]]

### 补充说明：缓冲机制的特殊情况

根据 C++ 参考文档（CPP Reference）：

- 在许多实现中，标准输出（如`std::cout`）是行缓冲的，写入`'\n'`会触发刷新，除非执行了`std::ios::sync_with_stdio(false)`（关闭 C 和 C++ 标准流的同步）。
- 若将输出重定向到文件（如通过`| cat`命令），`'\n'`不会立即触发刷新，需显式使用`std::flush`或`std::endl`。

#### 性能优化建议

- 若无需立即刷新（如大量循环输出），建议使用`'\n'`而非`std::endl`，因为刷新操作（flush）会消耗额外性能。
- 若需要关闭流同步以提升性能，可添加以下代码（但需注意可能的兼容性问题）：
```cpp
int main() {
    // 关闭C和C++标准流的同步，提升输出性能
    std::ios::sync_with_stdio(false); 
    for (int i = 1; i <= 5; ++i) {
        std::cout << i << '\n'; 
    }
    return 0;
}
```

当然输出流还要其他的，不仅仅是std::cout！
### 其他输出流：cerr 与 clog

- `cerr`：用于输出错误信息，**无缓冲**（unbuffered），即写入后立即输出，无需刷新。
- `clog`：用于输出非紧急的日志信息，**有缓冲**（buffered），需触发刷新才会输出。
- 更多细节可参考 GeeksForGeeks 网站的相关教程。
最后，记住用\n！

## 文件输出流（Output File Streams）

### 文件输出流的定义与类型

- 类型：`std::ofstream`（继承自`std::ostream`）。
- 作用：向文件中写入数据。
他属于第二类，输出流！与上面说到的std::cout，cerr，clog属于同一类！

### 核心成员函数

|函数名|作用|
|---|---|
|`is_open()`|判断文件是否成功打开|
|`open()`|打开指定文件（若未在构造函数中关联文件）|
|`close()`|关闭文件流（关闭后无法再写入数据）|
|`fail()`|判断文件操作是否失败|

### 示例：文件输出流的使用
```cpp
int main() {
    // 1. 构造文件输出流并关联文件“hello.txt”（若文件不存在则创建，存在则覆盖）
    std::ofstream ofs("hello.txt"); 
    
    // 2. 检查文件是否成功打开
    if (ofs.is_open()) {
        // 向文件中写入内容（“Hello CS106L!” + 换行符）
        ofs << "Hello CS106L!" << '\n'; 
    }
    
    // 3. 关闭文件流
    ofs.close(); 
    // 关闭后写入会“静默失败”（无报错但数据不会写入文件）
    ofs << "this will not get written"; 
    
    // 4. 重新打开文件“hello.txt”（默认覆盖原有内容）
    ofs.open("hello.txt"); 
    // 重新打开后可正常写入
    ofs << "this will though! It's open again"; 
    
    return 0;
}
```
注意关闭掉文件流后就不可以写内容到里面了！
### 文件追加模式（避免覆盖）

若需在文件末尾追加内容（而非覆盖），可在`open()`时指定`std::ios::app`标志：
```cpp
int main() {
    std::ofstream ofs("hello.txt"); 
    if (ofs.is_open()) {
        ofs << "Hello CS106L!" << '\n'; 
    }
    ofs.close(); 
    
    // 以“追加模式”打开文件（内容写入文件末尾）
    ofs.open("hello.txt", std::ios::app); 
    // 此内容会追加在原有内容之后，而非覆盖
    ofs << "this will though! It's open again"; 
    
    return 0;
}
```

## 文件输入流（Input File Streams）
### 文件输入流的定义与类型

- 类型：`std::ifstream`（继承自`std::istream`）。
- 作用：从文件中读取数据。
他属于第一类，与std::cin属于一类！

### 示例：文件输入流的使用
```cpp
int inputFileStreamExample() {
    // 构造文件输入流并关联文件“append.txt”
    std::ifstream ifs("append.txt"); 
    
    // 检查文件是否成功打开
    if (ifs.is_open()) {
        std::string line; 
        // 读取文件的第一行数据
        std::getline(ifs, line); 
        // 输出读取到的内容
        std::cout << "Read from the file: " << line << '\n';
        
        // 读取文件的第二行数据（若文件有多行）
        std::string lineTwo; 
        std::getline(ifs, lineTwo); 
        std::cout << "Read from the file: " << lineTwo << '\n';
    }
    
    return 0;
}
```
### 关键特性

- 文件输入流与文件输出流是 “互补” 的：针对同一文件，输入流负责读取，输出流负责写入，两者配合可完成文件的读写操作。

但是关于文件流使用，还要一个可以同时输入输出使用的，他属于输入输出流。在：
![[Pasted image 20251019162315.png]]
这个就给大家自己去探索！

## 输入流（Input Streams）
这个是第一类！
### 输入流的定义与作用

- 类型：`std::istream`。
- 作用：从数据源（如控制台、文件）读取数据到程序中。
- 示例：从控制台读取数据（`std::cin`）。
- 主要运算符：`>>`（提取运算符，用于从流中读取数据）。

### std::cin 的缓冲机制

- `std::cin`是有缓冲的，即用户输入的数据会先存储在 “cin 缓冲区” 中，`>>`运算符从缓冲区中提取数据。
- 缓冲停止条件：缓冲区遇到空白字符（空格、`\n`、`\t`）时停止存储。
其实整个输入流都有类似的缓冲区，与输出流一样！
#### 示例 1：std::cin 的基本使用
```cpp
int main() {
    double pi;
    // 从缓冲区提取数据到pi（若缓冲区有数据，直接提取；若无，等待用户输入）
    std::cin >> pi; 
    // 输出pi的值
    std::cout << "pi is: " << pi << '\n'; 
    return 0;
}
```
- 若用户输入 “3.14”，缓冲区会存储 “3.14\n”，`>>`运算符提取 “3.14” 到`pi`，控制台输出 “pi is: 3.14”。

![[Pasted image 20251019162841.png]]就是这样！

### std::cin 的读取失败情况

当`>>`运算符遇到 “无法转换为目标类型” 的数据时，会导致读取失败，后续读取操作也会受影响。
#### 示例：读取失败演示
```cpp
int main() {
    double pi; 
    double tao;
    std::string name;
    
    // 预期读取顺序：name（字符串）→ pi（双精度浮点数）→ tao（双精度浮点数）
    std::cin >> name; 
    std::cin >> pi; 
    std::cin >> tao; 
    
    // 输出结果（若输入不符合类型，pi和tao可能为随机值）
    std::cout << "my name is: " << name << " tao is: " << tao << " pi is: " << pi << '\n';
    return 0;
}
```
运行前三行是这样的：
![[Pasted image 20251019163755.png]]
然后：我们先输入3.14，cin读到了缓存区中，并加入了\n，且给到了pi！
![[Pasted image 20251019163824.png]]
然后：我们输入fabio lbanez!想着把fabio lbanez给到name变量！
![[Pasted image 20251019164052.png]]
然而name却是Fabio！因为这中间有空格，然而这个空格使得>>操作符浏览缓冲区时，停止！
然后：我们想继续输入20，复制给tao!
但是他却读取到lbanez给tao！而整个的数值类型都对不上，直接报错！
这个时候怎么办！
### std::cin 与 getline () 的混用问题

- `std::cin >>`的特性：读取数据后，会将 “换行符`\n`” 留在缓冲区中。
- `getline()`的特性：会读取到`\n`为止，并消耗掉`\n`（即从缓冲区中删除`\n`）。
- 混用问题：若`std::cin >>`之后直接调用`getline()`，`getline()`会读取到缓冲区中残留的`\n`，导致读取到空字符串。
所以我们这样写：
```cpp
void cinGetlineBug() {
    double pi; 
    double tao;
    std::string name;
    
    // 1. 读取pi（假设用户输入“3.14\n”）
    std::cin >> pi; 
    // 2. getline()读取到缓冲区残留的“\n”，name为空字符串
    std::getline(std::cin, name); 
    // 3. 读取tao时，缓冲区中可能还有后续数据（如“Fabio\n”），但tao是double类型，读取失败
    std::cin >> tao; 
    
    std::cout << "my name is: " << name << " tao is: " << tao << " pi is: " << pi << '\n';
}
```
大家认为大功告成对不对，不对，还是报错！为什么：
![[Pasted image 20251019164659.png]]
如图，getline他会读取上一次残留的\n，这会使得他没有读到任何内容给name，name比上次还不如，直接连Fabio都不会有，还有类型报错！
大家会以后为什么之前也留下有\n，怎么就读取得到Fabio，这是因为>>会自动跳过读取到具体内容前的空格符！而getline没有！

正确答案是：
```cpp
void cinGetlineFix() {
    double pi; 
    double tao;
    std::string name;
    
    std::cin >> pi; 
    // 第一次getline()：消耗缓冲区中残留的“\n”（读取到空字符串，不使用）
    std::getline(std::cin, name); 
    // 第二次getline()：读取真正的name（如“Fabio”）
    std::getline(std::cin, name); 
    std::cin >> tao; 
    
    std::cout << "my name is: " << name << " tao is: " << tao << " pi is: " << pi << '\n';
}
```

OK，这就是全部的流！