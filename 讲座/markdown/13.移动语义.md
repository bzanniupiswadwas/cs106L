我们循序渐进的开始：

### 引入 Photo 类
头文件（.h）
```cpp
class Photo {
public:
    Photo(int width, int height);                  // 构造函数
    Photo(const Photo& other);                     // 拷贝构造函数
    Photo& operator=(const Photo& other);          // 拷贝赋值运算符
    ~Photo();                                      // 析构函数
private:
    int width;   // 图片宽度
    int height;  // 图片高度
    int* data;   // 指向像素数据的指针
};
```

### Photo 类的构造函数
这是成员初始化列表！
```cpp
Photo::Photo(int width, int height)
    : width(width)
    , height(height)
    , data(new int[width * height])  // 为像素数据分配内存
{}
```
功能：创建一个全新的图片对象，并为其像素数据分配内存！

### Photo 类的特殊成员函数：拷贝构造函数
```cpp
Photo::Photo(const Photo& other)
    : width(other.width)
    , height(other.height)
    , data(new int[width * height])  // 为新对象的像素数据分配内存
{
    // 将源对象的像素数据复制到新对象中
    std::copy(other.data, other.data + width * height, data);
}
```
功能：从已有的图片对象创建新对象，并复制源对象的像素数据！

### Photo 类的特殊成员函数：拷贝赋值运算符
```cpp
Photo& Photo::operator=(const Photo& other) {
    // 检查自赋值（避免自身赋值导致的错误）
    if (this == &other) return *this;

    delete[] data;  // 清理当前对象原有的像素数据

    // 复制源对象的属性和像素数据
    width = other.width;
    height = other.height;
    data = new int[width * height];  // 为新像素数据分配内存
    std::copy(other.data, other.data + width * height, data);
    return *this;
}
```

功能：用另一个图片对象的内容替换当前对象的内容，替换前会先清理当前对象的原有数据！

### Photo 类的特殊成员函数：析构函数
```cpp
Photo::~Photo()
{
    delete[] data;  // 释放图片对象的像素数据内存
}
```
功能：清理当前图片对象的像素数据，避免内存泄漏！
## 你来试一试

以下代码中，（A）和（B）处会调用哪些特殊成员函数？
```cpp
注明：Photo takePhoto();  // 返回Photo对象的函数

int main() {
    Photo selfie = takePhoto();     // （A）处
    Photo retake(0, 0);             // 创建一个初始宽高为0的Photo对象
    retake = takePhoto();           // （B）处
}
```
### 答案

- （A）处：拷贝构造函数 → 析构函数（注：实际可能因编译器优化省略，后续会讲解）
- （B）处：拷贝赋值运算符 → 析构函数

## 补充说明：返回值优化（RVO）

- 对于`Photo selfie = takePhoto();`这行代码
    - 实际上可能不会调用 “复制构造函数 + 析构函数”
    - 这是由名为 “返回值优化”（Return-Value Optimization，简称 RVO）的编译器优化导致的
- 本讲为了讲解原理，将假设该代码会调用上述两个函数
### 核心观点：函数的返回值是临时对象

对于`Photo selfie = takePhoto();`

- 函数返回的对象会在执行下一行代码前被销毁
- 编译器会在进入下一行代码前清理这个临时对象！
（这个大家应该都清楚无需多说！）
那么接下来看问题所在：
### 问题场景
```cpp
Photo selfie = takePhoto();  // 用takePhoto()的返回值初始化selfie
```
其中`takePhoto()`会返回一个 Photo 对象。

### 问题拆解 1：临时对象的创建

`takePhoto()`返回的 Photo 对象属性如下：

- width = 3840（宽度为 3840 像素）
- height = 2160（高度为 2160 像素）
- data = 0x1024c3bd（指向像素数据的内存地址）
### 问题拆解 2：复制构造函数的调用

执行`Photo selfie = takePhoto();`时：

- 会调用复制构造函数，创建`selfie`对象
- `selfie`对象的属性如下：
    - width = 3840
    - height = 2160
    - data = 0x133210f1（新分配的内存地址，用于存储复制的像素数据）
- 此时存在两个独立的 Photo 对象，各自拥有一份像素数据副本
### 问题拆解 3：临时对象的销毁

复制完成后，`takePhoto()`返回的临时对象会被销毁：

- 调用临时对象的析构函数，释放其`data`指向的内存（0x1024c3bd）
- 最终仅`selfie`对象保留，但过程中额外进行了一次数据复制和内存释放
如果能复用临时对象的内存，岂不是更好？

## 解决方案：移动语义

### 移动语义的核心思路
### 移动语义的核心思路

对于`Photo selfie = takePhoto();`：

- 不复制临时对象的像素数据，而是 “窃取” 其内存资源
- 让`selfie`的`data`指针直接指向临时对象的像素数据内存，而非重新分配内存

### 步骤 1：调用移动构造函数

执行`Photo selfie = takePhoto();`时：

- 调用**移动构造函数**，而非复制构造函数
- `selfie`对象的`data`直接指向临时对象的内存地址：
    - `selfie.data = 0x1024c3bd`（临时对象的`data`地址）
    - 无需新分配内存，也无需复制像素数据
### 步骤 2：避免临时对象销毁时释放内存

- 移动构造函数中，需将临时对象的`data`指针设为`nullptr`（空指针）
- 此时临时对象的属性变为：
    - width = 3840
    - height = 2160
    - data = 0x0（空指针）
### 步骤 3：临时对象的安全销毁

- 调用临时对象的析构函数时，会执行`delete[] data`
- 由于`data`是`nullptr`，`delete[] nullptr`不会产生任何操作（C++ 标准规定）
- 最终`selfie`对象完整拥有原临时对象的像素数据，且无任何额外复制操作

我们无需任何复制，就创建了一个新的 Photo 对象！💪

但…… 这种操作始终是安全的吗？

## 移动语义 vs 复制语义

### 场景 1：临时对象的移动

`takePhoto()`返回的是临时对象，因此可以安全地 “窃取” 其资源：
```cpp
Photo takePhoto();

int main() {
    // takePhoto()返回临时对象，使用移动语义
    Photo selfie = takePhoto(); 
}
```
### 场景 2：持久化对象的移动风险

假设`get_pixel`函数用于访问`data`指向的像素数据，以下代码是否安全？
```cpp
Photo takePhoto();

void foo(Photo whoAmI) {
    // 如果此处使用移动语义，会发生什么？
    Photo selfie = whoAmI; 
    // 访问whoAmI的像素数据
    whoAmI.get_pixel(21, 24); 
}
```

若`selfie`“窃取” 了`whoAmI`的`data`资源，`whoAmI.data`会变为`nullptr`
此时调用`whoAmI.get_pixel(21, 24)`，会导致对空指针的解引用（`use-after-move`错误）

### 核心区别：对象的持久性决定语义选择
| 代码示例                            | 语义选择 | 原因                                      |
| ------------------------------- | ---- | --------------------------------------- |
| `Photo selfie = pic;`（`pic`是变量） | 复制语义 | `pic`是持久化对象（可能后续还会使用），需保留其完整状态          |
| `Photo selfie = takePhoto();`   | 移动语义 | `takePhoto()`返回临时对象（后续不再使用），可安全 “窃取” 资源 |

在第三讲的时候我们说过左值与右值，但是当时大家对c++内存的一个分配情况不了解，也不明白类的具体内部机制，所以这里再说一遍，不过是结合类的知识来说！
## 左值与右值

### 左值与右值的核心作用

左值（lvalue）和右值（rvalue）是 C++ 中对 “对象临时性” 的通用抽象概念。

### 示例：识别左值与右值
```cpp
void foo(Photo pic) {
    // pic是左值（lvalue）
    Photo beReal = pic; 
    // takePhoto()的返回值是右值（rvalue）
    Photo insta = takePhoto();
}
```
### 核心区分：是否拥有确定内存地址
左值：拥有确定的内存地址，可以取地址
```cpp
void foo(Photo pic) {
    // 合法：pic是左值，可取地址
    Photo* p1 = &pic; 
}
```
右值：没有确定的内存地址，不可取地址
```cpp
void foo(Photo pic) {
    // 非法：takePhoto()返回右值，不可取地址
    Photo* p2 = &takePhoto(); 
}
```
### 赋值语句中的位置差异
左值可出现在赋值运算符（`=`）的左侧或右侧
```cpp
x = y;  // x和y都是左值，y在右侧
y = 5;  // y是左值，在左侧
```
右值只能出现在赋值运算符的右侧
```cpp
x = 5;  // 5是右值，在右侧（合法）
5 = y;  // 5是右值，在左侧（非法）
```

以下赋值语句的右侧操作数中，哪些是右值？提示：判断标准是 “是否拥有确定的内存地址”
```cpp
int         a = 4;          // 右侧4是？
int&        b = a;          // 右侧a是？
vector<int> c = {1, 2, 3};  // 右侧{1,2,3}是？
int         d = c[1];       // 右侧c[1]是？
int*        e = &c[2];      // 右侧&c[2]是？
size_t      f = c.size();   // 右侧c.size()是？
int         g = static_cast<int>(f);  // 右侧static_cast<int>(f)是？
```
### 答案

1. 4：右值（rvalue）
2. a：左值（lvalue）
3. {1,2,3}：右值（rvalue）
4. `c [1]`：左值（lvalue）
5. `&c [2]`：右值（rvalue）
6. c.size ()：右值（rvalue）
7. static_cast`<int>`(f)：右值（rvalue）

### 生命周期差异

- 左值的生命周期：持续到所在作用域结束（如变量`a`在`main`函数结束前都存在）
- 右值的生命周期：持续到当前语句结束（如`c.size()`的返回值在赋值给`f`后立即销毁）

### 本质差异

- 左值：持久化对象（Persistent Object）
- 右值：临时对象（Temporary Object）

### 补充说明：实际分类更复杂（暂无需深入）

C++ 标准中，值的分类实际如下（现阶段无需掌握）：
```plaintext
表达式（expression）
├─ 泛左值（glvalue）
│  ├─ 左值（lvalue）
│  └─ 将亡值（xvalue）
└─ 右值（rvalue）
   └─ 纯右值（prvalue）
```
现阶段无需关注此复杂分类

## 迈向移动语义：实际场景问题
### 场景 1：左值的不必要复制

如何避免左值对象的内存被不必要地复制？
```cpp
// 接收Photo对象的函数
void uploadToInsta(Photo pic);

int main() {
    // selfie是左值（持久化对象）
    Photo selfie = takePhoto(); 
    // 此处会复制selfie，造成不必要的开销
    uploadToInsta(selfie); 
}
```

### 场景 1 的解决方案：传左值引用

通过左值引用（`Type&`）传递参数，避免复制：
```cpp
// 接收Photo左值引用的函数
void uploadToInsta(Photo& pic);

int main() {
    Photo selfie = takePhoto(); 
    // 无复制：直接传递selfie的引用
    uploadToInsta(selfie); 
}
```

### 场景 2：右值的复制问题

如何避免右值对象的复制？若尝试传左值引用，会发生什么？
```cpp
// 接收左值引用的函数
void uploadToInsta(Photo& pic);

int main() {
    // 传递takePhoto()的返回值（右值），是否合法？
    uploadToInsta(takePhoto()); 
}
```
### 场景 2 的错误原因

编译器报错：`candidate function not viable: expects lvalue as 1st argument`（候选函数不可用：第一个参数需为左值）

- 左值引用（`Photo&`）只能接收左值，无法接收右值
- 如何解决右值的传递与复制问题？

## 解决方案：右值引用

### 左值引用与右值引用的对比
| 类型   | 语法       | 适用场景        |
| ---- | -------- | ----------- |
| 左值引用 | `Type&`  | 传递持久化对象（左值） |
| 右值引用 | `Type&&` | 传递临时对象（右值）  |
示例代码：
左值引用:
```cpp
void upload(Photo& pic);
int main() {
	Photo selfie = takePhoto();
	upload(selfie);
}
```

右值引用:
```cpp
void upload(Photo&& pic);
int main() {
	upload(takePhoto());
}
```
### 右值引用的核心优势

对于`Photo&& pic`（右值引用参数），我们可以随意操作：

- 因为它指向的是临时对象，后续不会被使用
- 可以安全地 “窃取” 其资源（如`data`指向的内存），无需担心后续访问冲突
## 重要知识点总结

### 1. 左值引用（Type&）

- 指向持久化对象，函数执行结束后需保证对象处于有效状态
- 不可指向临时对象（右值）

### 2. 右值引用（Type&&）

- 指向临时对象，可 “窃取” 其资源（如内存、文件句柄等）
- 对象可能会处于无效状态（如`data`设为`nullptr`），但无需担心 —— 因为它是临时对象，后续不会被使用。
所以右值引用像是一个给右值延长寿命的工具！一般的左值是会一直等到整个程序文件结束后才会被释放，但是右值他是在当前语句结束后就立马被删除（可能他的内存释放确实是在整个程序文件结束后，但是内存地址是当前语句结束后就立马被删除），有了右值引用后会，会保存地址，由于右值不想是左值，会有许多的绑定，所以我们就可以安全的窃取他的内存！

### 核心观点：通过重载区分左值与右值引用

- 对参数分别重载左值引用（`Type&`）和右值引用（`Type&&`）版本
- 编译器会根据实参的类型（左值 / 右值）自动选择对应的重载函数
### 示例：通过重载实现差异化处理
```cpp
// 左值引用版本：处理左值实参
void upload(Photo& pic);
// 右值引用版本：处理右值实参
void upload(Photo&& pic);

int main() {
    Photo selfie = takePhoto();
    upload(selfie);          // 实参是左值，调用upload(Photo&)
    upload(takePhoto());     // 实参是右值，调用upload(Photo&&)
}
```
- 编译器会根据实参的 “左值 / 右值属性”，自动选择匹配的重载函数

## 移动语义：实战实现

### 我们的目标

- 对于`Photo selfie = pic;`（`pic`是左值）：使用复制语义，保留`pic`的完整状态
- 对于`Photo selfie = takePhoto();`（返回右值）：使用移动语义，“窃取” 临时对象的资源
- 通过重载特殊成员函数实现上述逻辑：左值用复制构造 / 赋值，右值用移动构造 / 赋值

### 1. 重载拷贝构造函数与移动构造函数
#### 拷贝构造函数（处理左值）
```cpp
Photo::Photo(const Photo& other) 
    : width(other.width)
    , height(other.height) 
    , data(new int[width * height])  // 新分配内存
{
    // 复制像素数据
    std::copy(
        other.data, 
        other.data + width * height, 
        data
    );
}
```
这个和开始给的那个是一样的没有变！

#### 移动构造函数（处理右值）
```cpp
Photo::Photo(Photo&& other) 
    : width(other.width)
    , height(other.height) 
{
    // “窃取”other的资源（other是临时对象）
    data = other.data;
    // 将other的data设为nullptr，避免析构时重复释放
    other.data = nullptr;
}
```

### 2. 重载拷贝赋值运算符与移动赋值运算符
#### 拷贝赋值运算符（处理左值）
```cpp
Photo& Photo::operator=(const Photo& other) {
    // 检查自赋值
    if (this == &other) return *this;

    // 清理当前对象的原有资源
    delete[] data;

    // 复制属性和数据
    width = other.width;
    height = other.height;
    data = new int[width * height];
    std::copy(other.data, other.data + width * height, data);

    return *this;
}
```
也是和之前一样的！

#### 移动赋值运算符（处理右值）
```cpp
Photo& Photo::operator=(Photo&& other) 
{
    // 检查自赋值（虽然后续操作对临时对象影响小，但仍需规范）
    if (this == &other) return *this;

    // 清理当前对象的原有资源
    delete[] data;

    // “窃取”other的资源
    width = other.width;
    height = other.height;
    data = other.data;

    // 将other的data设为nullptr，避免析构时重复释放
    other.data = nullptr;

    return *this;
}
```

上面的代码在106l.vercel.app/movesem中！大家去运行看看！

诶，就这样大家无意间就把上一讲没讲到的两个特殊成员函数给学会了！
### 新增的两个特殊成员函数

- 移动构造函数：`Type::Type(Type&& other);`
- 移动赋值运算符：`Type& Type::operator=(Type&& other);`

但是还是要补充一些东西！

## std::move 与特殊成员函数
### 场景：强制启用移动语义

- 通常情况下，编译器会自动判断使用拷贝语义（左值）还是移动语义（右值）
- 但有时我们明确知道某个左值后续不会再使用，能否强制对其使用移动语义以提升效率？
### 示例：左值的不必要复制

以下代码中，第 3 行对`elems[i-1]`的复制是不必要的 —— 因为后续不再使用`elems[i-1]`的原有值：
```cpp
1 void PhotoCollection::insert(const Photo& pic, int pos) {
2     for (int i = size(); i > pos; i--) 
3         elems[i] = elems[i – 1];  // 复制elems[i-1]到elems[i]，后续不再用elems[i-1]
4     elems[pos] = pic;
5 }
```
### 解决方案：用 std::move 强制移动

通过`std::move`将左值`elems[i-1]`强制转换为右值，触发移动赋值运算符：
```cpp
1 void PhotoCollection::insert(const Photo& pic, int pos) {
2     for (int i = size(); i > pos; i--) 
3         // 强制移动elems[i-1]到elems[i]，无复制开销
4         elems[i] = std::move(elems[i – 1]); 
5     elems[pos] = pic;
6 }
```
### 使用 std::move 的风险

若对左值使用`std::move`后，后续仍尝试访问该左值，会发生什么？
```cpp
Photo takePhoto();

void foo(Photo whoAmI) 
    // 强制移动whoAmI（左值）到selfie
    Photo selfie = std::move(whoAmI); 
    // 后续尝试访问whoAmI的像素数据
    whoAmI.get_pixel(21, 24); 
}
```
风险：`whoAmI`的`data`已被 “窃取”（设为`nullptr`），此时访问会导致空指针解引用错误！

- 移动后，原左值会处于 “有效但未定义” 的状态，后续不应再使用（除非重新赋值）
### 实战：用 std::move 实现移动操作

在移动构造 / 赋值函数中，若成员变量是 STL 容器（如`std::vector`），应使用`std::move`强制移动其资源：
#### 错误示例：未使用 std::move，导致容器复制
```cpp
class Photo {
public:
    Photo::Photo(Photo&& other) {
        // 错误：other.keywords是左值，此处会调用vector的复制构造函数
        keywords = other.keywords;
    }

private:
    std::vector<string> keywords;  // 存储图片关键词的容器
};
```
#### 正确示例：用 std::move 强制容器移动
```cpp
class Photo {
public:
    Photo::Photo(Photo&& other) {
        // 正确：用std::move将other.keywords转为右值，调用vector的移动构造函数
        keywords = std::move(other.keywords);
    }

private:
    std::vector<string> keywords;
};
```
### std::move 的本质

1. **无特殊操作**：`std::move`本身不移动任何数据，仅将左值强制转换为右值引用（`Type&&`）
    
    - 本质是一个类型转换函数，类似`static_cast<typename std::remove_reference<T>::type&&>(t)`
2. **风险提示**：与`const_cast`类似，`std::move`是 “主动选择” 可能存在风险的行为
    
    - 若移动后仍访问原左值，可能导致未定义行为（如空指针访问）
3. **使用原则**：尽量避免显式使用`std::move`，仅在以下场景使用：
    
    - 明确知道原左值后续不再使用
    - 性能优化需求迫切（如高频调用的函数、大数据量场景）
## 特殊成员函数汇总

现在我们有了五个特殊成员函数：

1. 复制构造函数：`Type::Type(const Type& other);`
2. 复制赋值运算符：`Type& Type::operator=(const Type& other);`
3. 移动构造函数：`Type::Type(Type&& other);`
4. 移动赋值运算符：`Type& Type::operator=(Type&& other);`
5. 析构函数：`~Type::Type();`

这么多特殊成员函数……😩我需要全部定义吗？
我需要全部定义吗？

## 无需全部定义！零规则、三规则、五规则

### 1. 零规则（Rule of Zero）

#### 适用场景

- 若类**不管理内存或其他外部资源**（如文件句柄、网络连接），无需手动定义任何特殊成员函数
- 编译器自动生成的特殊成员函数已足够，且能正确调用成员变量的特殊成员函数
```cpp
// Post类不管理外部资源，成员变量（Photo、std::string）会自行管理资源
struct Post {
    Photo photo;       // Photo类已实现完整的特殊成员函数
    std::string user;  // std::string自带完善的特殊成员函数
};
```
- Post 类无需手动定义复制 / 移动构造、赋值运算符或析构函数
- 编译器自动生成的版本会调用`photo`和`user`的对应特殊成员函数，行为正确
### 2. 三规则（Rule of Three）

#### 适用场景

- 若类**管理外部资源**（如`Photo`类管理`data`指向的内存），必须手动定义以下三个特殊成员函数：
    1. 析构函数：释放外部资源，避免内存泄漏
    2. 复制构造函数：深复制外部资源，避免多个对象共享同一资源
    3. 复制赋值运算符：先释放当前资源，再深复制源对象的资源

#### 原因

- 若不定义这三个函数，编译器自动生成的版本会执行 “浅复制”（仅复制指针地址，不复制资源内容）
- 导致多个对象共享同一资源，析构时会重复释放（双重释放错误），或访问已释放资源（悬垂指针错误）
#### 三规则核心：三者缺一不可

若需要以下任意一个函数，就必须同时定义另外两个：

- 析构函数
- 复制构造函数
- 复制赋值运算符

### 3. 五规则（Rule of Five）

#### 适用场景

- 若类已根据 “三规则” 定义了析构函数、复制构造函数和复制赋值运算符
- 建议额外定义**移动构造函数**和**移动赋值运算符**（非强制，但推荐）

#### 原因

- 若不定义移动语义相关函数，编译器不会自动生成（C++11 及以后标准）
- 此时对类的右值对象仍会使用复制语义，导致不必要的资源复制，影响性能

#### 五规则核心：推荐完整定义

若需要 “三规则” 中的任意一个函数，建议同时定义以下五个：

- 析构函数
- 复制构造函数
- 复制赋值运算符
- 移动构造函数（可选，但推荐）
- 移动赋值运算符（可选，但推荐）

到此，所以特殊成员变量学习完毕！

