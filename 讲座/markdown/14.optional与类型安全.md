## 类型安全（Type Safety）
指一种语言防止类型错误的能力。
### Python（动态类型语言，类比自然语言）与 C++（静态类型语言）对比
```python
def div_3(x):  
	return x / 3  
div_3(“hello”)
```
运行时崩溃（CRASH），无法对字符串执行除法运算

```c++
int div_3(int x){  
	return x / 3;  
}  
div_3(“hello”)
```
编译错误（Compile error），代码根本不会运行

类型安全也指一种语言保证程序行为可预测的程度。

## 代码案例分析：这段代码的功能是什么？
```cpp
void removeOddsFromEnd(vector<int>& vec) {
    while (vec.back() % 2 == 1) {
        vec.pop_back();
    }
}
```
其中：
- `vector::back()`：返回向量（vector）中最后一个元素的引用。
- `vector::pop_back()`：与`vector::push_back(elem)`功能相反，用于移除向量的最后一个元素。

这段代码就是为了移除向量末尾连续的奇数！

但是：
### 有人发现问题了吗？
如果向量`vec`是空的（`vec = {}`），会发生什么？
首先我们来看看官方文档对back()函数的说明！
```cpp
std::vector<T, Allocator>::back
reference back();          // C++20 之前
constexpr reference back();// C++20 及之后
const_reference back() const;          // C++20 之前
constexpr const_reference back() const;// C++20 及之后
```
- 功能：返回容器中最后一个元素的引用。
- 注意：对空容器调用`back()`会导致**未定义行为（Undefined Behavior）**。
这就是官方文档的说明！
未定义行为（Undefined Behavior）：指函数可能崩溃、返回垃圾值，或意外返回某个有效数值（行为完全不可预测）。

### 再看这段代码
```cpp
void removeOddsFromEnd(vector<int>& vec) {
    while (vec.back() % 2 == 1) {
        vec.pop_back();
    }
}
```
- 我们无法保证这个函数的行为是可预测的！比如上面提到的vec是空的怎么办！

### 解决方案一
```cpp
void removeOddsFromEnd(vector<int>& vec) {
    while (!vec.empty() && vec.back() % 2 == 1) {
        vec.pop_back();
    }
}
```
- **核心思路**：程序员有责任确保 “向量非空” 这一前置条件；若不满足该条件，仍会出现未定义行为。

## 问题本质：向量可能没有 “最后一个元素”

如何让`vec.back()`在 “有最后一个元素” 和 “没有最后一个元素” 两种情况下，都具备确定的行为？

### 问题代码（原始 back () 实现逻辑）
```cpp
valueType& vector<valueType>::back() {
    return *(begin() + size() - 1);
}
```
- 未验证指针是否指向有效内存就解引用，会导致未定义行为。
### 改进方案（增加空容器检查）
```cpp
valueType& vector<valueType>::back() {
    if (empty()) throw std::out_of_range;
    return *(begin() + size() - 1);
}
```
- 此时调用`back()`时，要么可靠地抛出错误并终止程序，要么返回最后一个元素（行为可预测）。
### 进一步思考

确定的行为固然好，但我们能做得更好吗？当调用`vec.back()`时，如何让它主动 “提醒” 我们 “向量可能为空” 这一情况？

### 重新理解类型安全

类型安全：函数签名（function signature）保证函数行为可预测的程度。
### 回到问题：原始 back () 的函数签名问题
```cpp
valueType& vector<valueType>::back() {
    return *(begin() + size() - 1);
}
```
- `back()`承诺返回一个`valueType`类型的值，但实际上，向量可能根本不存在 “最后一个元素”—— 函数签名做出了 “虚假承诺”。
## 初步解决方案：使用 std::pair
```cpp
std::pair<bool, valueType&> vector<valueType>::back() {
    if (empty()) {
        return {false, valueType()}; // 空容器时，返回{false, 默认构造的valueType}
    }
    return {true, *(begin() + size() - 1)}; // 非空时，返回{true, 最后一个元素}
}
```
- 优势：`back()`的签名现在明确告知 “可能存在或不存在最后一个元素”。
- 注意：`valueType()`表示调用`valueType`的默认构造函数。
### std::pair 方案的问题

1. `valueType`可能没有默认构造函数（无法构造`valueType()`）。
2. 即使`valueType`有默认构造函数，调用构造函数也会产生额外的性能开销。
3. 行为仍不可预测：例如，若`int`的默认构造函数返回奇数，以下代码逻辑会出错：
```cpp
void removeOddsFromEnd(vector<int>& vec) {
    while (vec.back().second % 2 == 1) {
        vec.pop_back();
    }
}
```
4. 最重要的是类型的构造函数本质上是一个临时对象，上一讲我们说过，左值引用无法绑定临时对象！
### 核心疑问

`back()`在空容器时究竟该返回什么？
```cpp
??? vector<valueType>::back() {
    if (empty()) {
        return ??; // 空容器时的返回值该如何定义？
    }
    return *(begin() + size() - 1);
}
```

## 引入 std::optional
### 什么是 std::optional`<T>`？

- `std::optional`是一个模板类，它要么包含一个`T`类型的值，要么不包含任何值（用`nullopt`表示）。
- **`std::optional<T>`**：这个“盒子”有两种状态：
    1. **有东西**：盒子里装着一个 `T` 类型的值。
    2. **空的**：盒子里什么都没有。
- **注意**：此处需用`nullopt`，而非`nullptr`—— 二者是不同的概念！
    - `nullptr`：可转换为任意指针类型的对象。这是“空指针”的专用表示。例如：`int* ptr = nullptr;` 表示 `ptr` 这个指针不指向任何地方。
    - `nullopt`：可转换为任意`optional`类型的对象。
### std::optional`<T>` 示例代码
```cpp
void main() {
    std::optional<int> num1 = {};  // num1 不包含任何值（空）
    num1 = 1;                      // 现在 num1 包含值 1
    num1 = std::nullopt;           // 现在 num1 又变为空（不包含值）
    // 注：{} 和 std::nullopt 在此场景下可互换使用
}
```

### 用 std::optional 改进 vector::back ()
```cpp
std::optional<valueType> vector<valueType>::back() {
    if (empty()) {
        return {}; // 空容器时，返回空的 optional
    }
    return *(begin() + size() - 1); // 非空时，返回包含最后一个元素的 optional
}
```
### 改进后 back () 的使用问题

原始代码无法直接运行，因为不能对`optional`类型执行算术运算 —— 必须先获取其中包含的值（若存在）：
```cpp
// 错误示例（无法运行）
void removeOddsFromEnd(vector<int>& vec) {
    while (vec.back() % 2 == 1) { // 错误：optional 类型不能直接参与取模运算
        vec.pop_back();
    }
}
```

```cpp
// 正确思路：先提取 optional 中的值
void removeOddsFromEnd(vector<int>& vec) {
    // 需先判断是否有值，再提取值进行运算
    while (/* 先判断 vec.back() 有值 */ && /* 再对提取的值做判断 */) {
        vec.pop_back();
    }
}
```
## std::optional 的接口（成员函数）

`std::optional`类型主要包含以下成员函数：

1. `.value()` 方法：
    - 功能：返回包含的值；若`optional`为空，则抛出`bad_optional_access`异常。
2. `.value_or(valueType val)` 方法：
    - 功能：返回包含的值；若`optional`为空，则返回默认值`val`。
3. `.has_value()` 方法：
    - 功能：若包含值，返回`true`；否则返回`false`。

## 重新优化 removeOddsFromEnd () 代码
### 优化方案 1：使用 .value ()（带异常处理）
```cpp
void removeOddsFromEnd(vector<int>& vec) {
    while (vec.back().value() % 2 == 1) {
        vec.pop_back();
    }
}
```
- 效果：若对空容器调用`back()`，会可靠地抛出`bad_optional_access`异常（行为可预测）。
### 优化方案 2：使用 .has_value ()（避免异常）
```cpp
void removeOddsFromEnd(vector<int>& vec) {
    while (vec.back().has_value() && vec.back().value() % 2 == 1) {
        vec.pop_back();
    }
}
```
- 效果：不会抛出异常，但代码略显繁琐（需多次调用成员函数）。
### 优化方案 3：利用 nullopt 的 “假值” 特性
```cpp
void removeOddsFromEnd(vector<int>& vec) {
    while (vec.back() && vec.back().value() % 2 == 1) {
        vec.pop_back();
    }
}
```
- 原理：`nullopt`在布尔语境下视为 “假（false）”，非空`optional`视为 “真（true）”，因此可直接用`vec.back()`判断是否有值。
- 优势：代码更简洁。

### 优化方案 4：使用 .value_or ()（不推荐，仅作示例）
```cpp
void removeOddsFromEnd(vector<int>& vec) {
    while (vec.back().value_or(2) % 2 == 1) {
        vec.pop_back();
    }
}
```
- 原理：空容器时返回默认值`2`（偶数），此时循环条件不成立，避免错误。
- 提示：这种写法虽能运行，但属于 “取巧”，不推荐在实际开发中使用！

## 回顾：std::vector::back () 的核心问题
为何对空容器调用`back()`的风险极高，却仍容易误写这样的代码？

- 因为函数签名做出了 “虚假承诺”：
```cpp
valueType& vector<valueType>::back()
```
- 签名承诺 “一定返回`valueType`类型的值”，但实际上向量可能没有 “最后一个元素”。

## 其他问题代码：vector::operator [] 的风险
```cpp
int thisFunctionSucks(vector<int>& vec) {
    return vec[0]; // 若 vec 为空，会导致未定义行为！
}
```
### 为何不能用 std::optional<T&> 改进？

- C++ 不支持`std::optional<valueType&>`（即 “包含引用的 optional”）。
- 原因：引用必须指向有效对象，而`optional`无法保证这一点（空`optional`对应的引用无有效指向）。
### 替代方案：使用 vector::at ()

- `vector::at()`会检查索引有效性，若索引越界则抛出`std::out_of_range`异常：
```cpp
valueType& vector<valueType>::operator[](size_t index) {
    return *(begin() + index); // 无越界检查，可能导致未定义行为
}

valueType& vector<valueType>::at(size_t index) {
    if (index >= size()) throw std::out_of_range; // 有越界检查
    return *(begin() + index);
}
```
- 疑问：为何 C++ 同时提供`operator[]`和`at()`？—— 前者追求性能（无检查），后者追求安全（有检查），由程序员根据场景选择。

## 使用 std::optional 作为返回值的优缺点

### 优点（Pros）

1. 函数签名能更准确地表达 “契约”（明确告知 “可能无返回值”）。
2. 类的成员函数调用具有可预测、可使用的行为（避免未定义行为）。

### 缺点（Cons）

1. 需频繁使用`.value()`等方法提取值，代码略显繁琐。
2. （C++ 中）仍可能因误用导致`bad_optional_access`异常。
3. （C++ 中）`optional`本身也可能引发未定义行为（例如直接解引用空`optional`，与`.value()`无检查版本效果一致）。
4. 很多场景下需要`std::optional<T&>`，但 C++ 不支持。

## 为何仍需使用 std::optional？

### std::optional 的高级接口（函数式编程支持）

`std::optional`还提供了以下成员函数，支持更优雅的 “链式调用”，避免嵌套判断：

1. `.and_then(function f)`：
    - 功能：若`optional`包含值，则调用函数`f`（`f`的返回值必须是`optional`类型），并返回`f`的结果；若`optional`为空，则返回`nullopt`。
2. `.transform(function f)`：
    - 功能：若`optional`包含值，则调用函数`f`（`f`的返回值为任意类型），并返回包含该结果的`optional`；若`optional`为空，则返回`nullopt`。
    - 注：文档中 “`f`必须返回`optional<valueType>`” 表述有误，正确逻辑为 “`f`返回任意类型，`transform`会将其包装为`optional`”。
3. `.or_else(function f)`：
    - 功能：若`optional`包含值，则返回该值；若为空，则调用函数`f`（`f`的返回值必须是`optional`类型），并返回`f`的结果。
### 这些接口的意义

- 它们遵循 “单子模式（Monadic Pattern）”—— 一种软件设计模式，用于组合函数片段，并将函数返回值包装在带有额外计算逻辑的类型中。
- 核心作用：可链式尝试调用多个函数，要么返回计算结果，要么返回默认值（避免大量`if-else`判断）。
### 用 .and_then () 重新优化代码
```cpp
void removeOddsFromEnd(vector<int>& vec) {
    // 定义lambda函数：判断optional<int>中的值是否为奇数
    auto isOdd = [](optional<int> num) {
        if (num) {
            return num.value() % 2 == 1; // 有值时，返回是否为奇数
        } else {
            return std::nullopt; // 空时，返回nullopt
        }
    };
    // 链式调用：若back()有值且为奇数，则执行pop_back()
    while (vec.back().and_then(isOdd)) {
        vec.pop_back();
    }
}
```
- 免责声明：`std::vector::back()`实际上并不返回`optional`类型，且未来可能也不会（受 C++ 设计哲学影响）。所以这里知识为了教学目的，了解.and_then ()怎么用即可，运行这段代码是错误的！

## 回顾 C++ 的设计哲学

1. 仅在能解决实际问题时才添加新特性。
2. 允许程序员自由选择编程风格。
3. 模块化（Compartmentalization）是核心。
4. 若程序员需要，应允许其获得完全控制权。
5. 除非万不得已，否则不牺牲性能。
6. 尽可能在编译时（而非运行时）保证安全性。

## 广泛使用 optional 单子模式的语言

1. **Rust**：系统级语言，保证内存安全和线程安全。
2. **Swift**：苹果公司推出的语言，专为应用开发设计。
3. **JavaScript**：广泛使用的脚本语言（ES2020 引入`Optional Chaining`等相关特性）。

## 总结：类型安全与 std::optional

1. 借助严格的类型系统，可以保证程序行为的可预测性。
2. `std::optional`是实现这一目标的工具：它支持 “返回值或空” 两种状态，核心接口包括`.has_value()`、`.value_or()`、`.value()`。
3. 由于`std::optional`会增加代码繁琐度并可能牺牲性能，C++ 标准库（STL）的大多数数据结构并未使用它。
4. 但许多其他语言（如 Rust、Swift）广泛使用`optional`。
5. 实际开发建议：除了在类中使用`std::optional`，也可在应用代码中根据场景合理使用 —— 这是非常推荐的做法！

## 最终寄语

“类型良好的程序不会出错。”—— 罗伯特・米尔纳（Robert Milner，计算机科学领域重要学者）

