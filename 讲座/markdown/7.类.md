## 为什么需要类？

- C 语言中没有 “对象” 的概念
- 无法将数据与操作这些数据的函数封装在一起
- 不支持面向对象编程（OOP）设计模式
## 什么是面向对象编程？

- 面向对象编程以 “对象” 为核心，重点在于类的设计与实现。
- 类是用户自定义的类型，可被声明为对象。

## 小惊喜！

标准模板库（STL）中定义的容器（Containers）本质就是类！

## 结构体（struct）与类（class）的对比

> 类包含一系列不同类型的对象、一组操作这些对象的函数，以及对这些对象和函数的访问限制；结构体则是没有访问限制的类。
> 
> —— 比雅尼・斯特劳斯特鲁普，《C++ 程序设计语言 —— 参考手册》，94.4 派生类型

```cpp
struct StanfordID {
    std::string name;    // 这些是字段（fields）
    std::string sunet;
    int idNumber;
};

StanfordID s;
s.name = "Fabio Ibanez";
s.sunet = "fabioi";
s.idNumber = 01243425;
```
结构体中，这些变量或者说成员都是共有的，没有任何的限制，任何成员都可以访问以及修改！

## 类的基本结构

你可能已经猜到了，类的结构如下：
```cpp
class ClassName {
private:
    // 私有成员（仅类内部可访问）
public:
    // 公有成员（外部可访问）
};
```

![[Pasted image 20251022205238.png]]
## 类的访问控制

类包含公有（public）和私有（private）两个部分：

- 用户可访问公有部分的成员
- 用户被限制访问私有部分的成员

## 基于结构体创建 StanfordID 类

回顾之前讲过的结构体：
```cpp
struct StanfordID {
    string name;    // 这些称为字段（fields）
    string sunet;
    int idNumber;   // 每个字段都有名称和类型
};

StanfordID id;      // 用“.”访问字段
id.name = "Jacob Roberts-Baca";
id.sunet = "jtrb";
id.idNumber = 6504417;
```

## 头文件（.h）与源文件（.cpp）的对比

| 对比维度 | 头文件（.h）                | 源文件（.cpp）                      |
| ---- | ---------------------- | ------------------------------ |
| 用途   | 定义接口                   | 实现类的函数                         |
| 包含内容 | 函数原型、类声明、类型定义、宏定义、常量   | 函数实现、可执行代码                     |
| 访问方式 | 可在多个源文件间共享             | 编译后生成目标文件（.o/.obj）             |
| 示例   | `void someFunction();` | `void someFunction() { ... };` |
头文件我们之前就讲过，其实他就是一个声明的文件，这与c++的设计理念紧密相关！

## 类的设计要素

- 构造函数（Constructor）
- 私有成员函数 / 变量（Private member functions/variables）
- 公有成员函数（用户接口，Public member functions）
- 析构函数（Destructor）

先说说构造函数
## 构造函数

构造函数用于初始化新创建对象的状态。
### StanfordID 类的构造需求

以`StanfordID`类为例，对象初始化需要哪些信息？

- `s.name = "Fabio Ibanez";`（姓名）
- `s.sunet = "fabioi";`（斯坦福网络标识）
- `s.idNumber = 01243425;`（ID 号）
## 构造函数的头文件声明（.h）或者说是类的头文件声明
```cpp
class StanfordID {
private:
    // 私有成员：姓名、SUNET标识、ID号
    std::string name;
    std::string sunet;
    int idNumber;
public:
    // 构造函数：用于初始化学生信息
    StanfordID(std::string name, std::string sunet, int idNumber);
};
```
注意这是头文件！

## 构造函数的语法规则

构造函数的名称必须与类名完全一致，无需指定返回值类型。
```cpp
class StanfordID {
private:
    std::string name;
    std::string sunet;
    int idNumber;
public:
    // 构造函数：名称与类名相同
    StanfordID(std::string name, std::string sunet, int idNumber);
    
    // 成员函数：获取姓名、SUNET标识、ID号
    std::string getName();
    std::string getSunet();
    int getID();
};
```

接下来是源文件
```cpp
#include "StanfordID.h"
#include <string>

// 构造函数实现：类名::构造函数名
StanfordID::StanfordID(std::string name, std::string sunet, int idNumber) {
    name = name;
    sunet = sunet;
    idNumber = idNumber;
}
```
注意：需使用命名空间（如`std::`）来指定标准库中的类型。

## 带参数的构造函数（源文件实现，.cpp）
```cpp
#include "StanfordID.h"
#include <string>

StanfordID::StanfordID(std::string name, std::string sunet, int idNumber) {
    name = name;
    sunet = sunet;
    // 可添加值校验逻辑，确保ID号为正数
    if (idNumber > 0) {
        idNumber = idNumber;
    }
}
```
现在，我们可以对初始化或修改的成员值进行合法性校验了！

## 构造函数的常见问题
```cpp
#include "StanfordID.h"
#include <string>

StanfordID::StanfordID(std::string name, std::string sunet, int idNumber) {
    name = name;        // 这里有问题吗？
    sunet = sunet;
    if (idNumber > 0) {
        idNumber = idNumber;
    }
}
```
参数名与成员变量名相同，会导致 “命名冲突”，无法正确赋值。就是成员变量也是name，参数名也是，这会产生歧义！怎么解决呢，要不然就加上StanfordID.name。其实真是可以的，但是为了简便：
## 使用 this 关键字解决命名冲突（.cpp）
实际上呢，this是一个指针！
```cpp
#include "StanfordID.h"
#include <string>

StanfordID::StanfordID(std::string name, std::string sunet, int idNumber) {
    this->name = name;      // this指向当前对象，明确指定成员变量
    this->sunet = sunet;
    this->idNumber = idNumber;
}
```

## 列表初始化构造函数（C++11）
```cpp
#include "StanfordID.h"
#include <string>

// 列表初始化构造函数（更高效的初始化方式）
StanfordID::StanfordID(std::string name, std::string sunet, int idNumber)
    : name{name}, sunet{sunet}, idNumber{idNumber} {
    // 构造函数体（若需额外逻辑可在此添加）
};
```
这与上面那段代码有什么不同呢，重点在于上面的是先搞出一个空的变量，然后再赋值，但是下面的是直接赋值，没有中间过程！举个例子，一个学生证，上面的是先打印出空白的学生证，然后发给学生，学生再填写姓名学号等，但是下面的在打印的时候就把姓名学号等一起打印出来了！性能上是否有提升我不太清楚，但是确实是让代码简洁了！

## 默认构造函数
```cpp
#include "StanfordID.h"
#include <string>

// 默认构造函数：无参数，使用默认值初始化
StanfordID::StanfordID() {
    name = "John Appleseed";
    sunet = "jappleseed";
    idNumber = 00000001;
}
```
当调用构造函数时不传入参数，会使用默认构造函数初始化对象。

## 构造函数重载
```cpp
#include "StanfordID.h"
#include <string>

// 默认构造函数（无参数）
StanfordID::StanfordID() {
    name = "John Appleseed";
    sunet = "jappleseed";
    idNumber = 00000001;
}

// 带参数的构造函数（有参数）
StanfordID::StanfordID(std::string name, std::string sunet, int idNumber) {
    this->name = name;
    this->sunet = sunet;
    this->idNumber = idNumber;
}
```
编译器会根据传入的参数类型和数量，自动选择对应的构造函数。
一般都会写这么两个构造函数！与python不一样，如果只有下面那个，然后构造时没有传入参数，会直接报错！

## 完整的对象实例化过程！
### 完善类的头文件定义（.h）
 `StanfordID.h`
```cpp
class StanfordID {
private:
    // 私有成员变量
    std::string name;
    std::string sunet;
    int idNumber;
public:
    // 构造函数：初始化学生信息
    StanfordID()
    StanfordID(std::string name, std::string sunet, int idNumber);
    
    // 成员函数：获取姓名、SUNET标识、ID号
    std::string getName();
    std::string getSunet();
    int getID();
};
```

### 完善类的实例化过程
 `StanfordID.cpp`
```cpp
#include "StanfordID.h"

// 默认构造函数
StanfordID::StanfordID() {
    name = "John Appleseed";
    sunet = "jappleseed";
    idNumber = 1; // 注意：00000001 在 C++ 中是八进制！建议写成 1
}

// 带参构造函数
StanfordID::StanfordID(std::string name, std::string sunet, int idNumber) 
	: name{name}, sunet{sunet}, idNumber{idNumber} {
}

std::string StanfordID::getName() {
    return name; // this-> 可以省略
}

std::string StanfordID::getSunet() {
    return sunet;
}

int StanfordID::getID() {
    return idNumber;
}
```

 `main.cpp`
 ```cpp
#include "StanfordID.h"
#include <iostream>

int main() {
    // 创建对象
    StanfordID student1; // 调用默认构造函数
    StanfordID student2("dingbawan", "dingba", 1234567);

    // 测试
    std::cout << student1.getName() << std::endl; // John Appleseed
    std::cout << student2.getSunet() << std::endl; // dingba

    return 0;
}
```
这就是完整的过程！


## 析构函数的实现（.cpp）
```cpp
#include "StanfordID.h"
#include <string>

// 析构函数：名称为“~类名”
StanfordID::~StanfordID() {
    // 在此处释放/销毁动态分配的数据（如new创建的对象）
}
```
## 析构函数的说明
在`StanfordID`类中，我们没有使用`new`关键字动态分配数据，因此析构函数体内无需额外操作。
## 析构函数的重要性
析构函数无需显式调用，当对象超出作用域时，会自动被调用，完成资源释放。

## 类的其他实用特性：类型别名

类型别名（Type aliasing）允许为现有类型创建同义标识符，简化代码。
```cpp
template <typename T>
class vector {
    using iterator = T*;  // 为T*创建别名iterator
    // 其他实现细节...
};
```

## 在类中使用类型别名（.h）
```cpp
class StanfordID {
private:
    // 为std::string创建别名String，简化代码
    using String = std::string;
    
    // 使用别名定义成员变量
    String name;
    String sunet;
    int idNumber;
public:
    // 构造函数：使用别名作为参数类型
    StanfordID(String name, String sunet, int idNumber);
    
    // 成员函数：使用别名作为返回值类型
    String getName();
    String getSunet();
    int getID();
};
```

## 示例：IntVector 类
```cpp
class IntVector {
public:
    using iterator = int*;  // 类型别名：迭代器
    
    // 构造函数与析构函数
    IntVector();
    ~IntVector();
    
    // 成员函数
    void push_back(const int& value);
    int& at(size_t index);
    int& operator[](size_t index);
    size_t size();
    bool empty();
    iterator begin();
    iterator end();

private:
    size_t _size;     // 实际存储的元素个数
    size_t _capacity; // 容量（可存储的最大元素个数）
    int* _data;       // 动态数组：存储int类型数据
    void resize();    // 私有成员函数：调整容量
};
```

反正析构函数就是这样，你显不显式声明析构函数都会被调用，区别是一个会调用C++定义的版本，一个是调用你自己写的版本！


# 继承（Inheritance）

## 继承的基本概念

继承允许从已有的 “基类”（Base Class）派生出 “子类”（Sub Class），子类可复用基类的代码并扩展新功能。
![[Pasted image 20251022214959.png]]
## 继承的应用场景

1. **动态多态（Dynamic Polymorphism）**：不同类型的对象可能需要相同的接口（如不同形状都需要计算面积）。
2. **可扩展性（Extensibility）**：通过创建子类，可在不修改基类的前提下扩展基类的功能。

## 继承的实际案例：形状类

假设我们设计一个 “形状” 基类，子类可包括圆形、矩形、三角形等。

### 形状类的共性

所有形状都需要计算 “面积”，但不同形状的面积计算方式不同。

### 形状类的问题

- 圆形需要 “半径”（radius）
- 矩形需要 “长”（width）和 “宽”（height）
- 三角形需要 “底”（base）和 “高”（height）
- 除了面积，形状还可能有其他共性（如周长）

## 基类的定义（.h）（基类就是父类）
```cpp
class Shape {
public:
    // 纯虚函数：基类中声明，子类中实现（动态多态的核心）
    virtual double area() const = 0;
};
```
纯虚函数（`virtual ... = 0`）：在基类中仅声明接口，无具体实现，必须在子类中重写。
后面加的const表示这个函数是无法修改成员变量的！
## 圆形子类的定义（.h）
`Shape.h`
```c++
// 基类Shape
calss Shape {
public:
	virtual double area() const = 0;
}
```
`Circle.h`
```cpp
#include "Shape.h"

class Circle : public Shape {
public:
    Circle(double radius);  // 声明构造函数
    double area() const override;   // 声明 area 函数

private:
    double _radius;
};
```
 `Circle.cpp`
 ```cpp
#include "Circle.h"

// 实现在 .cpp 文件中
Circle::Circle(double radius) : _radius{radius} {}

double Circle::area() const {
    return 3.14 * _radius * _radius;
}
```
其实也可以把上面的三个文件合并到一起：
```cpp
// 基类Shape
class Shape {
public:
    virtual double area() const = 0;
};

// 圆形子类：公有继承自Shape
class Circle : public Shape {
public:
    // 构造函数：列表初始化半径
    Circle(double radius) : _radius{radius} {};
    
    // 重写基类的area()函数，计算圆形面积
    double area() const {
        return 3.14 * _radius * _radius;
    }

private:
    double _radius;  // 圆形的私有成员：半径
};
```
不过这样不建议，但是初学者先这样写没有什么问题！下面我们都会用这种形式写，为了简便！

## 圆形子类的关键语法解析

1. **继承声明**：`class Circle : public Shape` 表示 Circle 是 Shape 的公有子类。
2. **纯虚函数重写**：`double area() const` 重写基类的纯虚函数，提供圆形面积的计算逻辑。
3. **列表初始化**：构造函数使用`_radius{radius}`直接初始化私有成员，比赋值初始化更高效。
4. **封装性**：`_radius`设为私有，确保只有类内部可修改，外部需通过接口访问。

再来个例子：
## 矩形子类的定义（.h）
```cpp
// 基类Shape
class Shape {
public:
    virtual double area() const = 0;
};

// 矩形子类：公有继承自Shape
class Rectangle : public Shape {
public:
    // 构造函数：列表初始化长和宽
    Rectangle(double height, double width) : _height{height}, _width{width} {};
    
    // 重写基类的area()函数，计算矩形面积
    double area() const {
        return _width * _height;
    }

private:
    double _width;   // 矩形的私有成员：长
    double _height;  // 矩形的私有成员：宽
};
```

## 三种继承方式的对比

| 继承方式   | 公有继承（public）                | 保护继承（protected）                | 私有继承（private）                |
| ------ | --------------------------- | ------------------------------ | ---------------------------- |
| 示例代码   | `class B: public A { ... }` | `class B: protected A { ... }` | `class B: private A { ... }` |
| 基类公有成员 | 子类中仍为公有（外部可访问）              | 子类中变为保护（仅子类内部可访问）              | 子类中变为私有（仅子类内部可访问）            |
| 基类保护成员 | 子类中仍为保护（仅子类内部可访问）           | 子类中仍为保护（仅子类内部可访问）              | 子类中变为私有（仅子类内部可访问）            |
| 基类私有成员 | 子类中不可访问（需通过基类公有 / 保护接口访问）   | 子类中不可访问（需通过基类公有 / 保护接口访问）      | 子类中不可访问（需通过基类公有 / 保护接口访问）    |
## 示例：Person 基类（.h）
```cpp
class Person {
protected:
    // 保护成员：子类可访问，外部不可访问
    std::string name;
public:
    // 构造函数：初始化姓名
    Person(const std::string& name) : name(name) {}
    
    // 公有成员函数：获取姓名
    std::string getName();
};
```

## 示例：Student 子类（.h）
```cpp
// Student子类：公有继承自Person
class Student : public Person {
protected:
    // 子类的保护成员
    std::string idNumber;  // 学号
    std::string advisor;   // 导师
    std::string major;     // 专业
    uint16_t year;         // 年级

public:
    // 构造函数：初始化姓名（继承自Person）及子类成员
    Student(const std::string& name, ...);
    
    // 公有成员函数：获取学号、专业、年级等
    std::string getIdNumber() const;
    std::string getMajor() const;
    uint16_t getYear() const;
    
    // 公有成员函数：修改年级、专业、导师
    void setYear(uint16_t year);
    void setMajor(const std::string& major);
    void setAdvisor(const std::string& advisor);
};
```
注：为简化代码，构造函数参数列表中省略了部分子类成员。

## 示例：Employee 子类（.h）
```cpp
// Employee子类：公有继承自Person
class Employee : public Person {
protected:
    double salary;  // 薪水（保护成员，子类可访问）

public:
    // 构造函数：初始化姓名（继承自Person）
    Employee(const std::string& name);
    
    // 纯虚函数：定义接口，子类需实现
    virtual std::string getRole() const = 0;    // 获取角色
    virtual double getSalary() const = 0;       // 获取薪水
    virtual void setSalary(double salary) = 0;  // 设置薪水
    
    // 虚析构函数：确保子类析构时能正确调用基类析构
    virtual ~Employee() = default;
};
```

## 示例：SectionLeader 子类（多继承，.h）
```cpp
// SectionLeader子类：同时继承自Person和Employee（多继承）
class SectionLeader : public Person, public Employee {
protected:
    // 子类的保护成员
    std::string section;          // 负责的课程小节
    std::string course;           // 负责的课程
    std::vector<std::string> students;  // 负责的学生列表

public:
    // 构造函数：初始化姓名及其他成员
    SectionLeader(const std::string& name, ...);
    
    // 公有成员函数：添加/移除学生、获取课程信息等
    void addStudent(const std::string& student);
    void removeStudent(const std::string& student);
    std::string getSection() const;
    std::string getCourse() const;
    std::vector<std::string> getStudents() const;
    
    // 重写Employee的纯虚函数
    std::string getRole() const override;
    double getSalary() const override;
    void setSalary(double salary) override;
    
    // 析构函数
    ~SectionLeader();
};
```
是这样的关系：
![[Pasted image 20251022222014.png]]

## 多继承的问题
当一个子类同时继承自两个父类，而这两个父类又继承自同一个基类时，会导致基类成员被重复继承。我们称之为菱形问题！

## 菱形问题的解决：虚继承（Virtual Inheritance）

虚继承确保子类（如 SectionLeader）仅拥有基类（如 Person）的一个实例，避免成员重复。
### 虚继承的语法

在父类继承基类时，添加`virtual`关键字：
```cpp
// Student子类：虚继承自Person
class Student : public virtual Person {
    // 成员定义（同前）
};

// Employee子类：虚继承自Person
class Employee : public virtual Person {
    // 成员定义（同前）
};
```

## 虚继承的注意事项

1. 虚继承的子类（如 SectionLeader）需要显式初始化基类（如 Person），即使基类的构造函数在父类（如 Student/Employee）中已调用。
2. 虚继承仅在多继承场景下需要使用，单一继承无需考虑菱形问题。

# 总结

1. 类允许将功能和数据封装在一起，并通过访问控制（公有 / 私有）保护数据安全。
2. 继承支持设计灵活且强大的抽象结构，帮助在代码中建模复杂的关系（如形状的分类、人的角色分类）。
3. 类和继承是 C++ 的核心概念，理解这些概念能充分发挥 C++ 的编程能力（尽管学习过程可能有难度）。
