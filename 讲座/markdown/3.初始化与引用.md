## 标准C++向量（`std::vector`）入门
由于上这门可的同学大部分可能是从cs106B来的，而且都是以cs106B作为c++入门的学科（当然这门课程才是我认为真正适合作为入门课程的！）。然而在106B在他的目的是更加高层的编程思维的培养，所以在讲c++的时候，用到了斯坦福自己定义的一个代码仓库，那么其中有许多语法是与标准的有出入的！比如向量：

### 1. 斯坦福自定义向量（Stanford Vector）回顾
在 CS 106B 中使用的是斯坦福自定义的 `Vector` 类，常用操作如下：
```cpp
Vector<int> v;                // 创建空向量
Vector<int> v(n, k);          // 创建含 n 个 k 值的向量
v[i] = k;                     // 给第 i 个元素赋值
auto k = v[i];                // 获取第 i 个元素
v.add(k);                     // 在向量末尾添加元素
v.isEmpty();                  // 判断向量是否为空
v.size();                     // 获取向量元素个数
v.clear();                    // 清空向量
v.insert(i, k);               // 在第 i 个位置插入元素 k
v.remove(i);                  // 删除第 i 个位置的元素
```
### 2. 斯坦福 `Vector` 与标准 `std::vector` 对比
标准库中的 `std::vector` 与斯坦福 `Vector` 功能相似，但部分接口名称不同，需注意区分：

| 操作功能           | 斯坦福 `Vector`                   | 标准 `std::vector`                     |
| -------------- | ------------------------------ | ------------------------------------ |
| 创建空向量          | `Vector<int> v;`               | `std::vector<int> v;`                |
| 创建含 n 个 k 的向量  | `Vector<int> v(n, k);`         | `std::vector<int> v(n, k);`          |
| 末尾添加元素         | `v.add(k);`                    | `v.push_back(k);`                    |
| 访问 / 修改第 i 个元素 | `v[i] = k;` / `auto k = v[i];` | 用法相同（`v[i] = k;` / `auto k = v[i];`） |
| 判断是否为空         | `v.isEmpty();`                 | `v.empty();`                         |
| 获取元素个数         | `v.size();`                    | 用法相同（`v.size();`）                    |
| 清空向量           | `v.clear();`                   | 用法相同（`v.clear();`）                   |
| 插入元素           | `v.insert(i, k);`              | 后续课程讲解（接口更复杂）                        |
| 删除元素           | `v.remove(i);`                 | 后续课程讲解（接口更复杂）                        |
但是如果你没有上过cs106B，那么你关注标准库就可以了！

## 统一初始化（Uniform Initialization）
### 1. 什么是初始化？
初始化指**为变量提供初始值的过程**，分为 “声明时初始化” 和 “声明后初始化” 两种方式。

#### 初始化示例
```cpp
int x = 5;  // 声明时初始化：声明变量 x 的同时赋值 5
int y;      // 声明变量 y
y = 6;      // 声明后初始化：后续为 y 赋值 6
```

### 2. 传统初始化的问题
在 C++ 中，传统初始化方式因变量类型不同而差异较大，代码繁琐且不统一。
#### 传统复杂初始化示例
```cpp
// 1. std::pair 初始化：需调用 std::make_pair
std::pair<bool, int> some_pair = std::make_pair(false, 6);

// 2. Student 结构体初始化：需逐个赋值成员
Student s;          // 先声明结构体变量
s.name = "Ethan";   // 为 name 赋值
s.state = "CA";     // 为 state 赋值
s.age = 20;         // 为 age 赋值
```

### 3. 统一初始化的优势
统一初始化通过**大括号 `{}`** 实现 “一种语法初始化所有类型”，代码更简洁、统一。
#### 统一初始化示例（简化前后对比）
**改进前**
```cpp
std::pair<bool, int> some_pair = std::make_pair(false, 6);

Student s;
s.name = "Ethan";
s.state = "CA";
s.age = 20;
```

**改进后**
```cpp
std::pair<bool, int> some_pair{false, 6};
Student s{"Ethan", "CA", 20};
```

也可以将变量赋值为大括号包裹的初始化内容：
**改进前**
```cpp
std::pair<bool, int> some_pair = std::make_pair(false, 6);

Student s;
s.name = "Ethan";
s.state = "CA";
s.age = 20;
```

**改进后**
```cpp
std::pair<bool, int> some_pair = {false, 6};
Student s = {"Ethan", "CA", 20};
```

而且更加安全：
改进前：
```cpp
#include <iostream>
int main() {
    int numOne = 12.0;
    int numTwo(12.0);
    std::cout << "numOne 的值为：" << numOne << std::endl;
    std::cout << "numTwo 的值为：" << numTwo << std::endl;
    return 0;
}
```
运行结果为：
```plaintext
numOne 的值为：12
numTwo 的值为：12
程序运行结束，退出码为0
按回车键退出控制台。
```
这是一种隐式转化，学过Java的会懂得！
改进后：
```cpp
#include <iostream>
int main() {
    // 注意这里使用的花括号
    int numOne{12.0}; 
    float numTwo{12.0};
    std::cout << "numOne 的值为：" << numOne << std::endl;
    std::cout << "numTwo 的值为：" << numTwo << std::endl;
    return 0;
}
```
他会直接报错。
```plaintext
int numOne{12.0};
生成1个错误。
```
所以后者更安全！
#### 统一初始化示例
```cpp
int x{3};        // 此处统一初始化的优势不明显
int y = {3};

// 以下两个向量的元素均为{3, 5, 7}
std::vector<int> a_vector{3, 5, 7};
std::vector<int> another_vector = {3, 5, 7};

// 后续学习类时，可使用统一初始化调用构造函数，
// 构造函数决定了变量的初始化方式
```
### 4.统一初始化的 “陷阱”
还记得这种初始化`std::vector`的方式吗？
```cpp
int n = 3;
int k = 5;
std::vector<int> v(n, k);  // 结果为{5, 5, 5}
```

这种初始化方式调用了一个构造函数（106B 课程将会详细讲解构造函数，大家对此不熟悉可以去106B看看！）：
通常情况下，可以将圆括号`()`替换为大括号`{}`以使用统一初始化，但此处不适用！
```cpp
int n = 3;
int k = 5;
std::vector<int> v(n, k);  // 结果为{5, 5, 5}
std::vector<int> v2{n, k}; // 结果为{3, 5}——与预期不符！
```
对向量使用`{}`会创建一个`initializer_list`（初始化列表）。当创建`std::initializer_list`时，实际上调用了另一个构造函数！叫做初始化列表，让列表（{1，2，3}）可以直接作为参数被函数接收
```cpp
auto list_init{3, 5};  // 类型为std::initializer_list
```
比如：
```cpp
void print(std::initializer_list<int> list) {
    for (int x : list) {
        std::cout << x << " ";
    }
}

print({1, 2, 3}); // 可以直接传 {1,2,3}
```
这主要是因为
- `std::vector` 有两个相关的构造函数：
    1. `vector(size_type count, const T& value = T{})`
    2. `vector(std::initializer_list<T> init)`
**关键结论**：使用统一初始化时，务必明确自己正在调用哪个构造函数。当然最常见的就是我们说到的这个`std::initializer_list`相关的二义性问题的例子以及对于像 `std::vector`, `std::array`, `std::string` 等容器，`{n}` 和 `(n)` 含义完全不同。这个需要大家多多写代码积累经验！

### 5. 复杂的统一初始化示例
假设我们用结构体表示斯坦福大学的课程：
```cpp
struct Course {
    std::string code;
    std::pair<Time, Time> time;
    std::vector<std::string> instructors;
};

struct Time {
    int hour, minute;
};

Course now{"CS106L", {{14, 30}, {15, 50}}, {"Raghuraman", "Chi"}};
```

### 6.统一初始化总结

- 可使用统一初始化初始化任意类型的变量。
- 注意与`std::initializer_list`相关的二义性问题。

## 引用
### 编程问题
编写一个函数，将`std::vector`中的所有课程时间向后推迟 1 小时。
```cpp
struct Course {
    std::string code;
    std::pair<Time, Time> time;
    std::vector<std::string> instructors;
};

struct Time {
    int hour, minute;
};

void shift(std::vector<Course>& courses) {
    // 待实现
}
```
这就是大概的框架，大家先去试试，自己可不可以写出来，写之前大家需要去翻阅c++文档，尤其是引用部分的内容，解决这个问题需要用到引用！

其实如果你是新手，大概率会报错，这是因为我们少学了一点内容，就是引用！
下面给大家来演示一下大部分新手写的代码可能出现的错误！
### 代码演示：课程时间调整（存在 bug）
```cpp
void shift(vector<Course>& courses) {
    for (size_t i = 0; i < courses.size(); ++i) {
        auto [code, time, instructors] = courses[i];
        time.first.hour++;
        time.second.hour++;
    }
}
// 问题：此处创建了课程的副本
// 对副本进行修改，原向量中的课程未受影响！
```
### 另一种错误写法
```cpp
void shift(vector<Course>& courses) {
    for (auto [code, time, instructors] : courses) {
        time.first.hour++;
        time.second.hour++;
    }
}
// 问题：同样创建了课程的副本
// 对副本进行修改，原向量中的课程未受影响！
```
我们需要进一步了解引用参数的知识！

### 106B 课程中的知识点回顾（如果没有上过106B，现在通过接下来的内容进行学习也不迟！）
变量`myValue`通过引用传递到`doubleValue`函数中：
```cpp
int doubleValue(int& x) {
    x *= 2;
    return x;
}
// doubleValue函数中的x是main函数中myValue的别名
// 这意味着x是同一个变量的另一个名称！
int main() {
    int myValue = 5;
    int result = doubleValue(myValue);
    cout << myValue << endl;  // 输出10
    cout << result << endl;   // 输出10
}
// 对x的修改等同于对myValue的修改，这就是引用的目的
```
### 变量赋值中的引用
注意 & 符号 ——`ref`是`original`的别名！
```cpp
std::vector<int> original{1, 2};
std::vector<int> copy = original;
std::vector<int>& ref = original;

original.push_back(3);
copy.push_back(4);
ref.push_back(5);

// original（及ref）的值为{1, 2, 3, 5}
// copy的值为{1, 2, 4}
```

### 练习题（可课后尝试）

阅读以下代码并思考问题（答案见下一页）：
```cpp
std::vector<int> original{1, 2};
std::vector<int> copy = original;
std::vector<int>& ref = original;

original.push_back(3);
copy.push_back(4);
ref.push_back(5);

// original（及ref）的值为{1, 2, 3, 5}
// copy的值为{1, 2, 4}

ref = copy;
copy.push_back(6);
ref.push_back(7);
// 问题1：original的内容是什么？
// 问题2：copy的内容是什么？
```

### 引用的核心特性

引用始终是同一个变量的别名！这意味着将`ref`赋值为新值，等同于将`original`赋值为该新值，无法改变`ref`所别名的变量。（就是说ref还是original的别名）
接下来我一步步分析上一题的答案：
```cpp
std::vector<int> original{1, 2};
```
得到：
```
original → {1, 2}
```

```cpp
std::vector<int> copy = original;
```
得到：
```
original → {1, 2}
copy → {1, 2}
```

```cpp
std::vector<int>& ref = original;
```
得到：
```
original → {1, 2}
 ↑
ref

copy → {1, 2}
```

```cpp
original.push_back(3);
copy.push_back(4);
ref.push_back(5);
```
得到：
```
original → {1, 2, 3, 5}
 ↑
ref

copy → {1, 2, 4}
```

```cpp
ref = copy;
```
得到：
```
original → {1, 2, 4}             {1, 2, 3, 5}(被遗弃)
 ↑
ref

copy → {1, 2, 4}
```

```cpp
copy.push_back(6);
ref.push_back(7);
```
得到：
```
original → {1, 2, 4, 7}             {1, 2, 3, 5}(被遗弃)
 ↑
ref

copy → {1, 2, 4, 6}
```
答案就是：
original的值为{1, 2, 4, 7}
copy的值为{1, 2, 4, 6}

### 代码演示：引用的陷阱

注意：只能为变量创建引用。这与 “左值”（l-values）相关，我们将在课程后期讨论左值（可参考错误信息中的提示）！
```cpp
int& thisWontWork = 5;  // 无法编译通过！
```
所以大家在跑这部分代码的时候不通过不要惊讶哦！

## 常量与常量引用
`const`关键字表示变量不能被修改。常量变量可以是引用类型，也可以是非引用类型。
```cpp
std::vector<int> vec{1, 2, 3};
std::vector<int>& ref = vec;          // 普通引用
const std::vector<int> c_vec{7, 8};   // 常量变量
const std::vector<int>& c_ref = vec;  // 常量引用

c_vec.push_back(3);   // 错误——常量变量不可修改
vec.push_back(3);     // 正确——普通变量可修改
ref.push_back(3);     // 正确——普通引用可修改
c_ref.push_back(3);   // 错误——常量引用不可修改
```

### 常量引用的限制
1. 不能为常量变量声明非常量引用：
```cpp
const std::vector<int> c_vec{7, 8};  // 常量变量
// 错误——无法为常量向量声明非常量引用
std::vector<int>& bad_ref = c_vec;
```
2. 不能为常量引用声明非常量引用：
```cpp
std::vector<int> vec{1, 2, 3};
const std::vector<int>& c_ref = vec;  // 常量引用

// 错误——无法将非常量引用赋值给常量引用
std::vector<int>& ref = c_ref;
```
3. 若不写`&`，C++ 默认会创建副本：
```cpp
std::vector<int> vec{1, 2, 3};
const std::vector<int>& c_ref = vec;  // 常量引用，不能通过它修改 vec

// 即使将变量赋值给常量引用，此处仍会创建vec的非常量副本（这句话要理解，还需要深入学习后面内容，现在不理解没有关系，只需要知道他会创建一个副本）
// 注意：ref只是vec的别名
std::vector<int> copy = c_ref;

copy.push_back(4);
// vec的值为{1, 2, 3}
// copy的值为{1, 2, 3, 4}
```

4. 使用`auto`时需显式指定`const`和`&`：
```cpp
std::vector<int> vec{1, 2, 3};
const std::vector<int> c_vec{7, 8};
std::vector<int>& ref = vec;
const std::vector<int>& c_ref = vec;

auto copy = c_ref;                // 非常量副本
const auto const_copy = c_ref;    // 常量副本
auto& a_ref = ref;                // 非常量引用
const auto& c_aref = ref;         // 常量引用
```

**注意**：在 C++ 中，变量赋值默认会创建副本。若需要引用而非副本，必须显式使用`&`。这是核心！
所以上面总结下来就是：
1. 被 const 修饰的变量，其值无法被修改，任何修改操作都会导致编译错误。
2. 普通引用可以修改所绑定的非 const 变量的值。
3. 常量引用无法修改所绑定变量的值，即使原变量是非 const 类型。
4. 不能将非 const 引用绑定到 const 变量，这会破坏 const 变量的不可修改性，导致编译错误。

## 更多关于引用的知识
### 引用作为返回值
函数也可以返回引用，C++ 标准库经常使用这一特性。
```cpp
// 注意：若要返回参数中某个元素的非常量引用，
// 则该参数必须是非常量引用类型！如果参数是常量引用，那么函数就不能对元素进行修改，而且改名常量引用为非常量引用在c++中是违法的！
int& front(std::vector<int>& vec) { //在函数传参时使用引用我们称为引用传递！
    // 假设vec.size() > 0（向量非空）
    return vec[0];
}//这个函数返回的就是vec索引为0的位置的别名，这个别名是非常量引用
int main() {
    std::vector<int> numbers{1, 2, 3};
    front(numbers) = 4;  // 向量变为{4, 2, 3}
    return 0;
}
```
这段代码我还需要讲到的一点是引用传递！：
大家会发现在main函数中传入front的参数不是一个引用啊，这不是多此一举吗，直接写`std::vector<int> vec`不是更好吗，为什么要`std::vector<int>& vec`。其实这是为了提升性能！如果`std::vector<int> vec`写出这样，那么这个函数就是值传递，在调用这个函数的时候，会拷贝一份numbers的副本给vec，这样会多占用内存空间！然而如果说是`std::vector<int>& vec`这样，就不会拷贝，而是把vec作为别名引用给numbers。当然这一切在函数执行完成后都会消失！

也可以返回常量引用：
```cpp
const int& front(const std::vector<int>& vec) {
    // 假设vec.size() > 0（向量非空）
    return vec[0];
}//这个返回的别名是常量引用
//或者
const int& front(std::vector<int>& vec) {
    // 假设vec.size() > 0（向量非空）
    return vec[0];
}//这个返回的别名是常量引用
```
细心的会发现，第二个函数，函数的返回类型是常量引用，而参数是非常量引用，那这会改变引用类型，不会报错吗，不会的，因为非常量可以改为常量，反过来不行！
### 悬空引用
悬空引用指引用了超出作用域的变量。永远不要返回局部变量的引用，因为局部变量会在函数结束后超出作用域。
```cpp
int& front(const std::string& file) {
    std::vector<int> vec = readFile(file);
    return vec[0];  // vec是局部变量，函数结束后销毁
}

int main() {
    front("text.txt") = 4;  // 未定义行为（引用指向已销毁的变量）
    return 0;
}
```
这段代码我想要说的是，`const std::string& file`。为什么要这样呢，其实上面我们说到了引用传递的好处，但是如果当我们不想要在函数中修改原副本时，就可以这样！

好，现在我们回到开始那个问题，这么把斯坦福的课都延长一个小时！
### 回到示例：如何修复这段代码？
```cpp
void shift(vector<Course>& courses) {
    for (size_t i = 0; i < courses.size(); ++i) {
        auto [code, time, instructors] = courses[i];
        time.first.hour++;
        time.second.hour++;
    }
}
```

### 修复方案一
```cpp
void shift(vector<Course>& courses) {
    for (size_t i = 0; i < courses.size(); ++i) {
        auto& [code, time, instructors] = courses[i]; // 此处创建了课程的引用
        time.first.hour++;
        time.second.hour++; // 对引用的修改会作用于原向量中的课程
    }
}
```

### 修复方案二
```cpp
void shift(vector<Course>& courses) {
    for (auto& [code, time, instructors] : courses) { // 此处创建了课程的引用
        time.first.hour++;
        time.second.hour++; // 对引用的修改会作用于原向量中的课程
    }
}
```
修改的代码已上传仓库，大家可以自己运行看看！


## 何时使用引用 / 常量引用？

1. 若变量占用内存较小（如`int`、`double`），无需使用引用，直接复制变量即可。
2. 若需要通过别名修改变量，可使用普通引用。
3. 若无需修改变量，但变量占用内存较大（如`std::vector`），可使用常量引用以避免拷贝开销。

## 左值与右值
### 左值与右值的核心区别
| 对比维度     | 左值（l-value）                              | 右值（r-value）                                 |
| -------- | ---------------------------------------- | ------------------------------------------- |
| 在等号两侧的位置 | 可位于等号左侧或右侧                               | 仅能位于等号右侧                                    |
| 示例       | `int x = 10;`（x 是左值）、`int y = x;`（x 是左值） | `int x = 10;`（10 是右值）、`int y = x;`（x 的值是右值） |
左值他是有明确的内存地址（可取地址 `&`，也就是可以被引用），通常是可修改的（除非是 `const` 左值）。右值是通常没有持久地址（不能取地址，或取地址无意义），不可修改（是临时值）！

### 错误示例
```cpp
#include <stdio.h> 
#include <cmath> 
#include <iostream>

// 函数参数为int类型的引用
int squareN(int& num) { 
    return std::pow(num, 2); 
}

int main() { 
    int lValue = 2; 
    // 传递左值，正常运行
    auto four = squareN(lValue); 
    // 传递右值（字面量2），编译错误
    auto fourAgain = squareN(2); 
    std::cout << four << std::endl; 
    return 0; 
}
```
### 错误原因

- `int& num`要求接收的是左值，因为引用需要绑定到一块持久的内存地址。
- 右值（如字面量 2）是临时值，没有持久的内存地址，无法被非 const 引用绑定。
- 因此，传递 2 给 squareN 函数时，编译器会报错，提示 “候选函数不可用：第一个参数需要左值”。

### 关键结论

1. 引用（非 const）只能绑定到左值，因为左值具有持久的内存地址。
2. 右值是临时的，无法被非 const 引用绑定，否则会导致编译错误。

## c++编译
我本来不想讲这个的内容，但是考虑到需要一些关于环境配置底层的知识，那么还是强调一下这部分的内容！
### 编译的核心作用

将人类可读的 C++ 源代码，翻译成计算机可执行的机器码。

### 编译相关基础知识

1. C++ 是编译型语言，必须经过编译才能运行。
2. 负责编译的工具称为编译器，常见的 C++ 编译器有 clang 和 g++以及msvc。
3. 使用 g++ 编译程序的基本命令：`g++ -std=c++20 main.cpp -o main`
这是因为g++是最常用的，所以我们解释一下他的命令。

### 编译命令各部分含义

|命令组成|作用|
|---|---|
|`g++`|调用 g++ 编译器|
|`-std=c++20`|指定使用 C++20 标准进行编译|
|`main.cpp`|指定需要编译的源代码文件|
|`-o main`|指定编译生成的可执行文件名为 main|

### 简化编译命令

- 若省略`-o main`，直接使用`g++ -std=c++20 main.cpp`，编译器会默认生成名为`a.out`的可执行文件。

### 运行可执行文件

- 在 Linux 或 macOS 系统中，运行命令为`./main`（若可执行文件名为 main）或`./a.out`（若为默认文件名）。

然后大家有点不能理解的是-std=c++20，怎么还可以选择c++版本呢，python解释器都是一对一对应着版本的啊，Java也是这样啊，这么c++一个版本的编译器对应着许多版本的c++!没错就是这样的，至于为什么，也许你该去问问c++委员会或者下图中的老头。
![[Pasted image 20251018013254.png]]
