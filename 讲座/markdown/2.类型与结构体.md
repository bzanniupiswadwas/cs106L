## 命名空间相关说明

部分内容位于 `std::` 命名空间下，例如：`std::cout`（标准输出流）、`std::cin`（标准输入流）、`std::lower_bound`（STL 中的二分查找函数）。

在 CS 106B 课程中，通常会使用 `using namespace std;` 声明，该声明会自动为代码中的标准库内容添加 `std::` 前缀，无需手动书写。

但在本课程中（大部分情况下）**不会使用该声明**，原因是：这种写法不符合良好的代码风格，可能导致命名冲突（例如自定义函数与标准库函数同名时产生歧义）。比如：
```cpp
using namespace std;
void sort() { /* 自定义排序 */ }

int main() {
    sort(); // 二义性错误！调用哪个 sort？
}
```
后续课程会通过更多示例进一步说明这一点。

## 数据类型
### 1. 什么是数据类型？

数据类型用于定义不同变量的 “类别”，它决定了变量能存储的数据类型、占用的内存大小以及可进行的操作。

### 2. 常见的数据类型

| 数据类型     | 示例值      | 说明                               |
| -------- | -------- | -------------------------------- |
| `int`    | `5`      | 整型，用于存储整数                        |
| `double` | `77.3`   | 双精度浮点型，用于存储带小数的数值                |
| `string` | `"test"` | 字符串类型，用于存储文本（需包含 `<string>` 头文件） |
| `bool`   | `true`   | 布尔型，仅存储 `true`（真）或 `false`（假）两个值 |
| `size_t` | `5`      | 无符号整型，通常用于表示内存大小、数组索引等非负数值       |

### 3. C++ 是静态类型语言

静态类型语言的核心特点是：**在编译阶段就确定所有变量的数据类型**，且后续无法随意更改。与之相对的是动态类型语言（如 Python），变量类型可在运行时动态变化。

| Python（动态类型）                    | C++（静态类型）                                           |
| ------------------------------- | --------------------------------------------------- |
| `a = 3`（无需声明类型，赋值后自动确定为整数）      | `int a = 3;`（必须明确声明变量类型为 `int`）                     |
| `b = "test"`（变量 `b` 类型动态变为字符串）  | `string b = "test";`（明确声明 `b` 为 `string` 类型）        |
| `def func(c):`（函数参数 `c` 类型无需声明） | `void func(string c) { }`（必须声明参数 `c` 为 `string` 类型） |
### 4. 更多类型使用示例
```cpp
int a = 3;          // 声明整型变量 a，赋值为 3
string b = "test";  // 声明字符串变量 b，赋值为 "test"

// 函数参数需明确类型，返回值类型为 void（无返回值）
void func(double c) {
    std::cout << b << std::endl;  // 使用已声明的变量 b，无需重复指定类型
}

if (b == 3) { /* 执行逻辑 */ }  // 编译错误：string 类型与 int 类型无法直接比较（静态类型检查）
```

### 5. 为什么使用静态类型？

- **性能更优**：编译时已确定类型，无需运行时额外进行类型判断，程序执行速度更快。
- **代码更易理解**：变量、函数参数的类型明确，其他开发者阅读代码时能快速了解数据含义。
- **错误检查更及时**：编译阶段可捕获类型不匹配等错误，避免程序运行时因类型问题崩溃。
#### 示例：静态类型的错误捕获优势
```python
def add_3(x):
	return first + 3

add_3('10')  # 运行时错误：字符串与整数无法相加，程序崩溃
```

```cpp
int add_3(int x){
	return first + 3;
}
add_3('10')// 编译错误：函数参数需为 int 类型，字符串类型不匹配，编译直接失败
```

### 6. 类型填空练习
```cpp
_____ a = "test";
_____ b = 3.2 * 5 - 1;
_____ c = 5 / 2;
_____ d(int foo) { return foo / 2; }
_____ e(double foo) { return foo / 2; }
_____ f(double foo) { return (int)(foo / 2); }
_____ g(double c) {
    std::cout << c << std::endl;
}
```
#### 正确答案及解析
```cpp
string a = "test";  // "test" 是字符串，对应 string 类型
double b = 3.2 * 5 - 1;  // 3.2 是 double 类型，运算结果仍为 double
int c = 5 / 2;  // 两个 int 类型相除，结果取整（值为 2）
int d(int foo) { return foo / 2; }  // 参数为 int，返回值为 int（foo/2 取整）
double e(double foo) { return foo / 2; }  // 参数为 double，返回值为 double（保留小数）
int f(double foo) { return (int)(foo / 2); }  // 强制类型转换为 int，返回整数
void g(double c) {  // 无返回值，用 void 声明
    std::cout << c << std::endl;
}
```

## 函数重载（Overloading）
### 1. 定义

函数重载指：**定义两个或多个同名函数，但函数的调用签名（参数类型、参数个数或参数顺序）不同**。编译器会根据调用时传入的实参类型，自动匹配对应的函数版本。

### 2. 示例
```cpp
// 版本1：参数为 int 类型，返回值为 double 类型
double func(int x) {
    return (double)x + 3;  // 强制类型转换：将 int 转为 double，避免整数相加
}

// 版本2：参数为 double 类型，返回值为 double 类型
double func(double x) {
    return x * 3;
}

// 函数调用与匹配
func(2);       // 传入 int 类型实参，匹配版本1，返回 5.0（2 转为 double 后 +3）
func(2.0);     // 传入 double 类型实参，匹配版本2，返回 6.0（2.0 * 3）
```

### 3. 注意事项

- 函数返回值类型不同**不能作为函数重载的依据**（例如两个函数仅返回值类型不同，参数完全一致，则编译报错）。
- 函数重载的核心是 “让同名函数处理不同类型的参数”，提升代码可读性（无需为相似功能的函数起不同名字）。

## 结构体（Structs）
### 1. 引入背景：学生信息管理场景

假设需要存储学生的三项信息：姓名（`string`）、家乡（`string`）、年龄（`int`）。若直接使用独立变量，会面临两个问题：

- 函数返回值限制：无法直接返回多个不同类型的值（例如无法同时返回姓名、家乡和年龄）。
- 函数参数冗余：调用函数时需重复传入多个变量（如 `printStudentInfo(name, state, age)`），代码繁琐且易出错。
```cpp
___ getStudentWithID(int id) {  
// how can we return a string, a string, and an int?  
}  
// python:  
// return (“a”, “b”, 3)
```

### 2. 结构体的定义
结构体是**一组命名变量的集合，每个变量（称为 “成员” 或 “字段”）可拥有独立的数据类型**，用于将相关联的数据 “打包” 成一个整体。
#### 语法格式
```cpp
// 声明结构体类型（通常在函数外声明，以便多个函数使用）
struct 结构体名称 {
    数据类型1 成员名1;  // 成员1
    数据类型2 成员名2;  // 成员2
    // ... 更多成员
};  // 注意：结构体声明末尾需加分号

// 示例：Student 结构体
struct Student {
    string name;   // 姓名
    string state;  // 家乡
    int age;       // 年龄
};
```

### 3. 结构体的使用
#### （1）创建结构体变量并赋值
```cpp
// 方式1：先创建变量，再通过 "." 运算符访问成员赋值
Student s;          // 创建 Student 类型变量 s
s.name = "Ethan";   // 为 name 成员赋值
s.state = "CA";     // 为 state 成员赋值
s.age = 20;         // 为 age 成员赋值

// 方式2：创建变量时直接初始化（推荐使用，更简洁）
// 注意：初始化顺序必须与结构体中成员的声明顺序一致
Student s = {"Ethan", "CA", 20};
```

#### （2）结构体作为函数参数
将结构体整体传入函数，避免参数冗余：
```cpp
// 函数参数为 Student 类型，直接访问结构体成员
void printStudentInfo(Student student) {
    std::cout << student.name << " from " << student.state;
    std::cout << " (" << student.age << ")" << std::endl;
}

// 调用函数：传入结构体变量 s
printStudentInfo(s);  // 输出：Ethan from CA (20)
```

#### （3）结构体作为函数返回值
```cpp
// 函数返回值为 Student 类型
Student lookupStudent() {
    Student s = {"Ethan", "CA", 20};  // 创建并初始化结构体
    return s;  // 返回结构体
}

// 调用函数：接收返回的结构体
Student foundStudent = lookupStudent();
std::cout << foundStudent.name << std::endl;  // 输出：Ethan
```

#### （4）结构体更加简单的写法
```cpp
Student issueNewID() {
	return {"Ethan", "CA", 20};
}
```
## 配对（Pairs）与元组（Tuples）
### 1. 配对（`std::pair`）
#### （1）定义

`std::pair` 是 C++ 标准库提供的**包含两个成员的结构体**，用于存储一对相关联的数据（如 “键 - 值” 对、“状态 - 结果” 对）。它是一个模板类，支持任意数据类型的组合（需包含 `<utility>` 头文件）。就像是python里面的二元元组！
#### （2）语法与使用
```cpp
#include <utility>  // 使用 std::pair 需包含此头文件

int main() {
    // 方式1：直接声明 std::pair，指定两个成员的类型（bool 和 Student）
    std::pair<bool, Student> query_result;
    query_result.first = true;                // 第一个成员（first）：布尔型，标识查询是否成功
    query_result.second = {"Ethan", "CA", 30};// 第二个成员（second）：Student 类型，存储查询结果

    // 方式2：使用 std::make_pair 
    std::pair<bool, Student> query_result = std::make_pair(true, Student{"Ethan", "CA", 30});
} 
```

#### （3）典型用途：返回 “状态 + 结果”
例如查询学生信息时，返回 “查询是否成功” 和 “学生信息（若成功）”：
```cpp
// 函数返回值为 std::pair<bool, Student>：bool 表示是否找到，Student 表示找到的学生
std::pair<bool, Student> lookupStudent(string name) {
    Student blank;  // 空的 Student 对象，用于查询失败时返回
    if (notFound(name)) {  // 假设 notFound(name) 是判断“未找到学生”的函数
        return std::make_pair(false, blank);
    }
    Student result = getStudentWithName(name);  // 获取学生信息
    return std::make_pair(true, result);
}

// 调用函数
std::pair<bool, Student> output = lookupStudent("Keith");
if (output.first) {  // 若查询成功（first 为 true）
    std::cout << output.second.name << std::endl;
} else {  // 查询失败
    std::cout << "Student not found!" << std::endl;
}
```
#### （4）补充说明

C++17 及以上标准中，`std::optional` 是比 `std::pair` 更适合 “返回可选结果” 的类型（可直接表示 “有结果” 或 “无结果”），但本阶段暂不深入讲解，后续课程会涉及。

### 小补充
std，在上面的代码中出现了许多次的东西，那么这个东西是什么？已经文件开头的includ <...>是什么！
首先<...>中的...，这是一些头文件，他们的作用是什么呢，简单说就是告诉我们正在写的代码文件一个说明书，说明书里面有一些函数，这些函数全名是什么等信息！比如utility里面包含了pair这个函数，他告诉源文件我这里有一个pair工具，他全名叫做std::pair！但是大家不要误会，...这类文件只是存储一些函数的信息，但是他的功能代码是存储在c++标准库的库文件中的。以后大家有写了一个自己的pair存储在（my_pair）这个文件中，你就可以includ "my_pair"(不能用<>，这是专门为c++标准库头文件准备的)。
那么什么是std，如果你这个项目中，也有其他人写了pair，那么我们调用pair的时候会有歧义，那么这个需要我们自己给我们自己定义一个命名空间（本节最开始说到的那个！），然后我们就可以调用自己的pair，比如dingbawan::pair！所以std这个是c++官方的命名空间！

你会不会觉得类似于iostream的头文件很冗余，为什么不像python一样，直接引入（import）对应存储那个函数功能代码的文件，直接略屌这个头文件过程！这其实是因为两种语言的差异，c++是编译语言，他需要提前知道所有函数的全部代码，就算不知道也要知道他的存在（就是声明）以及实现这个代码的接口（就是通向全部代码的文件的通道！c++选择的是后者）而python不一样，他是解释型语言，那么就可以在不知道全部的情况下一行行变解释边执行！然后回到最初的问题为什么不直接引入代码功能所在的文件，这是因为所以变成语言只能够被定义一次，如果我在一次的代码中需要用到两次这个函数，就会报错，所以有了头文件这个东西。而python没有这个烦恼是因为解释器有对应的智能化操作，但是代价是减慢了速度！这只是一个简单的概述，目的是你需要了解c++的一些设计结构，但是现实的远远比这复杂，比如有些轻量的函数确实就在头文件中写了大部分功能，比如中间还更多的结构来完善这个设计！但是大家不必纠结了解全部！
### 2. 元组（`std::tuple`）
#### （1）定义

`std::tuple` 是**包含多个成员的结构体**（成员数量可超过两个），用于存储多组相关数据（需包含 `<tuple>` 头文件）。它同样是模板类，支持任意类型的组合。类似于python中的多元组！

#### （2）语法与使用
```cpp
#include <tuple>  // 使用 std::tuple 需包含此头文件

int main() {
    // 声明 std::tuple，包含三个成员：string、int、int
    std::tuple<string, int, int> query_result;

    // 通过 std::get<索引> 访问成员（索引从 0 开始）
    string name = std::get<0>(query_result);  // 获取第一个成员（string 类型）
    int num1 = std::get<1>(query_result);     // 获取第二个成员（int 类型）
    int num2 = std::get<2>(query_result);     // 获取第三个成员（int 类型）
}
```

#### 3）注意事项

- `std::tuple` 在实际开发中使用较少，因为其成员需通过 “索引” 访问，可读性差（不如自定义结构体的 “命名成员” 清晰）。
- 多数场景下，`std::vector`（动态数组）、自定义结构体等类型比 `std::tuple` 更实用，后续课程也会以这些类型为主。

## 现场代码演示：Quadratic.cpp
qt这个软件已经下载好了吧。那么请你把仓库中的代码下载下来，并在qt中加载好lecture2这个项目！加载qt项目你需要先打开lecture2中的lecture-2.pro这个文件，然后运行他，他会加载所有的项目的文件的！如果运行出现报错，大概率是路径出现问题，那么你需要调整lecture-2.pro文件中的
```
SOURCES += src/main.cpp

HEADERS += src/main.h
```
这两行代码中的路径选择！

### 1. 背景：二次方程求解

一元二次方程的标准形式为：$ax^2 + bx + c = 0 \quad (\text{其中 } a \neq 0)。$

方程的解通过求根公式计算：$x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$, 其中 $b^2 - 4ac$ 称为判别式：

- 若判别式 >0：有两个不同的实数解；
- 若判别式 =0：有一个实数解（两个相同的解）；
- 若判别式 <0：无实数解（有两个共轭复数解）。

### 2. 代码实现：返回 “是否有解 + 解的值”
```cpp
#include <iostream>
#include <utility>  // 用于 std::pair
#include <cmath>    // 用于 sqrt（平方根函数）

// 函数返回值：std::pair<bool, std::pair<double, double>>
// 外层 pair：first（bool）表示是否有实数解，second（pair<double, double>）表示两个解
std::pair<bool, std::pair<double, double>> quadratic(int a, int b, int c) {
    double discriminant = b * b - 4 * a * c;  // 计算判别式
    std::pair<double, double> blank;          // 空的 pair，用于无解得情况

    if (discriminant < 0) {  // 无实数解
        return std::make_pair(false, blank);
    }

    // 计算两个实数解
    double sol1 = (-b + sqrt(discriminant)) / (2 * a);
    double sol2 = (-b - sqrt(discriminant)) / (2 * a);
    std::pair<double, double> answer = std::make_pair(sol1, sol2);

    return std::make_pair(true, answer);  // 有实数解，返回解的值
}

// 主函数：调用 quadratic 函数并输出结果
int main() {
    int a, b, c;
    std::cin >> a >> b >> c;  // 从标准输入读取 a、b、c 的值

    // 调用 quadratic 函数，获取结果
    std::pair<bool, std::pair<double, double>> result = quadratic(a, b, c);

    if (result.first) {  // 有实数解
        std::pair<double, double> solutions = result.second;
        std::cout << "Solutions: " << solutions.first << " " << solutions.second << std::endl;
    } else {  // 无实数解
        std::cout << "No solutions found!" << std::endl;
    }

    return 0;
}
```
这段代码写在了项目里！
好好品味，这里的一切代码我们在课上都讲过了。最好大家能够自己打一遍这个代码（自己打，不要借助外力）！

## `auto` 类型推导（Type Deduction with Auto）
### 1. 定义
`auto` 是 C++11 及以上标准引入的关键字，用于**让编译器自动推导变量的数据类型**，无需手动声明。它的核心作用是简化代码，尤其是当变量类型名称较长时（如 `std::pair<bool, std::pair<double, double>>`）。

### 2. 示例：`auto` 推导类型
```cpp
// 编译器自动推导变量类型
auto a = 3;                // 推导为 int 类型
auto b = 4.3;              // 推导为 double 类型
auto c = 'X';              // 推导为 char 类型
auto d = "Hello";          // 推导为 const char* 类型（C风格字符串）
auto e = std::make_pair(3, 3);  // 推导为 std::pair<int, int> 类型
```

### 3. 关键注意点
- `auto` **不表示变量 “没有类型”**，而是变量类型由编译器在编译阶段根据初始化值推导确定，推导后类型固定（仍遵循静态类型规则）。
- `auto` 不能用于函数返回值类型推导（除非使用 C++14 及以上标准的 “返回类型后置” 语法，但本课程暂不推荐），也不能用于函数参数类型声明。例如：
```cpp
// 错误：auto 不能用于函数返回值类型（C++11 标准下）
auto wrong() {
    return 3;
}

// 错误：auto 不能用于函数参数类型
void wrong(string a, auto b) {
    return a * b;
}
```

### 4. 何时使用 `auto`？
#### （1）场景：简化长类型名称
例如在二次方程求解代码中，`result` 变量的类型为 `std::pair<bool, std::pair<double, double>>`，手动声明繁琐，可用 `auto` 简化：
```cpp
// 简化前：手动声明长类型
std::pair<bool, std::pair<double, double>> result = quadratic(a, b, c);
std::pair<double, double> solutions = result.second;

// 简化后：auto 自动推导类型
auto result = quadratic(a, b, c);  // 推导为 std::pair<bool, std::pair<double, double>>
auto solutions = result.second;    // 推导为 std::pair<double, double>
```

#### （2）注意：避免过度使用

- 当变量类型简单且明确时（如 `int a = 3`），不建议使用 `auto`，否则会降低代码可读性（开发者需通过初始化值反推类型）。
- `auto` 的核心价值是 “简化长类型”，而非 “省略所有类型声明”。

## 结构化绑定（Structured Binding）
### 1. 定义

结构化绑定是 C++17 及以上标准引入的特性，用于**直接从结构体（或 `std::pair`、`std::tuple`）中提取成员，并初始化多个变量**，无需通过 `.` 运算符（或 `std::get`）逐个访问成员。

### 2. 示例：`std::pair` 的结构化绑定
#### 简化前：逐个访问成员
```cpp
auto p = std::make_pair("s", 5);  // p 是 std::pair<const char*, int> 类型
string a = p.first;               // 访问第一个成员
int b = p.second;                 // 访问第二个成员
```
#### 简化后：结构化绑定直接提取
```cpp
auto p = std::make_pair("s", 5);
auto [a, b] = p;  // 结构化绑定：a 对应 p.first，b 对应 p.second
// a 推导为 const char* 类型，b 推导为 int 类型

// 更简洁的写法：直接对 std::make_pair 结果进行绑定
auto [a, b] = std::make_pair("s", 5);
```

### 3. 扩展：自定义结构体的结构化绑定
结构化绑定同样适用于自定义结构体，只要结构体的成员是 “公开且有序” 的：
```cpp
struct Student {
    string name;
    string state;
    int age;
};

Student s = {"Ethan", "CA", 20};
auto [name, state, age] = s;  // 结构化绑定：name 对应 s.name，state 对应 s.state，age 对应 s.age
std::cout << name << " " << state << " " << age << std::endl;  // 输出：Ethan CA 20
```

### 4. 注意事项

- 结构化绑定的变量顺序**必须与结构体 /`pair`/`tuple` 的成员顺序一致**（例如 `auto [state, name, age] = s` 会导致变量值与预期不符）。
- 目前不支持 “嵌套结构化绑定”（例如无法直接用 `auto [found, [x1, x2]] = result` 提取嵌套 `pair` 的成员，需分两步绑定）。

### 5. 应用：简化二次方程求解代码
```cpp
int main() {
    int a, b, c;
    std::cin >> a >> b >> c;

    // 第一步：绑定外层 pair（found 对应 result.first，solutions 对应 result.second）
    auto [found, solutions] = quadratic(a, b, c);

    if (found) {
        // 第二步：绑定内层 pair（x1 对应 solutions.first，x2 对应 solutions.second）
        auto [x1, x2] = solutions;
        std::cout << "Solutions: " << x1 << " " << x2 << std::endl;
    } else {
        std::cout << "No solutions found!" << std::endl;
    }

    return 0;
}
```

这种写法的优势是：变量名称（`found`、`x1`、`x2`）直接反映数据含义，代码语义更清晰，可读性更高。这段代码，我也是极力推荐你去自己敲一遍！
