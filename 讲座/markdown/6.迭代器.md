先回答两个问题！

哪些类型支持在首尾两端以相同效率插入元素？
答案是：std::deque

哪些类型要求元素类型具备比较运算符？
答案是：std::map以及std::set

`unordered_set` 和 `set` 通常哪个更快？原因是什么？
答案是：unordered_set。因为后者使用的是哈希表，且负载因子小！

下图是我们上一讲内容说到的容器：
![[Pasted image 20251021214917.png]]大家回忆一下！

# for循环的初次见面
```cpp
for (const auto& elem : container)
```
这行代码大家看过许多次了吧！
不清楚，我们来看例子：
```cpp
std::vector<int> v { 1, 2, 3, 4 };
for (const auto& elem : v) {
    std::cout << elem << std::endl;
}
```
![[Pasted image 20251021215146.png]]

```cpp
std::deque<int> d { 
    1, 9, 7, 3, 
    2, 1, 2, 9 
};
for (const auto& elem : d) {
    std::cout << elem << std::endl;
}
```
![[Pasted image 20251021215222.png]]

```cpp
std::map<std::string, int> m {
    { "Chris", 31 }, { "CS106L", 42 },
    { "Keith", 14 }, { "Nick", 51 },
    { "Sean", 35 },
};
for (const auto& pair : m) {
    std::cout << pair.first << " ";
    std::cout << pair.second;
}
```

![[Pasted image 20251021215259.png]]

```cpp
std::unordered_map<string, int> m
{
    { "Chris", 31 }, { "Nick", 51 },
    { "Sean", 35 },
};
for (const auto& pair : m) {
    std::cout << pair.first << " ";
    std::cout << pair.second;
}
```
![[Pasted image 20251021215338.png]]
这样子大家回忆起来许多了吧！

然而他背后的本质是什么呢？

# 迭代器
### C++ 标准模板库（STL）组成部分
前面我们说了STL之一，容器。接下来我们说STL另外一部分内容，迭代器！
![[Pasted image 20251021215522.png]]
如果说容器是解决如何存储一组数据这个问题，那么迭代器（Iterators）：如何遍历容器中的数据？

### 问题：如何遍历容器？

对于向量容器，我们可以这样遍历：
```cpp
std::vector<int> v {1,2,3,4};
for (size_t i = 0; i < v.size(); i++) {
    const auto& elem = v[i];
}
```

通用的 for 循环结构如下：
```cpp
for (变量初始化; 循环条件; 变量递增) {
    const auto& elem = /* 获取元素 */;
}
```
这是一种很原始的迭代方式，无论你学习什么语言详细都会有这样类似的代码教学！
但是遍历元素，vector确实可以使用下标索引，但是如果是set类型的呢！
集合容器没有下标运算符，传统的下标遍历方式不再适用：
```cpp
std::set<int> s {1,2,3,4};
for (呃呃; 嗯嗯; 什么啊?) {
    const auto& elem = /* 求助 🥺🥺 */;
}
```
目前还不允许使用 `for (auto e : s)` 这种写法。

我们需要一种方式来跟踪当前在容器中的位置，类似于索引的作用。
那么铺垫这么久，主角登场了！

### 迭代器登场 😎😎

C++ 中的迭代器就像抓娃娃机里的 “爪子”。

（此处为抓娃娃机图片）

抓娃娃机的 “爪子” 能做三件事：

1. 抓住一个玩具（获取元素）
2. 向前移动（迭代器递增）
3. 判断是否抓取完成（判断是否到达容器末尾）

抓娃娃机本身能做两件事：

1. 告诉我们从哪里开始（获取容器起始迭代器）
2. 告诉我们什么时候停止（获取容器末尾迭代器）

### C++ 迭代器示例
```cpp
auto it = c.begin();  // 初始化迭代器，指向容器起始位置
++it;                 // 迭代器递增，向前移动
++it;                 // 迭代器递增，向前移动
++it;                 // 迭代器递增，向前移动
++it;                 // 迭代器递增，向前移动
auto elem = *it;      // 解引用迭代器，获取当前元素
++it;                 // 迭代器递增，向前移动
++it;                 // 迭代器递增，向前移动
it == c.end();        // 判断迭代器是否到达容器末尾
```
如下图：
![[Pasted image 20251021222618.png]]
容器和迭代器协同工作，实现对容器的遍历。

### 容器接口
- `container.begin()`：获取指向容器第一个元素的迭代器（假设容器非空）。
- `container.end()`：获取指向容器末尾的迭代器，即指向容器最后一个元素的下一个位置。
### 注意：end () 从不指向任何元素！

（此处为容器迭代器范围示意图）

- `c.begin()`：指向容器第一个元素。
- `c.end()`：指向容器最后一个元素的下一个位置，而非任何实际元素。
![[Pasted image 20251021223231.png]]

### 重要特性：空容器的迭代器

如果容器为空，那么 `begin()` 和 `end()` 返回的迭代器是相等的！

### 迭代器接口
```cpp
// 拷贝构造：创建一个新的迭代器，与原有迭代器指向同一位置
auto it = c.begin();

// 迭代器递增：将迭代器向前移动一个位置
++it;

// 迭代器解引用：获取当前指向的元素，若it == end()则行为未定义
auto elem = *it;

// 迭代器相等比较：判断两个迭代器是否指向同一位置
if (it == c.end()) ...
```

### 现在我们有答案了！

对于集合容器，我们可以使用迭代器进行遍历：
```cpp
std::set<int> s {1,2,3,4};
for (变量初始化; 循环条件; 变量递增) {
    const auto& elem = /* 获取元素 */;
}

// 逐步完善for循环
for (auto it = s.begin(); it != s.end(); ++it) {
    const auto& elem = *it;  // 通过解引用迭代器获取元素
}
```
目前还不允许使用 `for (auto e : s)` 这种写法。
### 范围 for 循环的本质
当你编写以下范围 for 循环时：
```cpp
for (auto elem : s) 
{
    std::cout << elem;
}
```

编译器实际上会将其转换为：
```cpp
auto b = s.begin();  // 获取容器起始迭代器
auto e = s.end();    // 获取容器末尾迭代器

for (auto it = b; it != e; ++it) {  // 使用迭代器遍历容器
    auto elem = *it;                // 解引用迭代器获取元素
    std::cout << elem;
}
```

### 迭代器的类型是什么？

使用 `auto` 关键字可以避免拼写冗长的迭代器类型。
```cpp
// 使用auto关键字（推荐）
std::map<int, int> m { {1, 2}, {3, 4}, {5, 6}};
auto it = m.begin();         // 自动推导迭代器类型
auto elem = *it;             // 自动推导元素类型（std::pair<int, int>）

// 显式指定类型（不推荐，代码冗长）
std::map<int, int> m { {1, 2}, {3, 4}, {5, 6}};
std::map<int, int>::iterator it = m.begin();  // 显式指定迭代器类型
std::pair<int, int> elem = *it;               // 显式指定元素类型
// 元素值为 {1, 2}
```

### 记住：使用 using 定义类型别名

在 `<map>` 头文件内部，map 类定义了迭代器的类型别名：
```cpp
template <typename K, typename V>
class std::map {
    using iterator = /* 某种迭代器类型 */;
};
```
在头文件外部（如 main.cpp 中），可以通过类型别名使用迭代器：
```cpp
std::map<int, int>::iterator it = m.begin();
```
迭代器类型通常非常冗长，因此我们更倾向于使用 `auto` 关键字来简化代码。

### 补充说明：为什么使用 ++it 而非 it++？

`++it`（前缀递增）可以避免创建不必要的副本，效率更高。
```cpp
// 前缀递增 ++it
// 递增迭代器，并返回对同一对象的引用
Iterator& operator++();

// 后缀递增 it++
// 递增迭代器，但返回旧值的副本
Iterator operator++(int);
```
记住：迭代器可能是功能完整的对象，因此复制迭代器通常比复制 int 等基本类型更耗时。
看不懂上面的代码没关系，++i就是先加上，然后存储到原值，内存占用永远是刚开始的那一块！而i++是先拷贝一份原值，然后在拷贝的内存上加上，然后再返回原始的内存地址！在循环这种情况下就会大量出现零时内存占用！
### 这真的会有区别吗？

“`++i` 有时比 `i++` 更快，而且永远不会更慢…… 因此，如果你只是将 `i++` 作为一条语句使用，而不是作为更大表达式的一部分，为什么不直接使用 `++i` 呢？你不会有任何损失，而且有时还会有所收获。”

—— 来自 Bjarne 的观点

### 动手实践
```cpp
std::map<int, int> m { 
    {1, 2}, {3, 4}, {5, 6}
};
auto a = m.begin();
++a;
auto b = a;
++a;
auto c = ++a;
```
与同伴一起跟踪这段代码，确定每个迭代器指向的位置。
自己尝试画出示意图，答案如下：
![[Pasted image 20251021225606.png]]

## 迭代器类型

并非所有迭代器都具备相同的功能。
### 所有迭代器都支持的四种操作
```cpp
auto it = c.begin();  // 1. 初始化：获取容器起始迭代器
++it;                 // 2. 递增：向前移动一个位置
*it;                  // 3. 解引用：获取当前元素
it == c.end();        // 4. 比较：判断是否到达容器末尾
```
但大多数迭代器还支持更多操作：
```cpp
--it;                 // 递减：向后移动一个位置
*it = elem;           // 修改：给当前元素赋值
it += n;              // 随机访问：向前移动n个位置
it1 < it2;            // 顺序比较：判断it1是否在it2之前
```

### 迭代器类型决定其功能

迭代器分为以下几类（按功能从弱到强排序）：

1. 输入迭代器（Input）
2. 输出迭代器（Output）
3. 前向迭代器（Forward）
4. 双向迭代器（Bidirectional）
5. 随机访问迭代器（Random Access）

让我们逐一解析每类迭代器的特性！

### 1. 输入迭代器（Input Iterators）

- 最基础的迭代器类型
- 仅支持读取元素，不支持修改元素
- 支持的操作：初始化、递增、解引用（读）、相等比较
#### 输入迭代器的 operator-> 操作

如果迭代器指向的元素是结构体（或类对象），可以使用 `->` 直接访问其成员。

“Bibble” 一词的含义：“吵闹地吃或喝”
```cpp
struct Bibble { 
    int zarf;  // 结构体成员
};

std::vector<Bibble> v {...};
auto it = v.begin();
int m = (*it).zarf;    // 方式1：先解引用，再访问成员
int m = it->zarf;      // 方式2：直接使用->访问成员，与方式1完全等价！
```

### 2. 输出迭代器（Output Iterators）

- 仅支持修改元素，不支持读取元素
- 支持的操作：初始化、递增、解引用（写）、相等比较
```cpp
*it = elem;  // 修改元素值
```

![[Pasted image 20251021231134.png]]

### 3. 前向迭代器（Forward Iterators）

- 兼具输入迭代器和输出迭代器的功能
- 支持多遍遍历（Multi-pass guarantee）
- 所有 STL 容器的迭代器都至少是前向迭代器
- 支持的操作：初始化、递增、解引用（读 / 写）、相等比较

多遍遍历保证：如果 `it1 == it2`，那么 `++it1 == ++it2`
![[Pasted image 20251021231251.png]]

#### 思考问题

哪些数据结构可能不支持多遍迭代器？答案：流（Streams）！例如输入流，读取后数据就无法再重新读取。原因是流为了一些性能上的考量，读过即丢！

### 4. 双向迭代器（Bidirectional Iterators）

- 在向前迭代器的基础上，增加了向后移动的功能
- 支持的容器：`std::map`（映射）、`std::set`（集合）
- 支持的操作：初始化、递增、递减、解引用（读 / 写）、相等比较
```cpp
auto it = m.end();     // 获取容器末尾迭代器
--it;                  // 递减迭代器，向后移动一个位置（指向最后一个元素）
auto& elem = *it;      // 解引用，获取最后一个元素
```
![[Pasted image 20251021231615.png]]

### 5. 随机访问迭代器（Random Access Iterators）

- 功能最强大的迭代器类型
- 支持快速向前 / 向后跳跃多个位置
- 支持的容器：`std::vector`（向量）、`std::deque`（双端队列）
- 支持的操作：初始化、递增、递减、随机访问（`+=`/`-=`）、解引用（读 / 写）、相等 / 不等比较、大小比较（`<`/`>`）
```cpp
auto it2 = it + 5;     // 向前跳跃5个位置
auto it3 = it2 - 2;    // 向后跳跃2个位置

// 获取第三个元素（索引为2）
auto& second = *(it + 2);  // 方式1：通过指针算术
auto& second = it[2];      // 方式2：通过下标运算符，与方式1等价
```
所以最开始我们最常见的下标访问的形式，他的迭代器类型还是很高级的！
![[Pasted image 20251021231709.png]]

### 注意：避免越界访问
```cpp
std::vector<int> v { 1, 2, 3 };
auto it = v.begin();
it += 3;                // 迭代器越界，指向容器末尾之后的位置
int& elem = *it;        // 未定义行为！可能导致程序崩溃或数据损坏
```
![[Pasted image 20251021231817.png]]
大家可能有一个疑惑，v.end()不就是指向最后一个元素的后一个位置吗，那为什么上面那个不行！其实不是不行，代码一直到it++3位置都是没有任何毛病的，但是问题出在最后一行代码，要知道的是end()这个迭代器是不允许解索引的！

### STL 迭代器类型总结
![[Pasted image 20251021232328.png]]
从功能弱到强排序：

1. 输入迭代器（Input）
2. 输出迭代器（Output）
3. 前向迭代器（Forward）：如 `unordered_map`、`unordered_set` 的迭代器
4. 双向迭代器（Bidirectional）：如 `map`、`set` 的迭代器
5. 随机访问迭代器（Random Access）：如 `vector`、`deque`、数组（Contig.）的迭代器

所有容器都有各自的迭代器类型，一定是属于上面的某一个类型！当然除开容器的迭代器，还有其他的内容，比如流的迭代器！
![[Pasted image 20251021233019.png]]
### 为什么迭代器类型很重要？

某些算法要求特定类型的迭代器才能正常工作！
```cpp
std::vector<int> vec{1,5,3,4};
std::sort(vec.begin(), vec.end()); 
// ✅ 正确：vector的迭代器是随机访问迭代器，sort算法需要随机访问迭代器

std::unordered_set<int> set {1,5,3,4};
std::sort(set.begin(), set.end()); 
// ❌ 错误：unordered_set的迭代器是前向迭代器，无法满足sort算法的要求
```
这个与算法的具体实现有关！

### 为什么需要多种迭代器类型？

1. 目标：为所有容器提供统一的抽象接口
2. 限制：容器的实现方式决定了其迭代器的功能
    - 对于顺序容器（如 vector、deque），随机访问（跳过 n 个位置）既简单又快速
    - 对于关联容器（如 map、set），随机访问则非常困难且缓慢

C++ 在设计上通常会避免提供效率低下的方法，因此 `map::iterator` 不支持随机访问操作。

## 指针与内存

- 迭代器指向容器中的元素
- 指针指向任意对象

### 内存基础
#### 内存基础概念 1：变量的存储

- 每个变量都存储在内存中的某个位置
- 所有可能的存储位置构成了地址空间
#### 程序的内存布局
当一个程序被加载到内存中执行时，操作系统会为它分配一块虚拟内存空间，并将其划分为几个**逻辑段（segments）**，每个段有不同的用途。
1. 文本段（Text）：存储程序指令
2. 全局变量（Global Variables）：存储全局变量和静态变量
3. 栈（Stack）：存储函数局部变量，自动分配和释放
4. 堆（Heap）：存储动态分配的内存，需要手动管理
5. 操作系统共享区（OS Shared）：与操作系统共享的内存区域
![[Pasted image 20251021233316.png]]

#### 内存基础概念 2：字节寻址

- 内存通常按字节寻址，每个字节都有一个唯一的编号（地址）
- 1 字节 = 8 位（bits）
- 在 64 位系统中，地址范围从 0 到 $2^{64} – 1$

#### 内存基础概念 3：对象的地址

- 对象的地址是其最低字节的位置
- 例如，一个整数（int）通常占用 32 位（4 字节）
```cpp
int x = 106;  // 32位整数，占用4字节内存
```
- 内存内容（二进制）：01101010 00000000 00000000 00000000
- 内存地址：0x10（最低字节）、0x11、0x12、0x13（最高字节）
- 变量 x 的地址是 0x10（最低字节的地址）

### 在 C++ 中如何获取变量的地址？
使用指针（Pointers）！👉 👉 👉（这个大名鼎鼎的东西）
#### 指针的定义

指针是变量的地址。
```cpp
// 定义一个int类型的变量x
int x = 106;

// 定义一个指向int类型的指针px，并将x的地址赋值给px
// int* 表示px是指向int类型的指针
// &是取地址运算符，用于获取变量的地址
int* px = &x;

// 输出结果
std::cout << x << std::endl;    // 输出变量x的值：106
std::cout << *px << std::endl;  // 输出指针px指向的变量值：106（*是解引用运算符）
std::cout << px << std::endl;   // 输出指针px的值（即x的地址）：0x50527c（地址值可能不同）
```

#### 指针本质上就是一个数字！
![[Pasted image 20251021235824.png]]
- 变量 x（int 类型）：存储值 106，占用地址 0x50527c~0x50527f
    - 内存内容：01101010 00000000 00000000 00000000
- 指针 px（int * 类型）：存储 x 的地址 0x50527c，占用 4 字节或 8 字节（取决于系统位数）
![[Pasted image 20251021235918.png]]

### 指针可以指向各种类型的对象！
```cpp
// 指向int类型变量的指针
int x = 106;
int* px = &x;

// 指向自定义结构体StanfordID的指针
StanfordID id { "jtrb" };
StanfordID* p = &id;
auto name = p->name;  // 通过指针访问结构体成员

// 指向vector容器的指针
std::vector<int> v;
std::vector<int>* p = &v;

// 指向vector容器中元素的指针（向量的底层是连续数组）
std::vector<int> v {1, 2, 3, 4, 5};
int* arr = &v[0];  // 获取第一个元素的地址
```

#### 记住：向量的底层是连续的数组

向量（vector）在内存中是连续存储的，类似于传统数组。

### 数组指针示例
```cpp
std::vector<int> v {1,2,3,4,5};

int* arr = &v[0];		std::cout << *arr << " ";  // 输出1
arr += 1; 					std::cout << *arr << " ";  // 输出2
++arr; 						std::cout << *arr << " ";  // 输出3
arr += 2; 					std::cout << *arr << " ";  // 输出5
if (arr == &v[4]) 		std::cout << "At last index";  // 输出"At last index"
```
![[Pasted image 20251022000228.png]]

### 发现相似之处了吗？
```cpp
std::vector<int> v {1,2,3,4,5};

int* arr = &v[0]; 
arr += 1;  // 随机访问：向前移动1个位置
++arr;     // 递增：向前移动1个位置
arr += 2;  // 随机访问：向前移动2个位置
if (arr == &v[4])  // 比较：判断是否指向最后一个元素
```
指针支持的操作：

- 拷贝构造
- 随机访问
- 指针递增
- 指针比较

### 迭代器也支持类似操作！
```cpp
auto it = v.begin(); 	std::cout << *it << " ";  // 输出1
it += 1; 							std::cout << *it << " ";  // 输出2
++it; 								std::cout << *it << " ";  // 输出3
it += 2; 							std::cout << *it << " ";  // 输出5
if (it == --v.end()) 	std::cout << "At last element";  // 输出"At last element"
```
迭代器和指针具有相似的接口！

### 记住：迭代器是类型别名

在 vector 类的定义中，迭代器是通过类型别名定义的：
```cpp
template <typename T>
class vector {
    using iterator = /* 某种迭代器类型 */;

    // 其他实现细节...
};
```

#### vector 迭代器的底层类型

对于 vector 容器，其迭代器的底层类型实际上是指针：
```cpp
template <typename T>
class vector {
    using iterator = T*;  // vector的迭代器本质上是指向T类型的指针

    // 其他实现细节...
};
```
注意：在实际的 STL 实现中，迭代器的真实类型并非简单的 T*（通常是封装了指针的类），但为了理解方便，我们可以将其视为指针。

### 思考问题：如何实现其他容器的迭代器？

对于 map 等容器，其迭代器的类型是什么？
```cpp
template <typename K, typename V>
class map {
    using iterator = ???????;  // map的迭代器类型是什么？

    // 其他实现细节...
};
```
答案将在下次课程揭晓！