## 上一讲内容：IntVector 类
大家记得他吗，上一讲我们提到过的，其实在容器那里也提到了！
```cpp
// 实现一个int类型的序列容器
class IntVector {
public:
    IntVector();   // 默认构造函数
    ~IntVector();  // 析构函数

    size_t size();  // 返回容器中元素个数
    bool empty();   // 判断容器是否为空

    void push_back(const int& elem);  // 向容器尾部添加元素
    int& operator[](size_t index);    // 重载[]运算符，访问指定索引元素
};
```

### 问题：IntVector 的局限性

你会发现需要处理多种类型的容器：

- 存储 std::string 的 Vector？
- 存储 double 的 Vector？
- 存储 stringVector 的 Vector？
- 存储尚未定义的自定义类型的 Vector？

#### IntVector 过于具体（问题示例）
```cpp
// 存储int的容器
class IntVector {
    // 存储int列表的代码...
};

// 存储double的容器
class DoubleVector {
    // 存储double列表的代码...
};

// 存储string的容器
class StringVector {
    // 存储string列表的代码...
};
```

#### 解决方案：模板类
```cpp
// 模板类：用T表示通用类型
template <typename T>
class vector {
    // 通用的容器实现代码，无需重复编写
};

// 使用模板类：指定具体类型
vector<int> v1;        // int类型的vector
vector<double> v2;     // double类型的vector
vector<string> v3;     // string类型的vector
```
## `std::vectorT`
这种语法是如何工作的？
# 模板类

### 模板的历史背景（问题）
在模板出现前，为不同类型编写容器需要大量重复代码：
```cpp
// 存储int的容器
class IntVector {
public:
    int& at(size_t index);
    void push_back(const int& elem);
private:
    int* elems;          // 存储元素的指针
    size_t logical_size; // 实际元素个数
    size_t array_size;   // 底层数组容量
};

// 存储double的容器（重复代码）
class DoubleVector {
public:
    double& at(size_t index);
    void push_back(const double& elem);
private:
    double* elems;
    size_t logical_size;
    size_t array_size;
};

// 存储string的容器（继续重复代码）
class StringVector {
public:
    string& at(size_t index);
    void push_back(const string& elem);
private:
    string* elems;
    size_t logical_size;
    size_t array_size;
};
```
(上面代码是一个简版的，连构造函数都没有，为了教学所以简便，大家不要学习！后续也是采用简版的内容！)
### 早期解决方案：预处理宏
```cpp
// 定义宏：生成指定类型的Vector类
#define GENERATE_VECTOR(MY_TYPE) 				\
class MY_TYPE##Vector { 							\ 
public: 														\ 
    MY_TYPE& at(size_t index); 					\ 
    void push_back(const MY_TYPE& elem); \ 
private: 														\ 
    MY_TYPE* elems; 										\ 
    size_t logical_size; 							\ 
    size_t array_size; 								\ 
}; 

// 注：预处理宏在编译前执行
```
很是复杂吧，看不懂不要紧，知道他是宏就可以！
## 宏
宏是什么，**宏** 是 C/C++ 中一种由 **预处理器（Preprocessor）** 处理的文本替换机制。
听不懂没有关系！不管他，毕竟随着时代发展他在慢慢被抛弃！但是我要说的是内部一个机制的运行！首先，先说说预处理器：在编译器真正开始编译代码**之前**，会先运行一个叫“预处理器”的工具。它负责处理所有以 `#` 开头的指令，比如 `#include`, `#define`, `#ifdef` 等。
首先告诉大家，要生成具体的机器码，必须保证函数与类的声明与实现的代码都存在！
所以结合前面零星提到的一些编译过程的内容，总结一个c++编译的全过程：
所有 C++ 的编译过程是这样的：

1. **有一个或多个源码文件**（如 `main.cpp`、`StudentID.cpp` 等）。 
    每个 `.cpp` 文件是一个独立的**编译单元**（translation unit），通常对应一个功能模块。
    
2. **对每个 `.cpp` 文件，分别运行预处理器**：（**预处理阶段**：） 
    
    - 处理所有以 `#` 开头的指令（如 `#include "StudentID.h"`、`#define N 100`、`#ifdef DEBUG` 等）；
    - 将头文件（`.h` 或 `.hpp`）的内容**原样插入**到 `#include` 的位置；（也就是把所有声明加上）
    - 展开宏、移除注释、处理条件编译；
    - 最终生成一个“纯净”的、不含预处理指令的 C++ 代码文件（称为**翻译单元**）。
    
    > 🔸 注意：**预处理器只读取 `.h` 文件，不会自动查找或包含其他 `.cpp` 文件！**
    
3. **将每个预处理后的翻译单元交给编译器，分别编译成目标文件（`.o` 或 `.obj`）**：（**编译阶段**：）
    
    - 编译器对每个 `.cpp`（及其展开后的头文件内容）进行词法分析、语法分析、语义检查和代码生成；
    - 如果某个函数或变量在当前 `.cpp` 中被使用但未定义（例如 `main.cpp` 调用了 `StudentID::getID()`，但定义在 `StudentID.cpp` 中），编译器会**保留一个外部符号引用**，不报错；
    - 每个 `.cpp` 文件独立生成一个 `.o` 文件（例如 `main.o`、`StudentID.o`）；
    - 这就是所谓的**分离编译**（separate compilation）。
4. **最后，链接器（linker）将所有目标文件（`.o`）和所需的库文件合并**：(**链接阶段**：)
    
    - 链接器解析各个 `.o` 文件中的**外部符号引用**（如 `main.o` 中引用的 `StudentID::getID`）；
    - 在其他 `.o` 文件或标准库（如 `libstdc++.a`）中查找这些符号的**实际定义**；
    - 如果所有引用都能找到定义，则合并所有代码和数据，生成最终的**可执行程序**（如 `main.exe` 或 `a.out`）；
    - 如果有未解析的符号（如漏掉了某个 `.cpp` 文件），链接器会报 **“undefined reference” 错误**。
5. **运行这个可执行程序**：
    
    - 操作系统加载可执行文件到内存；
    - 从 `main()` 函数开始执行程序逻辑；
    - 程序结束，返回退出状态码。
在本节对应的讲座代码上，。我们编译的时候是这样的命令：`g++ -fdiagnostics-color=always -g main.cpp StudentID.cpp -o main.exe`。这个过程相当于完成了上面的2-4步！

大家要好好体会这个过程，方便领会下文模板类实现的一些内容的讲解！
#### 宏的使用方式
```cpp
#include "grandmas_template.h"

// 生成intVector类
GENERATE_VECTOR(int)

int main() {
    intVector v1;
    v1.push_back(5);  // 使用生成的intVector类
}
```
#### 宏生成的代码（编译前展开）
```cpp
#include "grandmas_template.h"

// 宏展开后生成的intVector类
class intVector { 
public: 
    int& at(size_t index); 
    void push_back(const int& elem); 
private: 
    int* elems; 
    size_t logical_size; 
    size_t array_size; 
}; 

int main() {
    intVector v1;
    v1.push_back(5);
}
```

#### 宏的问题

- 语法繁琐，可读性差
- 难以进行类型检查（编译前展开，编译器无法提前验证）
- 容易出错：忘记调用宏或重复调用宏会导致编译问题
模板类登上了历史的舞台。

### 核心思想：模板自动生成代码

模板解决了宏的缺陷，能在编译时根据指定类型自动生成代码。

#### 模板类的声明
```cpp
// 模板声明：Vector是一个接受类型参数T的模板
template <typename T>
class Vector {
public:
    T& at(size_t index);          // 成员函数返回T类型引用
    void push_back(const T& elem); // 参数为const T类型引用
private:
    T* elems;  // 指向T类型数组的指针
};
```

#### 模板实例化

当指定具体类型时，编译器会生成对应类型的类代码（按需生成）：
```cpp
// 实例化不同类型的Vector
Vector<int> intVec;          // int类型的Vector
Vector<double> doubleVec;    // double类型的Vector
Vector<std::string> strVec;  // string类型的Vector

// 嵌套实例化：Vector中存储Vector<int>
Vector<Vector<int>> vecVec;

// 自定义类型实例化
struct MyCustomType {};
Vector<MyCustomType> structVec;  // 自定义结构体类型的Vector
```

#### 模板实例化的原理
```cpp
// 模板定义（编译器未生成实际代码）
template <typename T>
class Vector {
    T& at(size_t index);
    // 更多成员函数...
};

// 当编写以下代码时...
Vector<int> v;

// 编译器会自动生成类似以下的代码（int类型专用版）
class IntVector {
    int& at(size_t index);
    // 更多成员函数...
};

IntVector v;
```
#### 模板好比 “工厂”
- 模板：`template <typename T> class Vector`（生产类的 “工厂”）
- 输入类型`int` → 生成`Vector<int>`（int 类型的容器类）
- 输入类型`string` → 生成`Vector<string>`（string 类型的容器类）
至于具体的实现过程，没有办法像讲宏一样的详细，可能涉及一些汇编的知识，我们这里不讲杂了，反正他就是一个工厂，可以神奇的在编译阶段生产各种类的实例！

### 模板与类型的区别

|类别|代码示例|说明|
|---|---|---|
|模板|`template <typename T> class Vector`|不是具体类型，是生成类型的 “蓝图”|
|类型|`Vector<std::string>`|模板实例化后的具体类型，又称 “模板实例”|

#### 模板类型不兼容示例
```cpp
// 函数参数为std::vector<int>类型
void foo(std::vector<int> v);

int main() {
    std::vector<double> v;  // 定义std::vector<double>类型变量
    foo(v);  // 错误：无从std::vector<double>到std::vector<int>的转换
}
```
#### 关键注意点

`Vector<double>`和`Vector<int>`是**完全不同的类型**（无论编译时还是运行时），即使它们来自同一个模板。

（思考：对比 Java 中的`ArrayList<int>`和`ArrayList<double>`，它们在运行时共享相同的类型）
所以大家需要记住在c++中确定好的类型一般都是无法转换的，虽然存在一些隐式转换但是也是有方法避免的！

### 有趣的事实
1.**typename 可替换为 class**：在模板参数声明中，`typename`和`class`含义完全相同。
```cpp
// 以下两种写法等价
template <typename T> class Vector{};
template <class T> class Vector{};
```
2.**非类型模板参数**：模板参数不仅可以是类型（如`typename T`），还可以是常量值。
```cpp
// 布尔值作为模板参数
template <bool B> class BoolTemplate {};
BoolTemplate<true> b;  // 实例化时传入true

// 无符号整数作为模板参数
template <size_t N> class SizeTemplate {};
SizeTemplate<5> s;     // 实例化时传入5
```
3.**std::array 示例**：`std::array`是使用非类型模板参数的典型案例，其大小在编译时确定。
```cpp
template <typename T, std::size_t N> 
struct std::array { /* ... */ };

// 定义一个存储5个string的array
std::array<std::string, 5> arr;
```
（为什么用 array 而不用 vector？array 避免堆内存分配，编译器能确定其大小（大小被编码到类型中），因此可在栈上分配）这段话的具体解释是：vector这个类型中，他是自动有一个指针的，当我们实例化时，这个指针就会自动会new一个对应的内存，让这个指针指向这个内存的地址（这个指针是自动管理的，会自己删除！）！对比array他是没有这个指针的。大家会问那我想要改变存储大小岂不是要重新申请内存，这不是很麻烦吗！没错，但是我们可以自己定义指针去调节指针位置，所以大家不需要去运行代码申请内存！然后大家又会问，那和vector有什么区别，只不过指针是自己写的罢了，而且没了自动管理，我们需要自己写new，写deleta，一旦是指针麻烦的情况下，很容易出错啊！但是重点在于vector的内存是申请在堆中的，而array是在栈中的，前面我们说过栈的内存是比堆更加接近底层的，那么他的释放于申请性能花销没有那么大。所以在数值存储大小固定的情况下我们还是推荐使用array的，但是在动态变换的情况，还是vector比较稳妥！

## 模板的几个 “小怪癖”

### （1）实现模板类时需重复模板声明
#### 错误示例
```cpp
// Vector.h（头文件）
template <typename T>
class Vector {
public:
    T& at(size_t i);  // 声明成员函数
};

// Vector.cpp（源文件）- 错误写法
T& Vector::at(size_t i) {  // 编译器报错：不知道T是什么类型
    // 实现代码...
}
```

#### 正确示例（步骤 1：添加模板声明）
```cpp
// Vector.cpp（源文件）- 部分正确
template <typename T>  // 重复模板声明
T& Vector::at(size_t i) {  // 仍有错误：Vector不是具体类型
    // 实现代码...
}
```
#### 正确示例（步骤 2：指定模板参数）
```cpp
// Vector.cpp（源文件）- 完全正确
template <typename T>
T& Vector<T>::at(size_t i) {  // 用Vector<T>表示具体类型
    // 实现代码...
}
// 编译器：“哦，现在我明白了 😌😌”
```

### （2）头文件（.h）需在末尾包含源文件（.cpp）
#### 普通类的实现方式

对于非模板类，源文件包含头文件：
```cpp
// StrVector.h（头文件）
class StrVector {
public:
    string& at(size_t i);  // 声明
};

// StrVector.cpp（源文件）
#include "StrVector.h"  // 源文件包含头文件

string& StrVector::at(size_t i) 
{
    // 实现代码...
}
```

#### 模板类的实现方式
对于模板类，头文件需包含源文件：
```cpp
// Vector.h（头文件）
template <typename T>
class Vector {
public:
    T& at(size_t i);  // 声明
};

#include "Vector.cpp"  // 头文件末尾包含源文件

// Vector.cpp（源文件）
template <typename T>
T& Vector<T>::at(size_t i) {  // 实现
    // 实现代码...
}
```
#### 为什么要这样做？

- 原因：模板代码的生成依赖编译器在实例化时能看到完整的实现（包括头文件和源文件），这是由 C++ 的编译和链接机制决定的。
上面两个内容是不是把大家搞晕了，确实比较难一理解！那么我来试图解释一下：
假设你写了一个模板类 `Vector`，你想把**声明**（长什么样）和**实现**（怎么工作）分开，就像普通类一样。
```cpp
// Vector.h
template <typename T>
class Vector {
public:
    T& at(size_t i); // 我只说“有这个函数”，但不说它“怎么做”
};
```

```cpp
// Vector.cpp
T& Vector<T>::at(size_t i) { // 我在这里说“它是这么做的”
    // ...
}
```
### 问题来了：编译器“看不懂”
当你在 `main.cpp` 中写：
```cpp
#include "Vector.h"
int main() {
    Vector<int> vec;
    vec.at(0); // 编译器需要知道 at 函数的代码！
}
```
编译器会：

1. 看到 `#include "Vector.h"`，知道了 `Vector` 是个模板，有个 `at` 函数。
2. 看到 `Vector<int> vec;`，决定要生成一个具体的 `Vector<int>` 类。也就是把类的声明加入到main中了！
3. 看到 `vec.at(0);`，需要生成调用 `at` 函数的代码。
4. **但它在 `Vector.h` 里只看到了 `at` 的声明，没看到实现！**
5. 它去编译 `Vector.cpp`，但 `Vector.cpp` 里写着 `T& Vector<T>::at...`，而 `Vector.cpp` **自己并不知道 `T` 是 `int` 还是 `double`**，所以它无法生成具体代码。
6. 最终，链接时找不到 `Vector<int>::at` 的实现，**链接错误**！
问题就是出现在第5步，他把头文件中的声明确实加在vector.cpp里面了，但是由于无法有具体的实现代码，所以出现了断裂！
### 解决方案：让实现“可见”
编译器必须在**实例化点**（比如 `main.cpp` 里）看到 `at` 函数的完整代码。怎么做到？
#### 方法：在头文件中包含实现文件
```cpp
// Vector.h
#ifndef VECTOR_H
#define VECTOR_H

template <typename T>
class Vector {
public:
    T& at(size_t i);
};

//关键一步：把实现“粘贴”进来
#include "Vector.cpp" // 这行代码的意思是：
                   // “把 Vector.cpp 的内容复制到这里”

#endif
```

```cpp
// Vector.cpp
// 注意：这个文件现在更像是一个“代码片段”，不是独立编译的
template <typename T> // 必须写！告诉编译器：下面的 T 是模板参数
T& Vector<T>::at(size_t i) {
    // 实现...
    return data[i];
}
```
#### 现在编译器是怎么工作的？

当你在 `main.cpp` 中 `#include "Vector.h"` 时，预处理器会：

1. 把 `Vector.h` 的内容展开。
2. 遇到 `#include "Vector.cpp"`，就把 `Vector.cpp` 的内容也展开进来。
所以，`main.cpp` 实际上“看到”了这样的代码：
```cpp
// （这是 main.cpp 实际“看到”的）
template <typename T>
class Vector {
public:
    T& at(size_t i);
};

template <typename T> // 从 Vector.cpp 粘贴进来的
T& Vector<T>::at(size_t i) {
    // 实现...
}
// ... 其他代码
```
现在，当编译器遇到 `Vector<int> vec; vec.at(0);` 时：

- 它**已经看到了** `at` 函数的完整定义！
- 它可以顺利地用 `int` 替换 `T`，生成 `Vector<int>::at` 的具体代码。
所以就是因为c++是分开编译的，所以在编译vector.cpp的时候死活不知道T的类型，没办法，只好把文件内容复制到头文件中，这个时候声明与实现是一起的，那么在编译main的时候，引入.h，int就刚好可以传进去！（事实就是这样的，具体的类型如果不是直接的引用的文件，是传不进去的！）正是因为要等待具体的类型传入，所以造就了模板类与普通类的最大区别：普通类在编译到实例化那行代码之前，所有的类代码的机器码就已经生成了，而模板类他在编译到实例化的那行代码之气那，虽然大部分的代码的机器码生成了，但是关于类型的那一部分还是空的，是用引用符代替的，所以全部的机器码生成是在实例化这行代码编译完成后形成的！

所以这个包含源文件在头文件中的方法并没有解决机器码.o文件的生成问题，仅仅是在编译main文件的时候，把声明与实现的代码一起传入main中！大家去细细品味这整个的编译过程！

好，大家在理清楚这个过程后告诉大家一些忠告：
1.注意在编译讲座中我们给的代码的时候，不要再g++ Vector.cpp main.cpp -o main！这样是会报错的！这个时候应该是g++ main.cpp -o main
2.在Vector.cpp文件中不要再#include vector.h！（加不加都可以，但是最好不加！）
3.Vector.cpp最好不要叫这个名字，最好是Vector.tpp!
4.一定要确保实现源文件只能被定义一次！也就是被编译一次！（不过这是局部的，也就是在一个cpp文件中，函数与类只能够被编译一次！第一个问题的原因就是在main这一个cpp中编译了好几次！）

为什么呢，首先第一点的原因是，这样会造成重复编译，首先单独编译Vector.cpp（这个时候要在Vector.cpp加上#include vector.h不然会报错！），这里定义了一次，然后我们编译main，由于main中加入了#include vector.h，而vector.h是include vector.cpp的，那么这个时候会编译第二次，这样会进入**ODR**的大坑！
第二点是因为，我们都不去单独编译Vector.cpp了，加不加就无所谓了！但是如果你为了不让ide亮灯，可以加上！
第三点就是，一般的大型项目中会使用make等工具去编译，他会自动的把所以cpp文件都编译然后链接！所以改为tpp后缀更加好！

如果大家觉得太复杂了，为了实现一个模板类，搞这么多东西，实在是不懂！那就按照原始方法来，把实现与声明全部放到头文件中！
### 为什么每个函数前都要 `template <typename T>`？
**每个模板函数的定义都是独立的**，所以每个都需要这个“开关”来告诉编译器：“我是一个模板函数，`T` 是模板参数”。而且是每个函数前面都要加！

不懂也没有关系，记住这个特性就好，这门课也不是教大家去到c++委员会任职的，认识其特性就好！后续还会介绍更多的模板类的实现类型！所以记住这两个重要的东西！

### （3）typename 与 class 完全等价

在模板参数声明中，`typename`和`class`可以任意替换，以下写法均完全相同：
```cpp
// 写法1：两个参数都用typename
template <typename K, typename V>
struct pair;

// 写法2：两个参数都用class
template <class K, class V>
struct pair;

// 写法3：混合使用
template <class K, typename V>
struct pair;
```

## const 正确性

### 问题场景：使用 const Vector
```cpp
// 打印const Vector<int>的内容
void printVec(const Vector<int>& v) {
    for (size_t i = 0; i < v.size(); i++) {  // 编译器报错：无size方法
        std::cout << v.at(i) << " ";         // 编译器报错：无at方法
    }
    std::cout << std::endl;
}
```
#### 明明有 size 方法，为什么报错？
```cpp
template<class T> 
class Vector {
public:
    size_t size();          // 非const成员函数
    bool empty();           // 非const成员函数

    T& operator[] (size_t index); 
    T& at(size_t index);
    void push_back(const T& elem);
};
```

原因：将`v`声明为`const`后，我们承诺不修改`v`，但编译器无法确定`size()`和`at()`是否会修改对象（成员函数默认有权访问并修改成员变量）。
```cpp
template<class T> 
class Vector {
public:
    size_t size() const;    // const成员函数：承诺不修改对象
    bool empty() const;     // const成员函数：承诺不修改对象

    T& operator[] (size_t index); 
    T& at(size_t index) const;  // const成员函数
    void push_back(const T& elem);
};
```
const 成员函数的含义：“亲爱的编译器，我保证在这个函数内部不修改当前对象，请监督我。——Jacob 😘”

#### 实现的源文件中也要添加 const
```cpp
// 实现const成员函数时，必须在参数列表后添加const
template <class T>
size_t Vector<T>::size() const {
    return logical_size;
}

// 如果尝试在const成员函数中修改成员变量...
template <class T>
size_t Vector<T>::size() const {
    this->logical_size = 106; // 😈😈😈 错误！
    return logical_size;
}
// 编译器报错：无法在const成员函数中给非静态数据成员赋值
```
大家发现没有，为什么`T& operator[]`与`T& at`不用加const，这是因为const的添加并非是类的锁，而是一种访问的限制！解释起来就是这样：const实例化类后，他的目的是为了确保在类规定的可以改变对象的成员函数中改变，防止在类没规定可以改变对象的成员函数中改变对象！额，大家好好品味！所以const对象是只能访问类中被声明为const的函数与变量的！
不光是模板类，自定义的类也要注意这方面的内容！

#### const 成员函数中的 this 指针类型
```cpp
// 非const成员函数中，this的类型为 Point*
void Point::setX(int x)
{
    this->x = x;
}

// const成员函数中，this的类型为 const Point*
int Point::getX() const
{
    return this->x;
}
```

### const 接口

- 被声明为`const`的对象，只能调用其`const`成员函数（即 “const 接口”）。
- const 接口由类中所有`const`成员函数组成。
原类型：
```cpp
template<class T> 
class Vector {
public:
	size_t size() const;
	bool empty() const;
	void push_back(const T& elem);
private:
	size_t logical_size;
	T* elems;
};
```
const后的类型：
```cpp
template<class T> 
class Vector {
public:
	size_t size() const;
	bool empty() const;
	void push_back(const T& elem);
private:
	const size_t logical_size;
	const T* elems;
};
```
这个转变是自动的！（其实本质上这个const是没有加的，只是const对象会自动声明为只读，这样的效果就是与加上const是一样的！）所以记住，以后定义类的时候，在头文件与cpp实现文件中，逻辑上不改变对象的成员函数必须要在后面加上const，其他的函数不用。然后成员变量也不用，他会自动的转变，至于为什么函数不可以自动转变，这个就涉及更加深刻的内容，我们这里不继续深入探讨！

那么回到我们的vector类：
```cpp
template<class T> 
class Vector {
public:
    size_t size() const;    // 添加const
    bool empty() const;     // 添加const

    T& operator[] (size_t index); 
    T& at(size_t index) const;  // 添加const
    void push_back(const T& elem);
};
```

#### 修正后的 printVec 函数（编译通过）
```cpp
void printVec(const Vector<int>& v) {
    for (size_t i = 0; i < v.size(); i++) {
        std::cout << v.at(i) << " ";
    }
    std::cout << std::endl;
}
```

但是
### 新问题：const 成员函数的返回值
观察以下代码，思考是否存在问题：
```cpp
template<class T> 
class Vector {
public:
    size_t size() const;
    bool empty() const;

    T& operator[] (size_t index); 
    T& at(size_t index) const;  // 返回非const引用
    void push_back(const T& elem);
};
```

#### 问题 1：const 对象的成员被意外修改

由于`at()`返回非 const 引用，即使对象是`const`，也能通过引用修改其成员：
```cpp
// 错误示例：修改const对象的成员
void oops(const Vector<int>& v) {
    v.at(0) = 42;  // 编译通过，但违反了const承诺！
}
```
原因：`v`是`const`对象，本不应被修改，但`at()`返回的非 const 引用允许修改。

#### 解决方案 1：返回 const 引用
```cpp
template<class T> 
class Vector {
public:
    size_t size() const;
    bool empty() const;

    T& operator[] (size_t index); 
    const T& at(size_t index) const;  // 返回const引用
    void push_back(const T& elem);
};
```
#### 问题 2：非 const 对象无法修改成员

如果`at()`只提供 const 版本，非 const 对象也无法通过`at()`修改成员：
```cpp
// 错误示例：非const对象无法修改成员
void ooh(Vector<int>& v) {
    v.at(0) = 42;  // 错误：无法给const int&赋值
}
```
#### 解决方案 2：const 重载（提供两个版本的 at ()）

为`at()`提供两个版本：一个用于 const 对象，一个用于非 const 对象。
```cpp
template<class T> 
class Vector {
public:
    // const版本：用于const对象，返回const引用
    const T& at(size_t index) const;
    // 非const版本：用于非const对象，返回非const引用
    T& at(size_t index);
};
```
（cpp文件的实现）
```cpp
// const版本实现：返回const引用
template <class T>
const T& Vector<T>::at(size_t index) const {
    return elems[index];
}

// 非const版本实现：返回非const引用
template <class T>
T& Vector<T>::at(size_t index) {
    return elems[index];
}
```


### 扩展：findElement 函数的 const 重载

假设我们为 Vector 添加`findElement`函数，用于查找指定值并返回其引用。
#### 函数声明
```cpp
template<class T> 
class Vector {
public:
    T& at(size_t index);
    const T& at(size_t index) const;
    // findElement的两个版本
    T& findElement(const T& value);
    const T& findElement(const T& value) const;
};
```

#### 重复的实现（问题）
如果直接实现两个版本，会出现大量重复代码：
```cpp
// 非const版本
template <typename T>
T& Vector<T>::findElement(const T& value) {
    for (size_t i = 0; i < logical_size; i++) {
        if (elems[i] == value) return elems[i];
    }
    throw std::out_of_range("Element not found");
}

// const版本（重复代码）
template <typename T>
const T& Vector<T>::findElement(const T& value) const {
    for (size_t i = 0; i < logical_size; i++) {
        if (elems[i] == value) return elems[i];
    }
    throw std::out_of_range("Element not found");
}
```
这样真的很麻烦，一旦在大型的项目中，一个很复杂的函数也是要这样，就真的很无语！

### 优化：使用 const_cast 避免重复代码

#### 知识点：const_cast

- 作用：移除变量的 const 属性（“cast away const-ness”）。
- 语法：`const_cast<目标类型>(表达式)`。
- 注意：仅在确保变量实际是非 const 时使用，否则会导致未定义行为。
#### 优化后的 findElement 实现
```cpp
// 非const版本（保留原实现）
template <typename T>
T& Vector<T>::findElement(const T& value) {
    for (size_t i = 0; i < logical_size; i++) {
        if (elems[i] == value) return elems[i];
    }
    throw std::out_of_range("Element not found");
}

// const版本（调用非const版本，避免重复代码）
template <typename T>
const T& Vector<T>::findElement(const T& value) const {
    // 步骤1：*this是const Vector<T>&，通过const_cast移除const
    // 步骤2：调用非const版本的findElement
    // 步骤3：返回值自动转换为const T&
    return const_cast<Vector<T>&>(*this).findElement(value);
}
```
1. `*this`：在 const 成员函数中，`this`是`const Vector<T>*`，解引用后得到`const Vector<T>&`。
2. `const_cast<Vector<T>&>(...)`：将`const Vector<T>&`转换为`Vector<T>&`（移除 const 属性）。
3. `.findElement(value)`：调用非 const 版本的`findElement`，返回`T&`。
4. 返回值：`T&`自动转换为`const T&`（符合 const 版本的返回类型）。
### 何时使用 const_cast？

- 简短回答：几乎不用。
- 原因：`const_cast`本质是告诉编译器 “别担心，我知道自己在做什么”，但这会绕过 const 的安全检查。
- 建议：如果需要修改变量，一开始就不要将其声明为 const。
- 例外：极少数场景下（如上述避免代码重复），`const_cast`是合理的，但需格外谨慎。

### 更精细的控制：mutable 关键字
`const_cast`会让整个对象变为可修改，而`mutable`关键字可以让类的某个成员变量在 const 对象中仍可修改。
#### mutable 的使用方式
```cpp
struct MutableStruct {
    int dontTouchThis;       // 普通成员变量：const对象中不可修改
    mutable double iCanChange;  // mutable成员变量：const对象中仍可修改
};

int main() {
    const MutableStruct cm;
    // cm.dontTouchThis = 42;  // ❌ 错误：const对象的普通成员不可修改
    cm.iCanChange = 3.14;     // ✅ 正确：mutable成员可修改
}
```
#### mutable 示例：存储调试信息
```cpp
struct CameraRay {
    Point origin;        // 普通成员：const对象中不可修改
    Direction direction; // 普通成员：const对象中不可修改
    mutable Color debugColor;  // mutable成员：用于存储调试颜色
};

// 渲染const CameraRay
void renderRay(const CameraRay& ray) {
    ray.debugColor = Color::Yellow;  // ✅ 允许修改调试颜色（不影响核心数据）
    /* 渲染逻辑... */
}
```

这一节内容多而杂，而且我掺杂了许多编译方面的内容，大家可以好好品味！