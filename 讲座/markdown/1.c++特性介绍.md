首先，大家无需怀疑C++之后的发展前景，至今c++的使用率仍然是排在市场的前列！当然，由于最近ai的爆火，已经python语言的加持，c++进一步被使用！课程的话，这是2021年与2025年冬季课程，可以于cs106B一同上，也可以上完cs106B后再来上，或者直接来当然前提是学习过一门高级语言（python，Java都可以）！这门课会讲一些基础的语法结构等，但是不会大包大揽，不过不必担心，这门课会教你如何阅读c++官方文档学习（没有比这个更加全的c++语法教程了！），一下是这门课程要求：
- 了解 C++ 具备的特性及其存在的意义
- 能够熟练阅读 C++ 官方文档（附上文档地址：https://en.cppreference.com/w/  这是中文版的，如果大家英语不错，那么直接读英文！）
- 熟悉现代 C++ 的设计理念
- **不要求**死记硬背 C++ 语法

然后开始吧！顺便附上课程链接：
https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1254/（24年冬）
https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1212/（21年冬）

# c++的使用场景
### 深度学习框架基于 C++ 构建
比如：
```cpp
// 一个（微小的）调整：我们使用对数计算来提高数值稳定性（涉及 tog_probs 和 log_alpha）
// 该函数返回损失值（loss）和阿尔法值（alphas），阿尔法值会保留用于反向传播步骤。
// 下方的包装函数（ctc_loss）仅返回损失值，向用户隐藏了阿尔法值。
template<typename scalar_t, ScalarType target_scalar_type>
std::tuple<tensor, tensor> ctc_loss_cpu(const tensor& log_probs, const tensor& targets,
                                        const int_array& input_lengths, const int_array& target_lengths, int64_t BLANK) {
    // log_probs（对数概率）：维度为 input_len（输入长度）× batch_size（批次大小）× num_labels（标签数量）
    // targets（目标值）[int64 类型]：维度为 batch_size×target_length 或总长度为 sum(target_Lengths)（目标长度之和）
    constexpr scalar_t neginf = -std::numeric_limits<scalar_t>::infinity();
    using target_t = typename std::conditional<target_scalar_type == kInt, int, int64_t>::type;

    CheckedFrom c = "ctc_loss_cpu";
    auto log_probs_arg = TensorArg(log_probs, "log_probs", 1);
    auto targets_arg = TensorArg(targets, "targets", 2);
    checkScalarType(c, targets_arg, target_scalar_type);
    checkDim(c, log_probs_arg, 3);
    checkDimRange(c, targets_arg, 1, 3);

    int64_t batch_size = log_probs.size(1);
    int64_t num_labels = log_probs.size(2);
    TORCH_CHECK((0 <= BLANK) && (BLANK < num_labels), "空白标签（blank）必须在标签范围内");
    TORCH_CHECK((int64_t)input_lengths.size() == batch_size, "输入长度数组（input_lengths）的大小必须等于批次大小（batch_size）");
    TORCH_CHECK((int64_t)target_lengths.size() == batch_size, "目标长度数组（target_lengths）的大小必须等于批次大小（batch_size）");

    size_t tg_target_stride;
    int64_t max_target_length = 0;
    std::vector<int64_t> tg_batch_offsets(batch_size);
    
    if (targets.dim() == 1) { // 若为拼接后的目标值（concatenated targets）
        int64_t pos = 0;
        for (int64_t i = 0; i < batch_size; i++) {
            tg_batch_offsets[i] = pos;
            pos += target_lengths[i];
            if (max_target_length < target_lengths[i]) {
                max_target_length = target_lengths[i];
            }
        }
    }
    // （注：代码片段此处未完整展示，剩余逻辑需结合完整框架代码理解）
```
无需懂得上面的代码，知道深度学习依赖于cpp即可！或者把他理解成一个简易版的英伟达的cuda！

### 使用 C++ 的企业
- 亚马逊（[amazon.com](https://amazon.com/)）
- 脸书（[facebook.com](https://facebook.com/)）
- 英特尔（Intel）
- IBM（国际商业机器公司）
- 谷歌（Google）
- 微软（Microsoft）
当然国内的话各大互联网虽然以Java为主，但是仍然在招收大量的C++工程师！而如大疆这种偏向硬件或者嵌入式的，就是以C++为主了！国内统计不完全，但是可以肯定的是C++工程师仍然是市场的香饽饽，尽管是在大模型的冲击下！

### 用 C++ 编写的浏览器
比如Chrome、Firefox等等！

### 用 C++ 编写的软件
- Java 运行环境(没错，Java编译器都是c++写的)
- Microsoft Office（微软办公软件）
- Adobe Photoshop（PS，图像处理软件）
- Windows 操作系统
- YouTube（视频平台后端部分）

### 用 C++ 开发的游戏

- 《刺客信条》（ASSASSIN'S CREED）
- 《魔兽世界》（WORLD OF WARCRAFT）
- 《传送门 2》（PORTAL 2）
- 《反恐精英 2》
- 《无畏契约》
![[Pasted image 20251017160217.png]]
![[Pasted image 20251017160236.png]]
你玩过几款！

### 其他基于 C++ 的重要应用

- F-35“闪电 Ⅱ” 联合攻击战斗机：其系统大量依赖 C++ 编写
- “勇气号” 火星车：原计划任务周期约 3 个月，实际依靠 C++ 相关系统运行了超过 6 年

如此广泛的应用，c++一定有过人之处！
# C++ 的核心优势
#### 1. 运行速度快
![[Pasted image 20251013211037.png]]

（速度对比图表，展示 C++ 与 C、C#、Java、Perl、Python 等语言在不同操作系统（Linux、Windows、macOS）上的性能表现，C++ 速度通常接近 C，优于多数高级语言）

#### 2. 具备底层控制能力

编程语言底层控制能力层级（从高到低）：

- 高级语言：JavaScript、Perl、Scala、Java
- 中高级语言：C++
- 低级语言：C
- 底层语言：汇编语言（Assembly）、机器码（Machine Code）

# C++ 的历史
### 1. 示例代码

### 基础 C++ 代码（输出 “Hello, world!”）
```cpp
#include <iostream>
int main() {
    std::cout << "Hello, world!" << std::endl;
    return 0;
}
```
### 兼容 C 语言的 C++ 代码
```cpp
#include "stdlib.h"
#include "stdio.h"
int main(int argc, char *argv[]) {
    printf("%s", "Hello, world!\n"); // 调用C语言函数printf
    return EXIT_SUCCESS;
}
```
### 包含汇编指令的 C++ 代码（技术层面上的 C++ 代码）
```cpp
#include "stdio.h"
#include "stdlib.h"
int main(int argc, char *argv[]) {
    asm( "movabs $0x77202c6f6c6c6548, %rax\n\t" // 将字符串“Hello, ”的十六进制值移入rax寄存器
         "sub $0x20, %rsp\n\t" // 调整栈指针（为局部变量分配栈空间）
         "mov %rax, (%rsp)\n\t" // 将rax中的值存入栈指针指向的地址
         "movl $0x646c726f, 0x8(%rsp)\n\t" // 将“orld”的十六进制值存入栈偏移8字节处
         "movw $0x21, 0xc(%rsp)\n\t" // 将感叹号“!”的十六进制值存入栈偏移12字节处
         "movb $0x0, 0xd(%rsp)\n\t" // 在栈偏移13字节处存入字符串结束符“\0”
         "leaq (%rsp), %rax\n\t" // 将栈指针地址载入rax（获取字符串首地址）
         "call __Z6myputsPc\n\t" // 调用自定义函数myputs（参数为字符串首地址）
         "mov %rax, %rdi\n\t" // 将函数返回值移入rdi寄存器（用于后续系统调用）
         "add $0x20, %rsp\n\t" // 恢复栈指针（释放栈空间）
    );
```
### 汇编语言代码（C++ 历史源头）
```nasm
section .text
global _start ; 必须声明，供链接器（ld）识别
_start: ; 告诉链接器程序入口点
    mov edx, len ; 将消息长度存入edx寄存器
    mov ecx, msg ; 将消息（字符串）地址存入ecx寄存器
    mov ebx, 1 ; 文件描述符（stdout，标准输出）
    mov eax, 4 ; 系统调用号（sys_write，写入系统调用）
    int 0x80 ; 调用内核（执行系统调用）
    
    mov eax, 1 ; 系统调用号（sys_exit，退出系统调用）
    int 0x80 ; 调用内核

section .data
msg db 'Hello, world!', 0xa ; 要输出的字符串（0xa为换行符）
len equ $ - msg ; 计算字符串长度（当前地址减去msg的地址）
```
没错，他的表现形式很多！

那么c++的由来就很有意思：
## 汇编语言的特点（这是一切编程语言的起点）
#### 优势

- 指令极其简单
- 运行速度极快（编写良好时）
- 对程序拥有完全控制能力

#### 劣势

- 完成简单任务也需要大量代码
- 代码可读性极差
- 可移植性极低（难以在不同系统上运行）

然后有两个人受不了计算机只能理解汇编语言，直接编写汇编代码效率极低，开发了一门叫C的语言（大家可以通过学习cs107去学习C语言）。
他们的想法是：

- 第一步：用更直观的语言编写源代码
- 第二步：通过一个额外程序将源代码转换为汇编语言（这个额外程序就是**编译器**）

#### C 语言的局限（既是优势也是劣势）

- 优势：语法简洁，易于上手。编写的代码兼具**快速性、简洁性和跨平台性**。
- 劣势：
    - 不支持面向对象的 “对象” 和 “类” 概念
    - 难以编写通用型代码
    - 开发大型程序时繁琐且易出错

但是由于不支持面向对象，这几乎会错过编程中最伟大的思想之一，所以又有个人受不了，目标是打造一门兼具以下特性的语言：

- 运行速度快
- 使用简单
- 跨平台
- 支持高级语言特性（如面向对象）其实比起C语言，多的就是第四条！

于是C++诞生了！

## C++ 的设计理念

### 理念 1：赋予程序员更多选择权（代价是更多责任）

- 示例：支持底层内存直接访问（如指针操作），程序员可自主管理内存，但需承担内存泄漏、野指针等风险。
“low-level memory access” 是计算机领域的常用术语，指直接对计算机内存（如物理内存地址、内存块）进行操作的能力，不经过高级语言的自动内存管理机制（如 Java 的垃圾回收、Python 的内存池）。在 C++ 中，通常通过指针（pointer）实现底层内存访问，例如直接分配、释放内存（`new`/`delete`）或操作特定内存地址的数据。这种特性让程序能更高效地利用内存资源，但也要求开发者手动处理内存生命周期，避免内存泄漏、野指针等问题，体现了 C++“赋予程序员控制权” 的设计理念。

### 理念 2：在编译阶段捕获错误（代价是语法稍显繁琐）

- 示例：强制（或近乎强制）的类型声明，变量、函数参数等必须明确类型，编译时可检测出类型不匹配错误，减少运行时错误。
1. **术语解析**：“mandatory-ish typing” 是编程语言类型系统中的描述性术语，“mandatory” 意为 “强制的”，后缀 “-ish” 表示 “近似、近乎”，整体指一种 “以强制为主、兼具少量灵活性” 的类型规则。
2. **C++ 中的体现**：在 C++ 中，变量声明、函数参数及返回值等必须明确指定数据类型（如 `int a = 5;` `void func(double b);`），编译器会严格检查类型匹配（例如不能直接将字符串赋值给整型变量），这是 “强制” 的体现；同时允许有限的隐式类型转换（如 `int c = 3.14;` 会自动截断为整数 3，需开发者主动规避风险），这是 “近乎强制” 中 “灵活性” 的部分。
3. **设计理念关联**：这种类型规则正是 C++“在编译阶段捕获错误” 设计理念的体现 —— 通过强制类型声明，编译器可在编译时发现绝大多数类型不匹配错误，避免程序运行时因类型问题崩溃，代价则是相比弱类型语言（如 Python）多了类型声明的代码量，显得稍繁琐。

### 理念 3：封装复杂结构（降低使用难度）

- 示例：智能指针（如`unique_ptr`、`shared_ptr`），将内存管理的复杂逻辑封装在类内部，程序员无需手动调用`delete`释放内存，降低内存泄漏风险。
1. **术语定义**：“smart pointers” 是 C++ 标准库提供的一种封装类（位于`<memory>`头文件中），核心功能是自动管理动态分配的内存（即通过`new`分配的内存），避免手动使用`delete`释放内存时可能出现的内存泄漏、野指针等问题，本质是 “用对象管理资源”（RAII 设计思想）的典型实现。
    
2. **常见类型及作用**：
    
    - `std::unique_ptr`：独占式智能指针，同一时间仅允许一个指针指向某块内存，当指针生命周期结束（如离开作用域）时，自动释放内存，适用于 “资源唯一归属” 的场景（如单个对象的内存管理）。
    - `std::shared_ptr`：共享式智能指针，允许多个指针共同指向同一块内存，通过 “引用计数” 记录指向该内存的指针数量，当引用计数变为 0 时自动释放内存，适用于 “资源多对象共享” 的场景（如容器中存储的对象被多个模块访问）。
    - `std::weak_ptr`：弱引用智能指针，通常与`std::shared_ptr`配合使用，不增加引用计数，仅用于观察`std::shared_ptr`管理的内存，可解决`std::shared_ptr`可能出现的 “循环引用” 导致内存无法释放的问题。
3. **与设计理念的关联**：智能指针完美体现了 C++“封装复杂结构” 的设计理念 —— 将内存管理的复杂逻辑（如引用计数更新、内存释放时机判断）隐藏在类内部，开发者无需关注底层实现，只需像使用普通指针一样调用智能指针，即可安全高效地管理内存，降低了底层操作的复杂度和出错风险。

不要怀疑c++的用户范围，显然在AI的带飞下，他的受欢迎程度仅次于python：
![[Pasted image 20251017161121.png]]