看下面这段代码：
```cpp
std::string returnNameCheckPawsome(Pet p) {
    /// 注：狗比猫更受欢迎（dogs>cats）
    if (p.type() == "Dog" || p.firstName() == "Fluffy") {
        std::cout << p.firstName() << " " << p.lastName() << " is paw-some!" << '\n';
    }
		return p.firstName() + " " + p.lastName();
}
```
问：有多少条执行路径（就是问大家代码执行情况分为几种！）
p.type() == "Dog"这里一种。
p.firstName() == "Fluffy"这里两种。
return p.firstName() + " " + p.lastName();这里第三种！
是 3 条吗？
## 异常（Exceptions）

异常是处理代码中出现错误的一种方式。

异常会被 “抛出”（thrown）。

不过，我们可以编写代码来处理异常，从而让程序能够继续执行，而不一定会直接报错。

我们把这种操作称为 “捕获”（catching）异常。具体实现代码如下：
```cpp
try {
    // 需要检查异常的代码块
} catch ([异常类型] e1) {
    // “如果”捕获到该类型异常，执行此处代码
    // 遇到错误时的处理逻辑
} catch ([其他异常类型] e2) {
    // “否则如果”捕获到该类型异常，执行此处代码
    // ……
} catch {
    // “否则”（捕获所有未明确指定类型的异常）
    // 通用异常捕获（哈哈）
}
```
所以上面给的代码到底有多少条代码执行路径？
至少有 23 条！

- （1）Pet 的拷贝构造函数可能抛出异常
- （5）临时字符串的构造函数可能抛出异常
- （6）调用 type ()、firstName ()（3 次）、lastName ()（2 次）可能抛出异常
- （10）用户重载的运算符可能抛出异常
- （1）返回字符串的拷贝构造函数可能抛出异常
加起来23种！

```cpp
std::string returnNameCheckPawsome(int petId) {
    Pet* p = new Pet(petId);
    if (p.type() == "Dog" || p.firstName() == "Fluffy") {
        std::cout << p.firstName() << " " << p.lastName() << " is paw-some!" << '\n';
    }
    std::string returnStr = p.firstName() + " " + p.lastName();
    delete p;
    return returnStr;
}
```
如果函数在下列这些地方出现异常怎么办：
p.type() == "Dog"
std::cout << p.firstName()
p.firstName() + " " + p.lastName()

看到这里，大家心里可能会说，你是不是有点大病，这么说任何代码都会报错，从头错到尾，那何止23种，有多少运算符，多少变量就有多少报错！其实理论上确实是这样的！但是我们在这里不讨论这种极端情况！这23种并非是极端思维，而是有来源的，在现代 C++（特别是采用 **RAII** 和 **异常安全** 设计的代码）中，我们必须考虑**任何函数调用都可能抛出异常**。

那抛出异常后，会带来的最严重的问题是资源的释放！程序崩溃不可怕，可怕的是程序在崩溃前**留下了未清理的烂摊子**（内存没释放、文件没关闭、锁没解开）。
### 这并非指针独有的问题！

实际上，有许多资源在获取后都需要手动释放。

| 资源类型             | 获取操作（Acquire）  | 释放操作（Release） |
| ---------------- | -------------- | ------------- |
| 堆内存（Heap memory） | new            | delete        |
| 文件（Files）        | 打开（open）       | 关闭（close）     |
| 锁（Locks）         | 尝试加锁（try_lock） | 解锁（unlock）    |
| 套接字（Sockets）     | 创建（socket）     | 关闭（close）     |

如何确保在发生异常时，资源仍能被正确释放？
## 资源获取即初始化（RAII）

RAII：Resource Acquisition Is Initialization（资源获取即初始化）
它是 C++ 等语言中一个极具代表性的概念。

### 什么是 RAII？

- 类所使用的所有资源，都应在构造函数中获取；
- 类所使用的所有资源，都应在析构函数中释放。

### 为什么需要 RAII？

遵循 RAII 原则可以避免 “半有效” 状态（“half-valid” states）。

无论发生什么情况，当资源超出作用域时，析构函数一定会被调用。

另外还有一点：资源 / 对象在创建后可立即使用。

### 以下代码是否符合 RAII 规范？
```cpp
void printFile() {
    ifstream input;
    input.open("hamlet.txt"); // 手动打开文件，非构造函数中获取资源
    string line;
    while (getline(input, line)) { // 此处可能抛出异常
        std::cout << line << std::endl;
    }
    input.close(); // 手动关闭文件，非析构函数中释放资源
}
```
不符合！文件的打开和关闭操作在代码中手动执行，而非在构造函数和析构函数中完成。

```cpp
1 void cleanDatabase(mutex databaseLock, map<int, int>& db) {
2     databaseLock.lock(); // 手动加锁，非构造函数中获取资源
3     // 其他线程或设备无法修改数据库
4     // 修改数据库（若此处抛出异常，锁将永远无法释放）
5     database.unlock(); // 手动解锁，非析构函数中释放资源
6 }
```
也不符合！如果3和4行（我们称之为 “临界区”，critical section）中的代码抛出异常，锁将永远无法解锁。

### 如何修复上述问题？
```cpp
void cleanDatabase(mutex& databaseLock, map<int, int>& db) {
    lock_guard<mutex> lg(databaseLock); // 构造函数中加锁
    // 其他线程或设备无法修改数据库
    // 修改数据库（即使此处抛出异常，互斥锁也会被解锁）
    // 无需显式解锁，lock_guard会自动处理
}
```
`lock_guard`是一个符合 RAII 规范的包装类，它会尝试获取传入的锁，并在自身超出作用域时自动释放该锁。更多详情可参考相关文档。
所以这里想要告诉大家的就是，在c++中，任何的关于资源获取与资源释放的代码一定要放在构造函数与析构函数中，因为资源的正确获取与释放是c++的重中之重！也许大家会侥幸认为代码不会报错，所以对资源的行为不加小心，但是一旦就如上文所说，任何的代码，任何一处地方理论上都会出错！
所以，记住这个口诀：

> **“与其在代码里处处小心，不如让对象自己管好自己。”**

这就是 RAII 的哲学。
那么rall是怎么实现的呢？
## 智能指针（Smart Pointers）

- 锁的 RAII 实现 → `lock_guard`（锁守卫）
- 内存的 RAII 实现 → 智能指针

### 准则 R.11：避免显式调用 new 和 delete

#### 原因

`new`返回的指针应属于一个能调用`delete`的资源句柄。如果将`new`返回的指针赋值给一个普通（裸）指针，对应的对象可能会发生内存泄漏。

#### 注意

在大型程序中，裸`delete`（即直接在应用代码中调用`delete`，而非在专门的资源管理代码中调用）很可能是错误的。如果你使用了`new`，如何确保不需要多调用一次（N+1）或少调用一次（N-1）`delete`？这类 bug 可能具有潜伏性，仅在代码维护阶段才会显现。如果代码中有裸`new`，那么很可能需要在某处配合裸`delete`—— 而这往往会引入 bug。

#### 实施建议

（简单规则）对任何显式使用`new`和`delete`的代码发出警告，并建议使用`make_unique`替代。

### 还记得这段代码吗？
```cpp
std::string returnNameCheckPawsome(int petId) {
    Pet* p = new Pet(petId);
    if (p.type() == "Dog" || p.firstName() == "Fluffy") {
        std::cout << p.firstName() << " " << p.lastName() << " is paw-some!" << '\n';
    }
    std::string returnStr = p.firstName() + " " + p.lastName();
    delete p;
    return returnStr;
}
```
我们是如何处理锁的？
- 创建一个新对象，在构造函数中获取资源，在析构函数中释放资源。
### 内存的 RAII 实现该如何做？

我们可以采用相同的思路 —— 创建 “包装” 指针，这类指针被称为 “智能指针”！

### 智能指针可视化
![[Pasted image 20251101140156.png]]
包含 “智能指针类”（Smart Pointer Class）和 “动态获取的资源”（Dynamically Acquired Resource）两部分。具体来说是这样的，一般我们new是会申请一个堆上的内存，然后a = new...
会让a这个变量存储指向这个内存的指针！然而智能指针类就是代替a，如果只是单纯的普通的指针变量a，我们需要手动的释放内存！有了这个智能指针类，他就是一个对象，有析构函数与构造函数，那么一旦我们程序结束，这个对象会调用析构函数释放内存，无需我们手动操作！这样就实现了rall的思想，是不是很妙！

符合 RAII 规范的智能指针主要有三种类型：

1. `std::unique_ptr`（独占指针）
    - 独占所指向的资源，无法被拷贝。
2. `std::shared_ptr`（共享指针）
    - 可以被拷贝，当所有指向该内存的共享指针都超出作用域时，内存才会被释放。
3. `std::weak_ptr`（弱指针）
    - 用于解决代码中的循环依赖问题，避免内存泄漏。后续会详细讲解。
### 智能指针的代码示例
```cpp
// 裸指针版本
void rawPtrFn() {
    Node* n = new Node;
    // 使用n进行一些操作
    delete n; // 手动释放内存
}
```
不推荐
```cpp
// 智能指针版本（unique_ptr）
void rawPtrFn() {
    std::unique_ptr<Node> n(new Node);
    // 使用n进行一些操作
    // 无需手动释放，n超出作用域时会自动释放内存
}
```
推荐

### 为什么`unique_ptr`不能被拷贝？
```cpp
void rawPtrFn() {
    std::unique_ptr<Node> n(new Node);
    std::unique_ptr<Node> copy = n; // 编译错误！
}
```
试想一下：如果拷贝完成后，原指针`n`的析构函数被调用（例如`n`先超出作用域），会发生什么？
此时拷贝指针`copy`会指向已经被释放的内存，导致 “悬垂指针”

### `std::shared_ptr`（共享指针）

共享指针解决了`unique_ptr`无法拷贝的问题 —— 它不会在单个指针超出作用域时释放内存，而是等到**所有**指向该内存的共享指针都超出作用域后，才会释放内存。
![[Pasted image 20251101143145.png]]
- 数据部分（Data）：`T`类型对象（T Object）
- 共享指针部分（shared_ptr）：指向`T`的指针（Pointer to T）、指向控制块的指针（Pointer to Control Block）
- 控制块部分（Control Block）：引用计数（Reference Count）、弱计数（Weak Count）、自定义删除器（Custom Deleter）、分配器（Allocator）等）


### 智能指针的初始化方式
```cpp
// 方式1：直接使用new（不推荐）
std::unique_ptr<T> uniquePtr(new T);
std::shared_ptr<T> sharedPtr(new T);
std::weak_ptr<T> wp = sharedPtr; // 弱指针需从共享指针初始化

// 方式2：使用make系列函数（推荐）
std::unique_ptr<T> uniquePtr = std::make_unique<T>();
std::shared_ptr<T> sharedPtr = std::make_shared<T>();
std::weak_ptr<T> wp = sharedPtr;
```
### 为什么推荐使用`std::make_unique`和`std::make_shared`？

1. **避免内存泄漏风险**：如果不使用这两个函数，可能会发生两次内存分配（一次为指针本身，一次为`new T`创建的对象），在极端情况下（如分配过程中抛出异常）可能导致内存泄漏。
2. **代码一致性**：如果使用`make_unique`，建议同时使用`make_shared`，保持代码风格统一。

### `std::weak_ptr`（弱指针）

弱指针用于解决代码中的循环依赖问题，避免内存泄漏。

#### 循环依赖问题示例（错误用法）
```cpp
#include <iostream>
#include <memory>

// 前向声明
class B;

class A {
public:
    ~A() {
        std::cout << "A的所有资源已释放" << std::endl;
    }
    std::shared_ptr<B> ptr_to_b; // A持有指向B的共享指针
};

class B {
public:
    ~B() {
        std::cout << "B的所有资源已释放" << std::endl;
    }
    std::shared_ptr<A> ptr_to_a; // B持有指向A的共享指针
};

int main() {
    std::shared_ptr<A> shared_ptr_to_a = std::make_shared<A>();
    std::shared_ptr<B> shared_ptr_to_b = std::make_shared<B>();
    
    shared_ptr_to_a->ptr_to_b = shared_ptr_to_b; // A指向B
    shared_ptr_to_b->ptr_to_a = shared_ptr_to_a; // B指向A
    
    return 0;
}
```
问题：类 A 的实例`a`和类 B 的实例`b`互相持有对方的共享指针。这会导致它们的引用计数永远无法减至 0，内存永远无法释放，造成内存泄漏。

#### 循环依赖问题修复（正确用法）
```cpp
#include <iostream>
#include <memory>

// 前向声明
class B;

class A {
public:
    ~A() {
        std::cout << "A的所有资源已释放" << std::endl;
    }
    std::shared_ptr<B> ptr_to_b; // A仍持有指向B的共享指针
};

class B {
public:
    ~B() {
        std::cout << "B的所有资源已释放" << std::endl;
    }
    std::weak_ptr<A> ptr_to_a; // B持有指向A的弱指针（关键修改）
};

int main() {
    std::shared_ptr<A> shared_ptr_to_a = std::make_shared<A>();
    std::shared_ptr<B> shared_ptr_to_b = std::make_shared<B>();
    
    shared_ptr_to_a->ptr_to_b = shared_ptr_to_b;
    shared_ptr_to_b->ptr_to_a = shared_ptr_to_a; // 弱指针不会增加引用计数
    
    return 0;
}
```
修复原理：类 B 中不再使用共享指针持有 A，而是使用弱指针。弱指针不会增加 A 的引用计数，因此当`main`函数中的`shared_ptr_to_a`超出作用域时，A 的引用计数减为 0，资源被释放；A 释放后，B 的引用计数也随之减为 0，B 的资源也会被释放。

这三种指针用到的场景不一样，都是智能指针！而智能指针仅仅是rall实现的一种方式，跟多的rall的实现需要大家在项目中去积累了！

## C++ 项目构建
## 编译快速入门

我们编写的 C++ 代码需要被翻译成计算机能理解的形式才能执行。
### 编译流程示例
1. **源代码（Source Code）**
```cpp
std::cout << "Hello World" << std::endl;
std::cout << "Welcome to CS106L" << std::endl;
for (char ch : "CS106L") {
    std::cout << ch << std::endl;
}
```
2. **编译器命令（Compiler Command）**
```bash
$ g++ main.cpp -o main  # 使用g++编译器，将main.cpp编译为可执行文件main
$ ./main                # 运行可执行文件main
```
3. **机器码（Machine Code）**
    
    （二进制代码，示例如下）
    
    10110101
    
    01011010
    
    10011101
    
    10110001
整个流程就是：
![[Pasted image 20251101144319.png]]

### 编译器命令各部分含义

- `g++`：所使用的编译器（GNU C++ 编译器）
- `main.cpp`：待编译的源代码文件
- `-o main`：指定编译生成的可执行文件名为`main`（`-o`是 “output” 的缩写）
- `./main`：在 Linux/macOS 系统中运行可执行文件`main`的命令
## Makefile 与 make 工具

`make`是一个帮助编译代码的 “构建系统” 工具，它支持：

- 指定要使用的编译器；
- 定义编译规则，自动处理文件依赖。

使用`make`工具需要先编写一个`Makefile`文件（文件名固定，无后缀）。

### Makefile 示例（对应第 7 讲代码）
```makefile
# 编译器设置
CXX = g++

# 编译器选项（使用C++20标准）
CXXFLAGS = -std=c++20

# 源文件与目标文件
SRCS = $(wildcard *.cpp)  # 匹配所有.cpp后缀的源文件
TARGET = main             # 目标可执行文件名

# 默认目标（输入make时自动执行）
all:
    $(CXX) $(CXXFLAGS) $(SRCS) -o $(TARGET)  # 编译命令

# 清理目标（输入make clean时执行）
clean:
    rm -f $(TARGET)  # 删除生成的可执行文件
```

## CMake 工具

CMake 是一个 “构建系统生成器”，可以用它来自动生成 Makefile（或其他构建系统的配置文件，如 Visual Studio 的解决方案文件）。它相当于 Makefile 的 “高层抽象” 工具，更适合跨平台项目。
### CMake 配置文件（CMakeLists.txt）示例
```cmake
# 指定所需的CMake最低版本
cmake_minimum_required(VERSION 3.10)

# 项目名称（此处为cs106l_classes）
project(cs106l_classes)

# 设置C++标准为C++20
set(CMAKE_CXX_STANDARD 20)

# 匹配所有.cpp后缀的源文件
file(GLOB SRC_FILES "*.cpp")

# 将源文件编译为可执行文件main
add_executable(main ${SRC_FILES})
```
### CMake 使用步骤

1. 在项目根目录下创建`CMakeLists.txt`文件（文件名固定）；
2. 创建`build`文件夹（用于存放编译生成的中间文件）：
```bash
mkdir build
```
3. 进入`build`文件夹：
```bash
cd build
```
4. 运行 CMake，生成 Makefile（`..`表示从上级目录的`CMakeLists.txt`读取配置）：
```bash
cmake ..
```
5. 运行`make`命令编译代码：
```bash
make
```
6. 像往常一样运行可执行文件：
```bash
./main
```

这个课程就顺利结束了！本课程信息量很大，需要大家在后续的实践中多加运用！